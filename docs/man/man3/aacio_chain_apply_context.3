.TH "aacio::chain::apply_context" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
aacio::chain::apply_context
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBapply_results\fP"
.br
.ti -1c
.RI "class \fBgeneric_index\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBapply_context\fP (\fBchain_controller\fP &con, \fBchainbase::database\fP &\fBdb\fP, const \fBaction\fP &a, const \fBtransaction_metadata\fP &trx_meta, uint32_t depth=0)"
.br
.ti -1c
.RI "void \fBexec\fP ()"
.br
.ti -1c
.RI "void \fBexecute_inline\fP (\fBaction\fP &&a)"
.br
.ti -1c
.RI "void \fBexecute_context_free_inline\fP (\fBaction\fP &&a)"
.br
.ti -1c
.RI "void \fBexecute_deferred\fP (\fBdeferred_transaction\fP &&trx)"
.br
.ti -1c
.RI "void \fBcancel_deferred\fP (const uint128_t &sender_id)"
.br
.ti -1c
.RI "void \fBrequire_authorization\fP (const \fBaccount_name\fP &\fBaccount\fP)"
.br
.RI "Require \fBaccount\fP to have approved of this message\&. "
.ti -1c
.RI "bool \fBhas_authorization\fP (const \fBaccount_name\fP &\fBaccount\fP) const"
.br
.ti -1c
.RI "void \fBrequire_authorization\fP (const \fBaccount_name\fP &\fBaccount\fP, const \fBpermission_name\fP &permission)"
.br
.ti -1c
.RI "void \fBrequire_write_lock\fP (const \fBscope_name\fP &scope)"
.br
.ti -1c
.RI "void \fBrequire_read_lock\fP (const \fBaccount_name\fP &\fBaccount\fP, const \fBscope_name\fP &scope)"
.br
.ti -1c
.RI "bool \fBis_account\fP (const \fBaccount_name\fP &\fBaccount\fP) const"
.br
.RI "exec() "
.ti -1c
.RI "void \fBrequire_recipient\fP (\fBaccount_name\fP \fBaccount\fP)"
.br
.ti -1c
.RI "bool \fBhas_recipient\fP (\fBaccount_name\fP \fBaccount\fP) const"
.br
.ti -1c
.RI "bool \fBall_authorizations_used\fP () const"
.br
.ti -1c
.RI "\fBvector\fP< \fBpermission_level\fP > \fBunused_authorizations\fP () const"
.br
.ti -1c
.RI "\fBvector\fP< \fBaccount_name\fP > \fBget_active_producers\fP () const"
.br
.ti -1c
.RI "const \fBbytes\fP & \fBget_packed_transaction\fP ()"
.br
.ti -1c
.RI "template<typename T > void \fBconsole_append\fP (\fBT\fP val)"
.br
.ti -1c
.RI "template<typename T , typename \&.\&.\&. Ts> void \fBconsole_append\fP (\fBT\fP val, Ts \&.\&.\&.rest)"
.br
.ti -1c
.RI "void \fBconsole_append_formatted\fP (const string &fmt, const \fBvariant_object\fP &vo)"
.br
.ti -1c
.RI "void \fBchecktime\fP (uint32_t instruction_count)"
.br
.ti -1c
.RI "int \fBget_action\fP (uint32_t type, uint32_t index, char *buffer, size_t buffer_size) const"
.br
.ti -1c
.RI "int \fBget_context_free_data\fP (uint32_t index, char *buffer, size_t buffer_size) const"
.br
.ti -1c
.RI "void \fBupdate_db_usage\fP (const \fBaccount_name\fP &payer, int64_t delta)"
.br
.ti -1c
.RI "void \fBcheck_auth\fP (const \fBtransaction\fP &trx, const \fBvector\fP< \fBpermission_level\fP > &perm)"
.br
.ti -1c
.RI "int \fBdb_store_i64\fP (uint64_t scope, uint64_t table, const \fBaccount_name\fP &payer, uint64_t id, const char *buffer, size_t buffer_size)"
.br
.ti -1c
.RI "void \fBdb_update_i64\fP (int iterator, \fBaccount_name\fP payer, const char *buffer, size_t buffer_size)"
.br
.ti -1c
.RI "void \fBdb_remove_i64\fP (int iterator)"
.br
.ti -1c
.RI "int \fBdb_get_i64\fP (int iterator, char *buffer, size_t buffer_size)"
.br
.ti -1c
.RI "int \fBdb_next_i64\fP (int iterator, uint64_t &primary)"
.br
.ti -1c
.RI "int \fBdb_previous_i64\fP (int iterator, uint64_t &primary)"
.br
.ti -1c
.RI "int \fBdb_find_i64\fP (uint64_t code, uint64_t scope, uint64_t table, uint64_t id)"
.br
.ti -1c
.RI "int \fBdb_lowerbound_i64\fP (uint64_t code, uint64_t scope, uint64_t table, uint64_t id)"
.br
.ti -1c
.RI "int \fBdb_upperbound_i64\fP (uint64_t code, uint64_t scope, uint64_t table, uint64_t id)"
.br
.ti -1c
.RI "int \fBdb_end_i64\fP (uint64_t code, uint64_t scope, uint64_t table)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "const \fBchain_controller\fP & \fBcontroller\fP"
.br
.ti -1c
.RI "const \fBchainbase::database\fP & \fBdb\fP"
.br
.RI "database where state is stored "
.ti -1c
.RI "const \fBaction\fP & \fBact\fP"
.br
.RI "message being applied "
.ti -1c
.RI "\fBaccount_name\fP \fBreceiver\fP"
.br
.RI "the code that is currently running "
.ti -1c
.RI "bool \fBprivileged\fP = false"
.br
.ti -1c
.RI "bool \fBcontext_free\fP = false"
.br
.ti -1c
.RI "bool \fBused_context_free_api\fP = false"
.br
.ti -1c
.RI "\fBchain_controller\fP & \fBmutable_controller\fP"
.br
.ti -1c
.RI "\fBchainbase::database\fP & \fBmutable_db\fP"
.br
.RI "Parallel to act\&.authorization; tracks which permissions have been used while processing the message\&. "
.ti -1c
.RI "\fBvector\fP< bool > \fBused_authorizations\fP"
.br
.ti -1c
.RI "const \fBtransaction_metadata\fP & \fBtrx_meta\fP"
.br
.ti -1c
.RI "\fBapply_results\fP \fBresults\fP"
.br
.ti -1c
.RI "\fBgeneric_index\fP< \fBcontracts::index64_object\fP > \fBidx64\fP"
.br
.ti -1c
.RI "\fBgeneric_index\fP< \fBcontracts::index128_object\fP > \fBidx128\fP"
.br
.ti -1c
.RI "\fBgeneric_index\fP< \fBcontracts::index256_object\fP, uint128_t *, const uint128_t * > \fBidx256\fP"
.br
.ti -1c
.RI "\fBgeneric_index\fP< \fBcontracts::index_double_object\fP > \fBidx_double\fP"
.br
.ti -1c
.RI "uint32_t \fBrecurse_depth\fP"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "void aacio::chain::apply_context::execute_inline (\fBaction\fP && a)"
This will execute an action after checking the authorization\&. Inline transactions are implicitly authorized by the current receiver (running code)\&. This method has significant security considerations and several options have been considered:
.PP
.IP "1." 4
priviledged accounts (those marked as such by block producers) can authorize any action
.IP "2." 4
all other actions are only authorized by 'receiver' which means the following: a\&. the user must set permissions on their account to allow the 'receiver' to act on their behalf
.PP
.PP
Discarded Implemenation: at one point we allowed any account that authorized the current transaction to implicitly authorize an inline transaction\&. This approach would allow privelege escalation and make it unsafe for users to interact with certain contracts\&. We opted instead to have applications ask the user for permission to take certain actions rather than making it implicit\&. This way users can better understand the security risk\&. 
.SS "bool aacio::chain::apply_context::has_recipient (\fBaccount_name\fP account) const"
Return true if the current action has already been scheduled to be delivered to the specified account\&. 
.SS "bool aacio::chain::apply_context::is_account (const \fBaccount_name\fP & account) const"

.PP
exec() 
.PP
\fBReturns:\fP
.RS 4
true if account exists, false if it does not 
.RE
.PP

.SS "void aacio::chain::apply_context::require_authorization (const \fBaccount_name\fP & account)"

.PP
Require \fBaccount\fP to have approved of this message\&. 
.PP
\fBParameters:\fP
.RS 4
\fIaccount\fP The account whose approval is required
.RE
.PP
This method will check that \fBaccount\fP is listed in the message's declared authorizations, and marks the authorization as used\&. Note that all authorizations on a message must be used, or the message is invalid\&.
.PP
\fBExceptions:\fP
.RS 4
\fItx_missing_auth\fP If no sufficient permission was found 
.RE
.PP

.SS "void aacio::chain::apply_context::require_recipient (\fBaccount_name\fP account)"
Requires that the current action be delivered to account 

.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
