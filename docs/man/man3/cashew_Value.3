.TH "cashew::Value" 3 "Sun Jun 3 2018" "AcuteAngleChain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cashew::Value
.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBcashew::Assign\fP, and \fBcashew::AssignName\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBType\fP { \fBString\fP = 0, \fBNumber\fP = 1, \fBArray\fP = 2, \fBNull\fP = 3, \fBBool\fP = 4, \fBObject\fP = 5, \fBAssign_\fP = 6, \fBAssignName_\fP = 7 }"
.br
.ti -1c
.RI "typedef \fBstd::unordered_map\fP< \fBIString\fP, \fBRef\fP > \fBObjectStorage\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBValue\fP (const char *s)"
.br
.ti -1c
.RI "\fBValue\fP (double n)"
.br
.ti -1c
.RI "\fBValue\fP (\fBArrayStorage\fP &a)"
.br
.ti -1c
.RI "void \fBfree\fP ()"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetString\fP (const char *s)"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetString\fP (const \fBIString\fP &s)"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetNumber\fP (double n)"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetArray\fP (\fBArrayStorage\fP &a)"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetArray\fP (size_t size_hint=0)"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetNull\fP ()"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetBool\fP (bool b)"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetObject\fP ()"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetAssign\fP (\fBRef\fP target, \fBRef\fP value)"
.br
.ti -1c
.RI "\fBValue\fP & \fBsetAssignName\fP (\fBIString\fP target, \fBRef\fP value)"
.br
.ti -1c
.RI "bool \fBisString\fP ()"
.br
.ti -1c
.RI "bool \fBisNumber\fP ()"
.br
.ti -1c
.RI "bool \fBisArray\fP ()"
.br
.ti -1c
.RI "bool \fBisNull\fP ()"
.br
.ti -1c
.RI "bool \fBisBool\fP ()"
.br
.ti -1c
.RI "bool \fBisObject\fP ()"
.br
.ti -1c
.RI "bool \fBisAssign\fP ()"
.br
.ti -1c
.RI "bool \fBisAssignName\fP ()"
.br
.ti -1c
.RI "bool \fBisBool\fP (bool b)"
.br
.ti -1c
.RI "bool \fBisArray\fP (\fBIString\fP name)"
.br
.ti -1c
.RI "const char * \fBgetCString\fP ()"
.br
.ti -1c
.RI "\fBIString\fP & \fBgetIString\fP ()"
.br
.ti -1c
.RI "double & \fBgetNumber\fP ()"
.br
.ti -1c
.RI "\fBArrayStorage\fP & \fBgetArray\fP ()"
.br
.ti -1c
.RI "bool & \fBgetBool\fP ()"
.br
.ti -1c
.RI "\fBAssign\fP * \fBasAssign\fP ()"
.br
.ti -1c
.RI "\fBAssignName\fP * \fBasAssignName\fP ()"
.br
.ti -1c
.RI "int32_t \fBgetInteger\fP ()"
.br
.ti -1c
.RI "\fBValue\fP & \fBoperator=\fP (const \fBValue\fP &\fBother\fP)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBValue\fP &\fBother\fP)"
.br
.ti -1c
.RI "char * \fBparse\fP (char *curr)"
.br
.ti -1c
.RI "void \fBstringify\fP (std::ostream &os, bool pretty=false)"
.br
.ti -1c
.RI "size_t \fBsize\fP ()"
.br
.ti -1c
.RI "void \fBsetSize\fP (size_t size)"
.br
.ti -1c
.RI "\fBRef\fP & \fBoperator[]\fP (unsigned x)"
.br
.ti -1c
.RI "\fBValue\fP & \fBpush_back\fP (\fBRef\fP r)"
.br
.ti -1c
.RI "\fBRef\fP \fBpop_back\fP ()"
.br
.ti -1c
.RI "\fBRef\fP \fBback\fP ()"
.br
.ti -1c
.RI "int \fBindexOf\fP (\fBRef\fP \fBother\fP)"
.br
.ti -1c
.RI "\fBRef\fP \fBmap\fP (std::function< \fBRef\fP(\fBRef\fP \fBnode\fP)> \fBfunc\fP)"
.br
.ti -1c
.RI "\fBRef\fP \fBfilter\fP (std::function< bool(\fBRef\fP \fBnode\fP)> \fBfunc\fP)"
.br
.ti -1c
.RI "\fBRef\fP & \fBoperator[]\fP (\fBIString\fP x)"
.br
.ti -1c
.RI "bool \fBhas\fP (\fBIString\fP x)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBType\fP \fBtype\fP"
.br
.ti -1c
.RI "union {"
.br
.ti -1c
.RI "   \fBIString\fP \fBstr\fP"
.br
.ti -1c
.RI "   double \fBnum\fP"
.br
.ti -1c
.RI "   \fBArrayStorage\fP * \fBarr\fP"
.br
.ti -1c
.RI "   bool \fBboo\fP"
.br
.ti -1c
.RI "   \fBObjectStorage\fP * \fBobj\fP"
.br
.ti -1c
.RI "   \fBRef\fP \fBref\fP"
.br
.ti -1c
.RI "}; "
.br
.in -1c

.SH "Author"
.PP 
Generated automatically by Doxygen for AcuteAngleChain from the source code\&.
