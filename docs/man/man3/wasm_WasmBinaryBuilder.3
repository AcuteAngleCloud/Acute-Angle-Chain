.TH "wasm::WasmBinaryBuilder" 3 "Sun Jun 3 2018" "AcuteAngleChain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
wasm::WasmBinaryBuilder
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBBreakTarget\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBWasmBinaryBuilder\fP (\fBModule\fP &wasm, \fBstd::vector\fP< char > &input, bool debug)"
.br
.ti -1c
.RI "void \fBread\fP ()"
.br
.ti -1c
.RI "void \fBreadUserSection\fP (size_t payloadLen)"
.br
.ti -1c
.RI "bool \fBmore\fP ()"
.br
.ti -1c
.RI "uint8_t \fBgetInt8\fP ()"
.br
.ti -1c
.RI "uint16_t \fBgetInt16\fP ()"
.br
.ti -1c
.RI "uint32_t \fBgetInt32\fP ()"
.br
.ti -1c
.RI "uint64_t \fBgetInt64\fP ()"
.br
.ti -1c
.RI "\fBLiteral\fP \fBgetFloat32Literal\fP ()"
.br
.ti -1c
.RI "\fBLiteral\fP \fBgetFloat64Literal\fP ()"
.br
.ti -1c
.RI "uint32_t \fBgetU32LEB\fP ()"
.br
.ti -1c
.RI "uint64_t \fBgetU64LEB\fP ()"
.br
.ti -1c
.RI "int32_t \fBgetS32LEB\fP ()"
.br
.ti -1c
.RI "int64_t \fBgetS64LEB\fP ()"
.br
.ti -1c
.RI "WasmType \fBgetWasmType\fP ()"
.br
.ti -1c
.RI "\fBName\fP \fBgetString\fP ()"
.br
.ti -1c
.RI "\fBName\fP \fBgetInlineString\fP ()"
.br
.ti -1c
.RI "void \fBverifyInt8\fP (int8_t x)"
.br
.ti -1c
.RI "void \fBverifyInt16\fP (int16_t x)"
.br
.ti -1c
.RI "void \fBverifyInt32\fP (int32_t x)"
.br
.ti -1c
.RI "void \fBverifyInt64\fP (int64_t x)"
.br
.ti -1c
.RI "void \fBungetInt8\fP ()"
.br
.ti -1c
.RI "void \fBreadHeader\fP ()"
.br
.ti -1c
.RI "void \fBreadStart\fP ()"
.br
.ti -1c
.RI "void \fBreadMemory\fP ()"
.br
.ti -1c
.RI "void \fBreadSignatures\fP ()"
.br
.ti -1c
.RI "\fBName\fP \fBgetFunctionIndexName\fP (Index i)"
.br
.ti -1c
.RI "void \fBgetResizableLimits\fP (\fBAddress\fP &initial, \fBAddress\fP &max, \fBAddress\fP defaultIfNoMax)"
.br
.ti -1c
.RI "void \fBreadImports\fP ()"
.br
.ti -1c
.RI "void \fBreadFunctionSignatures\fP ()"
.br
.ti -1c
.RI "\fBName\fP \fBgetNextLabel\fP ()"
.br
.ti -1c
.RI "void \fBreadFunctions\fP ()"
.br
.ti -1c
.RI "void \fBreadExports\fP ()"
.br
.ti -1c
.RI "\fBExpression\fP * \fBreadExpression\fP ()"
.br
.ti -1c
.RI "void \fBreadGlobals\fP ()"
.br
.ti -1c
.RI "void \fBprocessExpressions\fP ()"
.br
.ti -1c
.RI "\fBExpression\fP * \fBpopExpression\fP ()"
.br
.ti -1c
.RI "\fBExpression\fP * \fBpopNonVoidExpression\fP ()"
.br
.ti -1c
.RI "\fBName\fP \fBgetGlobalName\fP (Index index)"
.br
.ti -1c
.RI "void \fBprocessFunctions\fP ()"
.br
.ti -1c
.RI "void \fBreadDataSegments\fP ()"
.br
.ti -1c
.RI "void \fBreadFunctionTableDeclaration\fP ()"
.br
.ti -1c
.RI "void \fBreadTableElements\fP ()"
.br
.ti -1c
.RI "void \fBreadNames\fP (size_t)"
.br
.ti -1c
.RI "void \fBsetDebugLocations\fP (std::istream *sourceMap_)"
.br
.ti -1c
.RI "void \fBreadNextDebugLocation\fP ()"
.br
.ti -1c
.RI "void \fBreadSourceMapHeader\fP ()"
.br
.ti -1c
.RI "BinaryConsts::ASTNodes \fBreadExpression\fP (\fBExpression\fP *&curr)"
.br
.ti -1c
.RI "void \fBvisitBlock\fP (\fBBlock\fP *curr)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBgetMaybeBlock\fP (WasmType type)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBgetBlock\fP (WasmType type)"
.br
.ti -1c
.RI "void \fBvisitIf\fP (\fBIf\fP *curr)"
.br
.ti -1c
.RI "void \fBvisitLoop\fP (\fBLoop\fP *curr)"
.br
.ti -1c
.RI "\fBBreakTarget\fP \fBgetBreakTarget\fP (int32_t offset)"
.br
.ti -1c
.RI "void \fBvisitBreak\fP (\fBBreak\fP *curr, uint8_t code)"
.br
.ti -1c
.RI "void \fBvisitSwitch\fP (\fBSwitch\fP *curr)"
.br
.ti -1c
.RI "template<typename T > void \fBfillCall\fP (\fBT\fP *call, \fBFunctionType\fP *type)"
.br
.ti -1c
.RI "\fBExpression\fP * \fBvisitCall\fP ()"
.br
.ti -1c
.RI "void \fBvisitCallIndirect\fP (\fBCallIndirect\fP *curr)"
.br
.ti -1c
.RI "void \fBvisitGetLocal\fP (\fBGetLocal\fP *curr)"
.br
.ti -1c
.RI "void \fBvisitSetLocal\fP (\fBSetLocal\fP *curr, uint8_t code)"
.br
.ti -1c
.RI "void \fBvisitGetGlobal\fP (\fBGetGlobal\fP *curr)"
.br
.ti -1c
.RI "void \fBvisitSetGlobal\fP (\fBSetGlobal\fP *curr)"
.br
.ti -1c
.RI "void \fBreadMemoryAccess\fP (\fBAddress\fP &alignment, size_t bytes, \fBAddress\fP &offset)"
.br
.ti -1c
.RI "bool \fBmaybeVisitLoad\fP (\fBExpression\fP *&out, uint8_t code)"
.br
.ti -1c
.RI "bool \fBmaybeVisitStore\fP (\fBExpression\fP *&out, uint8_t code)"
.br
.ti -1c
.RI "bool \fBmaybeVisitConst\fP (\fBExpression\fP *&out, uint8_t code)"
.br
.ti -1c
.RI "bool \fBmaybeVisitUnary\fP (\fBExpression\fP *&out, uint8_t code)"
.br
.ti -1c
.RI "bool \fBmaybeVisitBinary\fP (\fBExpression\fP *&out, uint8_t code)"
.br
.ti -1c
.RI "void \fBvisitSelect\fP (\fBSelect\fP *curr)"
.br
.ti -1c
.RI "void \fBvisitReturn\fP (\fBReturn\fP *curr)"
.br
.ti -1c
.RI "bool \fBmaybeVisitHost\fP (\fBExpression\fP *&out, uint8_t code)"
.br
.ti -1c
.RI "void \fBvisitNop\fP (\fBNop\fP *curr)"
.br
.ti -1c
.RI "void \fBvisitUnreachable\fP (\fBUnreachable\fP *curr)"
.br
.ti -1c
.RI "void \fBvisitDrop\fP (\fBDrop\fP *curr)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBstd::vector\fP< \fBName\fP > \fBfunctionImportIndexes\fP"
.br
.ti -1c
.RI "\fBstd::vector\fP< \fBFunctionType\fP * > \fBfunctionTypes\fP"
.br
.ti -1c
.RI "size_t \fBnextLabel\fP"
.br
.ti -1c
.RI "\fBstd::vector\fP< \fBFunction\fP * > \fBfunctions\fP"
.br
.ti -1c
.RI "\fBstd::map\fP< Index, \fBstd::vector\fP< \fBCall\fP * > > \fBfunctionCalls\fP"
.br
.ti -1c
.RI "\fBFunction\fP * \fBcurrFunction\fP = nullptr"
.br
.ti -1c
.RI "Index \fBendOfFunction\fP = \-1"
.br
.ti -1c
.RI "\fBstd::map\fP< \fBExport\fP *, Index > \fBexportIndexes\fP"
.br
.ti -1c
.RI "\fBstd::vector\fP< \fBExport\fP * > \fBexportOrder\fP"
.br
.ti -1c
.RI "\fBstd::vector\fP< \fBBreakTarget\fP > \fBbreakStack\fP"
.br
.ti -1c
.RI "bool \fBbreaksToReturn\fP"
.br
.ti -1c
.RI "\fBstd::vector\fP< \fBExpression\fP * > \fBexpressionStack\fP"
.br
.ti -1c
.RI "BinaryConsts::ASTNodes \fBlastSeparator\fP = BinaryConsts::End"
.br
.ti -1c
.RI "\fBstd::map\fP< Index, \fBName\fP > \fBmappedGlobals\fP"
.br
.ti -1c
.RI "\fBstd::map\fP< Index, \fBstd::vector\fP< Index > > \fBfunctionTable\fP"
.br
.ti -1c
.RI "Function::DebugLocation \fBdebugLocation\fP"
.br
.ti -1c
.RI "\fBstd::unordered_map\fP< std::string, Index > \fBdebugInfoFileIndices\fP"
.br
.ti -1c
.RI "int \fBdepth\fP = 0"
.br
.in -1c

.SH "Author"
.PP 
Generated automatically by Doxygen for AcuteAngleChain from the source code\&.
