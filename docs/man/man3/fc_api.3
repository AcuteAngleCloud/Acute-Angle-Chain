.TH "fc::api< Interface, Transform >" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
fc::api< Interface, Transform >
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBfc::api_base\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBvtable\fP< Interface, Transform > \fBvtable_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename T > \fBapi\fP (const \fBT\fP &p)"
.br
.ti -1c
.RI "\fBapi\fP (const \fBapi\fP &cpy)"
.br
.ti -1c
.RI "virtual uint64_t \fBget_handle\fP () const override"
.br
.ti -1c
.RI "virtual api_id_type \fBregister_api\fP (\fBapi_connection\fP &conn) const override"
.br
.ti -1c
.RI "\fBvtable_type\fP & \fBoperator*\fP () const"
.br
.ti -1c
.RI "\fBvtable_type\fP * \fBoperator\->\fP () const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::shared_ptr< \fBvtable_type\fP > \fB_vtable\fP"
.br
.ti -1c
.RI "std::shared_ptr< fc::any > \fB_data\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "bool \fBoperator==\fP (const \fBapi\fP &a, const \fBapi\fP &b)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBapi\fP &a, const \fBapi\fP &b)"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename Interface, typename Transform = identity_member> template<typename T > \fBfc::api\fP< Interface, Transform >::\fBapi\fP (const \fBT\fP & p)\fC [inline]\fP"
\fBT\fP is anything with pointer semantics 
.SH "Member Function Documentation"
.PP 
.SS "template<typename Interface , typename Transform > api_id_type \fBfc::api\fP< Interface, Transform >::register_api (\fBapi_connection\fP & conn) const\fC [override]\fP, \fC [virtual]\fP"
It is slightly unclean tight coupling to have this method in the api class\&. It breaks encapsulation by requiring an api class method to have a pointer to an \fBapi_connection\fP\&. The reason this is necessary is we have a goal of being able to call \fBregister_api()\fP on an api<T> through its base class \fBapi_base\fP\&. But \fBregister_api()\fP must know the template parameters!
.PP
The only reasonable way to achieve the goal is to implement \fBregister_api()\fP as a method in api<T> (which obviously knows the template parameter \fBT\fP), then make the implementation accessible through the base class (by making it a pure virtual method in the base class which is overridden by the subclass's implementation)\&.
.PP
It is slightly unclean tight coupling to have this method in the api class\&. It breaks encapsulation by requiring an api class method to have a pointer to an \fBbinary_api_connection\fP\&. The reason this is necessary is we have a goal of being able to call \fBregister_api()\fP on an api<T> through its base class \fBapi_base\fP\&. But \fBregister_api()\fP must know the template parameters!
.PP
The only reasonable way to achieve the goal is to implement \fBregister_api()\fP as a method in api<T> (which obviously knows the template parameter \fBT\fP), then make the implementation accessible through the base class (by making it a pure virtual method in the base class which is overridden by the subclass's implementation)\&. 
.PP
Implements \fBfc::api_base\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
