.TH "gbench.util" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gbench.util
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "def \fBis_executable_file\fP (filename)"
.br
.ti -1c
.RI "def \fBis_json_file\fP (filename)"
.br
.ti -1c
.RI "def \fBclassify_input_file\fP (filename)"
.br
.ti -1c
.RI "def \fBcheck_input_file\fP (filename)"
.br
.ti -1c
.RI "def \fBfind_benchmark_flag\fP (prefix, benchmark_flags)"
.br
.ti -1c
.RI "def \fBremove_benchmark_flags\fP (prefix, benchmark_flags)"
.br
.ti -1c
.RI "def \fBload_benchmark_results\fP (fname)"
.br
.ti -1c
.RI "def \fBrun_benchmark\fP (exe_name, benchmark_flags)"
.br
.ti -1c
.RI "def \fBrun_or_load_benchmark\fP (filename, benchmark_flags)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBIT_Invalid\fP = 0"
.br
.ti -1c
.RI "int \fBIT_JSON\fP = 1"
.br
.ti -1c
.RI "int \fBIT_Executable\fP = 2"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
.nf
util.py - General utilities for running, loading, and processing benchmarks

.fi
.PP
 
.SH "Function Documentation"
.PP 
.SS "def gbench\&.util\&.check_input_file ( filename)"

.PP
.nf
Classify the file named by 'filename' and return the classification.
If the file is classified as 'IT_Invalid' print an error message and exit
the program.

.fi
.PP
 
.SS "def gbench\&.util\&.classify_input_file ( filename)"

.PP
.nf
Return a tuple (type, msg) where 'type' specifies the classified type
of 'filename'. If 'type' is 'IT_Invalid' then 'msg' is a human readable
string represeting the error.

.fi
.PP
 
.SS "def gbench\&.util\&.find_benchmark_flag ( prefix,  benchmark_flags)"

.PP
.nf
Search the specified list of flags for a flag matching `<prefix><arg>` and
if it is found return the arg it specifies. If specified more than once the
last value is returned. If the flag is not found None is returned.

.fi
.PP
 
.SS "def gbench\&.util\&.is_executable_file ( filename)"

.PP
.nf
Return 'True' if 'filename' names a valid file which is likely
an executable. A file is considered an executable if it starts with the
magic bytes for a EXE, Mach O, or ELF file.

.fi
.PP
 
.SS "def gbench\&.util\&.is_json_file ( filename)"

.PP
.nf
Returns 'True' if 'filename' names a valid JSON output file.
'False' otherwise.

.fi
.PP
 
.SS "def gbench\&.util\&.load_benchmark_results ( fname)"

.PP
.nf
Read benchmark output from a file and return the JSON object.
REQUIRES: 'fname' names a file containing JSON benchmark output.

.fi
.PP
 
.SS "def gbench\&.util\&.remove_benchmark_flags ( prefix,  benchmark_flags)"

.PP
.nf
Return a new list containing the specified benchmark_flags except those
with the specified prefix.

.fi
.PP
 
.SS "def gbench\&.util\&.run_benchmark ( exe_name,  benchmark_flags)"

.PP
.nf
Run a benchmark specified by 'exe_name' with the specified
'benchmark_flags'. The benchmark is run directly as a subprocess to preserve
real time console output.
RETURNS: A JSON object representing the benchmark output

.fi
.PP
 
.SS "def gbench\&.util\&.run_or_load_benchmark ( filename,  benchmark_flags)"

.PP
.nf
Get the results for a specified benchmark. If 'filename' specifies
an executable benchmark then the results are generated by running the
benchmark. Otherwise 'filename' must name a valid JSON output file,
which is loaded and the result returned.

.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
