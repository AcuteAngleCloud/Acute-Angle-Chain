.TH "mathcapi" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mathcapi \- Defines basic mathematical operations for higher abstractions to use\&.  

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBmulteq_i128\fP (uint128_t *self, const uint128_t *\fBother\fP)"
.br
.RI "Multiply two 128 unsigned bit integers\&. \fBThrows\fP exception if pointers are invalid\&. "
.ti -1c
.RI "void \fBdiveq_i128\fP (uint128_t *self, const uint128_t *\fBother\fP)"
.br
.RI "Divide two 128 unsigned bit integers and throws an exception in case of invalid pointers\&. "
.ti -1c
.RI "uint64_t \fBdouble_add\fP (uint64_t a, uint64_t b)"
.br
.RI "Addition between two double\&. "
.ti -1c
.RI "uint64_t \fBdouble_mult\fP (uint64_t a, uint64_t b)"
.br
.RI "Multiplication between two double\&. "
.ti -1c
.RI "uint64_t \fBdouble_div\fP (uint64_t a, uint64_t b)"
.br
.RI "Division between two double\&. "
.ti -1c
.RI "uint32_t \fBdouble_lt\fP (uint64_t a, uint64_t b)"
.br
.RI "Less than comparison between two double\&. "
.ti -1c
.RI "uint32_t \fBdouble_eq\fP (uint64_t a, uint64_t b)"
.br
.RI "Equality check between two double\&. "
.ti -1c
.RI "uint32_t \fBdouble_gt\fP (uint64_t a, uint64_t b)"
.br
.RI "Greater than comparison between two double\&. "
.ti -1c
.RI "uint64_t \fBdouble_to_i64\fP (uint64_t a)"
.br
.RI "Convert double to 64 bit unsigned integer\&. "
.ti -1c
.RI "uint64_t \fBi64_to_double\fP (uint64_t a)"
.br
.RI "Convert 64 bit unsigned integer to double (interpreted as 64 bit unsigned integer) "
.in -1c
.SH "Detailed Description"
.PP 
Defines basic mathematical operations for higher abstractions to use\&. 


.SH "Function Documentation"
.PP 
.SS "void diveq_i128 (uint128_t * self, const uint128_t * other)"

.PP
Divide two 128 unsigned bit integers and throws an exception in case of invalid pointers\&. Divide two 128 bit unsigned integers and assign the value to the first parameter\&. It will throw an exception if the value of other is zero\&. 
.PP
\fBParameters:\fP
.RS 4
\fIself\fP \fBPointer\fP to numerator\&. It will be replaced with the result 
.br
\fIother\fP \fBPointer\fP to denominator Example: 
.PP
.nf
uint128_t self(100);
uint128_t other(100);
diveq_i128(&self, &other);
printi128(self); // Output: 1

.fi
.PP
 
.RE
.PP

.SS "uint64_t double_add (uint64_t a, uint64_t b)"

.PP
Addition between two double\&. Get the result of addition between two double interpreted as 64 bit unsigned integer This function will first reinterpret_cast both inputs to double (50 decimal digit precision), add them together, and reinterpret_cast the result back to 64 bit unsigned integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.br
\fIb\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBResult\fP of addition reinterpret_cast to 64 bit unsigned integers
.RE
.PP
Example: 
.PP
.nf
uint64_t a = double_div( i64_to_double(5), i64_to_double(10) );
uint64_t b = double_div( i64_to_double(5), i64_to_double(2) );
uint64_t res = double_add( a, b );
printd(res); // Output: 3

.fi
.PP
 
.SS "uint64_t double_div (uint64_t a, uint64_t b)"

.PP
Division between two double\&. Get the result of division between two double interpreted as 64 bit unsigned integer This function will first reinterpret_cast both inputs to double (50 decimal digit precision), divide numerator with denominator, and reinterpret_cast the result back to 64 bit unsigned integer\&. \fBThrows\fP an error if b is zero (after it is reinterpret_cast to double) 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP Numerator in double interpreted as 64 bit unsigned integer 
.br
\fIb\fP Denominator in double interpreted as 64 bit unsigned integer 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBResult\fP of division reinterpret_cast to 64 bit unsigned integers
.RE
.PP
Example: 
.PP
.nf
uint64_t a = double_div( i64_to_double(10), i64_to_double(100) );
printd(a); // Output: 0\&.1

.fi
.PP
 
.SS "uint32_t double_eq (uint64_t a, uint64_t b)"

.PP
Equality check between two double\&. Get the result of equality check between two double This function will first reinterpret_cast both inputs to double (50 decimal digit precision) before doing equality check\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.br
\fIb\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if first input is equal to second input, 0 otherwise
.RE
.PP
Example: 
.PP
.nf
uint64_t a = double_div( i64_to_double(10), i64_to_double(10) );
uint64_t b = double_div( i64_to_double(5), i64_to_double(2) );
uint64_t res = double_eq( a, b );
printi(res); // Output: 0

.fi
.PP
 
.SS "uint32_t double_gt (uint64_t a, uint64_t b)"

.PP
Greater than comparison between two double\&. Get the result of greater than comparison between two double This function will first reinterpret_cast both inputs to double (50 decimal digit precision) before doing the greater than comparison\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.br
\fIb\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if first input is greater than second input, 0 otherwise
.RE
.PP
Example: 
.PP
.nf
uint64_t a = double_div( i64_to_double(10), i64_to_double(10) );
uint64_t b = double_div( i64_to_double(5), i64_to_double(2) );
uint64_t res = double_gt( a, b );
printi(res); // Output: 0

.fi
.PP
 
.SS "uint32_t double_lt (uint64_t a, uint64_t b)"

.PP
Less than comparison between two double\&. Get the result of less than comparison between two double This function will first reinterpret_cast both inputs to double (50 decimal digit precision) before doing the less than comparison\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.br
\fIb\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if first input is smaller than second input, 0 otherwise
.RE
.PP
Example: 
.PP
.nf
uint64_t a = double_div( i64_to_double(10), i64_to_double(10) );
uint64_t b = double_div( i64_to_double(5), i64_to_double(2) );
uint64_t res = double_lt( a, b );
printi(res); // Output: 1

.fi
.PP
 
.SS "uint64_t double_mult (uint64_t a, uint64_t b)"

.PP
Multiplication between two double\&. Get the result of multiplication between two double interpreted as 64 bit unsigned integer This function will first reinterpret_cast both inputs to double (50 decimal digit precision), multiply them together, and reinterpret_cast the result back to 64 bit unsigned integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.br
\fIb\fP \fBValue\fP in double interpreted as 64 bit unsigned integer 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBResult\fP of multiplication reinterpret_cast to 64 bit unsigned integers
.RE
.PP
Example: 
.PP
.nf
uint64_t a = double_div( i64_to_double(10), i64_to_double(10) );
uint64_t b = double_div( i64_to_double(5), i64_to_double(2) );
uint64_t res = double_mult( a, b );
printd(res); // Output: 2\&.5

.fi
.PP
 
.SS "uint64_t double_to_i64 (uint64_t a)"

.PP
Convert double to 64 bit unsigned integer\&. Convert double (interpreted as 64 bit unsigned integer) to 64 bit unsigned integer\&. This function will first reinterpret_cast the input to double (50 decimal digit precision) then convert it to double, then reinterpret_cast it to 64 bit unsigned integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP - value in double interpreted as 64 bit unsigned integer 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBResult\fP of conversion in 64 bit unsigned integer
.RE
.PP
Example: 
.PP
.nf
uint64_t a = double_div( i64_to_double(5), i64_to_double(2) );
uint64_t res = double_to_i64( a );
printi(res); // Output: 2

.fi
.PP
 
.SS "uint64_t i64_to_double (uint64_t a)"

.PP
Convert 64 bit unsigned integer to double (interpreted as 64 bit unsigned integer) Convert 64 bit unsigned integer to double (interpreted as 64 bit unsigned integer)\&. This function will convert the input to double (50 decimal digit precision) then reinterpret_cast it to 64 bit unsigned integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP - value to be converted 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBResult\fP of conversion in double (interpreted as 64 bit unsigned integer)
.RE
.PP
Example: 
.PP
.nf
uint64_t res = i64_to_double( 3 );
printd(res); // Output: 3

.fi
.PP
 
.SS "void multeq_i128 (uint128_t * self, const uint128_t * other)"

.PP
Multiply two 128 unsigned bit integers\&. \fBThrows\fP exception if pointers are invalid\&. Multiply two 128 bit unsigned integers and assign the value to the first parameter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIself\fP \fBPointer\fP to the value to be multiplied\&. It will be replaced with the result\&. 
.br
\fIother\fP \fBPointer\fP to the \fBValue\fP to be multiplied\&.
.RE
.PP
Example: 
.PP
.nf
uint128_t self(100);
uint128_t other(100);
multeq_i128(&self, &other);
printi128(self); // Output: 10000

.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
