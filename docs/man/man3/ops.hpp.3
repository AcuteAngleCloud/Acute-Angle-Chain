.TH "externals/magic_get/include/boost/pfr/precise/ops.hpp" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
externals/magic_get/include/boost/pfr/precise/ops.hpp
.SH SYNOPSIS
.br
.PP
\fC#include <boost/pfr/detail/config\&.hpp>\fP
.br
\fC#include <boost/pfr/detail/detectors\&.hpp>\fP
.br
\fC#include <boost/pfr/precise/functors\&.hpp>\fP
.br
\fC#include <boost/pfr/precise/core\&.hpp>\fP
.br
\fC#include <boost/pfr/precise/io\&.hpp>\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "template<template< class, class > class Detector, class T > using \fBboost::pfr::detail::enable_not_comp_base_t\fP = typename std::enable_if< not_appliable< Detector, \fBT\fP const  &, \fBT\fP const  & >::value, bool >::type"
.br
.ti -1c
.RI "template<class T > using \fBboost::pfr::detail::enable_not_eq_comp_t\fP = enable_not_comp_base_t< comp_eq_detector, \fBT\fP >"
.br
.ti -1c
.RI "template<class T > using \fBboost::pfr::detail::enable_not_ne_comp_t\fP = enable_not_comp_base_t< comp_ne_detector, \fBT\fP >"
.br
.ti -1c
.RI "template<class T > using \fBboost::pfr::detail::enable_not_lt_comp_t\fP = enable_not_comp_base_t< comp_lt_detector, \fBT\fP >"
.br
.ti -1c
.RI "template<class T > using \fBboost::pfr::detail::enable_not_le_comp_t\fP = enable_not_comp_base_t< comp_le_detector, \fBT\fP >"
.br
.ti -1c
.RI "template<class T > using \fBboost::pfr::detail::enable_not_gt_comp_t\fP = enable_not_comp_base_t< comp_gt_detector, \fBT\fP >"
.br
.ti -1c
.RI "template<class T > using \fBboost::pfr::detail::enable_not_ge_comp_t\fP = enable_not_comp_base_t< comp_ge_detector, \fBT\fP >"
.br
.ti -1c
.RI "template<class Stream , class Type > using \fBboost::pfr::detail::enable_not_ostreamable_t\fP = typename std::enable_if< not_appliable< ostreamable_detector, Stream &, \fBType\fP const  & >::value, Stream &>::type"
.br
.ti -1c
.RI "template<class Stream , class Type > using \fBboost::pfr::detail::enable_not_istreamable_t\fP = typename std::enable_if< not_appliable< istreamable_detector, Stream &, \fBType\fP & >::value, Stream &>::type"
.br
.in -1c
.SH "Detailed Description"
.PP 
Contains comparison operators and stream operators for types that do not have their own operators\&. If type is comparable or streamable using it's own operator or it's conversion operator, then the original operator is used\&.
.PP
Just write \fBusing\fP \fBnamespace\fP \fBops\fP; and operators will be available in scope\&.
.PP
\fBRequires:\fP C++17 or {C++14 constexpr aggregate intializable type}\&.
.PP
\fBExample:\fP 
.PP
.nf
#include <boost/pfr/precise/ops\&.hpp>
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// \&.\&.\&.

using namespace ops;

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
comparable_struct s2 {0, 1, "Hello", false, 6,7,8,9,10,11111};
assert(s1 < s2);
std::cout << s1 << std::endl; // Outputs: {0, 1, H, e, l, l, o, , , 0, 6, 7, 8, 9, 10, 11}

.fi
.PP
.PP
for other ways to define operators and more details\&.
.PP
\fBThis\fP \fBheader\fP \fBcontains:\fP 
.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
