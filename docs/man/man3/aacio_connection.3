.TH "aacio::connection" 3 "Sun Jun 3 2018" "AcuteAngleChain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
aacio::connection
.SH SYNOPSIS
.br
.PP
.PP
Inherits enable_shared_from_this< connection >\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBqueued_write\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBconnection\fP (string endpoint)"
.br
.ti -1c
.RI "\fBconnection\fP (socket_ptr s)"
.br
.ti -1c
.RI "void \fBinitialize\fP ()"
.br
.ti -1c
.RI "\fBconnection_status\fP \fBget_status\fP () const"
.br
.ti -1c
.RI "bool \fBconnected\fP ()"
.br
.ti -1c
.RI "bool \fBcurrent\fP ()"
.br
.ti -1c
.RI "void \fBreset\fP ()"
.br
.ti -1c
.RI "void \fBclose\fP ()"
.br
.ti -1c
.RI "void \fBsend_handshake\fP ()"
.br
.ti -1c
.RI "const string \fBpeer_name\fP ()"
.br
.ti -1c
.RI "void \fBtxn_send_pending\fP (const \fBvector\fP< \fBtransaction_id_type\fP > &ids)"
.br
.ti -1c
.RI "void \fBtxn_send\fP (const \fBvector\fP< \fBtransaction_id_type\fP > &txn_lis)"
.br
.ti -1c
.RI "void \fBblk_send_branch\fP ()"
.br
.ti -1c
.RI "void \fBblk_send\fP (const \fBvector\fP< \fBblock_id_type\fP > &txn_lis)"
.br
.ti -1c
.RI "void \fBstop_send\fP ()"
.br
.ti -1c
.RI "void \fBenqueue\fP (\fBtransaction_id_type\fP id)"
.br
.ti -1c
.RI "void \fBenqueue\fP (const \fBnet_message\fP &msg, bool trigger_send=true)"
.br
.ti -1c
.RI "void \fBcancel_sync\fP (\fBgo_away_reason\fP)"
.br
.ti -1c
.RI "void \fBcancel_fetch\fP ()"
.br
.ti -1c
.RI "void \fBflush_queues\fP ()"
.br
.ti -1c
.RI "bool \fBenqueue_sync_block\fP ()"
.br
.ti -1c
.RI "void \fBrequest_sync_blocks\fP (uint32_t start, uint32_t end)"
.br
.ti -1c
.RI "void \fBcancel_wait\fP ()"
.br
.ti -1c
.RI "void \fBsync_wait\fP ()"
.br
.ti -1c
.RI "void \fBfetch_wait\fP ()"
.br
.ti -1c
.RI "void \fBsync_timeout\fP (boost::system::error_code ec)"
.br
.ti -1c
.RI "void \fBfetch_timeout\fP (boost::system::error_code ec)"
.br
.ti -1c
.RI "void \fBqueue_write\fP (std::shared_ptr< \fBvector\fP< char >> buff, bool trigger_send, std::function< void(boost::system::error_code, std::size_t)> cb)"
.br
.ti -1c
.RI "void \fBdo_queue_write\fP ()"
.br
.ti -1c
.RI "bool \fBprocess_next_message\fP (\fBnet_plugin_impl\fP &impl, uint32_t message_length)"
.br
.RI "Process the next message from the pending message buffer\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "block_state_index \fBblk_state\fP"
.br
.ti -1c
.RI "transaction_state_index \fBtrx_state\fP"
.br
.ti -1c
.RI "\fBoptional\fP< \fBsync_state\fP > \fBpeer_requested\fP"
.br
.ti -1c
.RI "socket_ptr \fBsocket\fP"
.br
.ti -1c
.RI "\fBmessage_buffer\fP< 1024 *1024 > \fBpending_message_buffer\fP"
.br
.ti -1c
.RI "\fBvector\fP< char > \fBblk_buffer\fP"
.br
.ti -1c
.RI "\fBdeque\fP< \fBqueued_write\fP > \fBwrite_queue\fP"
.br
.ti -1c
.RI "\fBfc::sha256\fP \fBnode_id\fP"
.br
.ti -1c
.RI "\fBhandshake_message\fP \fBlast_handshake_recv\fP"
.br
.ti -1c
.RI "\fBhandshake_message\fP \fBlast_handshake_sent\fP"
.br
.ti -1c
.RI "int16_t \fBsent_handshake_count\fP"
.br
.ti -1c
.RI "bool \fBconnecting\fP"
.br
.ti -1c
.RI "bool \fBsyncing\fP"
.br
.ti -1c
.RI "int \fBwrite_depth\fP"
.br
.ti -1c
.RI "string \fBpeer_addr\fP"
.br
.ti -1c
.RI "\fBunique_ptr\fP< boost::asio::steady_timer > \fBresponse_expected\fP"
.br
.ti -1c
.RI "\fBoptional\fP< \fBrequest_message\fP > \fBpending_fetch\fP"
.br
.ti -1c
.RI "\fBgo_away_reason\fP \fBno_retry\fP"
.br
.ti -1c
.RI "\fBblock_id_type\fP \fBfork_head\fP"
.br
.ti -1c
.RI "uint32_t \fBfork_head_num\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const fc::string \fBlogger_name\fP"
.br
.ti -1c
.RI "static \fBfc::logger\fP \fBlogger\fP"
.br
.in -1c
.SS "Peer Timestamps"
Time message handling 
.in +1c
.ti -1c
.RI "tstamp \fBorg\fP {0}"
.br
.RI "originate timestamp "
.ti -1c
.RI "tstamp \fBrec\fP {0}"
.br
.RI "receive timestamp "
.ti -1c
.RI "tstamp \fBdst\fP {0}"
.br
.RI "destination timestamp "
.ti -1c
.RI "tstamp \fBxmt\fP {0}"
.br
.RI "transmit timestamp "
.ti -1c
.RI "double \fBoffset\fP {0}"
.br
.RI "peer offset "
.ti -1c
.RI "char \fBts\fP [ts_buffer_size]"
.br
.RI "working buffer for making human readable timestamps "
.ti -1c
.RI "static const size_t \fBts_buffer_size\fP {32}"
.br
.ti -1c
.RI "char * \fBconvert_tstamp\fP (const tstamp &t)"
.br
.RI "Convert an std::chrono nanosecond rep to a human readable string\&. "
.ti -1c
.RI "void \fBsend_time\fP ()"
.br
.RI "Populate and queue \fBtime_message\fP\&. "
.ti -1c
.RI "void \fBsend_time\fP (const \fBtime_message\fP &msg)"
.br
.RI "Populate and queue \fBtime_message\fP immediately using incoming \fBtime_message\fP\&. "
.ti -1c
.RI "tstamp \fBget_time\fP ()"
.br
.RI "Read system time and convert to a 64 bit integer\&. "
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "tstamp aacio::connection::get_time ()\fC [inline]\fP"

.PP
Read system time and convert to a 64 bit integer\&. There are only two calls on this routine in the program\&. \fBOne\fP when a packet arrives from the network and the other when a packet is placed on the send queue\&. Calls the kernel time of day routine and converts to a (at least) 64 bit integer\&. 
.SS "bool aacio::connection::process_next_message (\fBnet_plugin_impl\fP & impl, uint32_t message_length)"

.PP
Process the next message from the pending message buffer\&. Process the next message from the pending_message_buffer\&. message_length is the already determined length of the data part of the message and impl in the net plugin implementation that will handle the message\&. Returns true is successful\&. Returns false if an error was encountered unpacking or processing the message\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for AcuteAngleChain from the source code\&.
