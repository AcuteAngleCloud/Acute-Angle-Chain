.TH "websocketpp::connection< config >" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
websocketpp::connection< config > \- Represents an individual WebSocket connection\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <connection\&.hpp>\fP
.PP
Inherits transport_con_type, and connection_base\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBconnection\fP< \fBconfig\fP > \fBtype\fP"
.br
.RI "\fBType\fP of this connection\&. "
.ti -1c
.RI "typedef lib::shared_ptr< \fBtype\fP > \fBptr\fP"
.br
.RI "\fBType\fP of a shared pointer to this connection\&. "
.ti -1c
.RI "typedef lib::weak_ptr< \fBtype\fP > \fBweak_ptr\fP"
.br
.RI "\fBType\fP of a weak pointer to this connection\&. "
.ti -1c
.RI "typedef \fBconfig::concurrency_type\fP \fBconcurrency_type\fP"
.br
.RI "\fBType\fP of the concurrency component of this connection\&. "
.ti -1c
.RI "typedef \fBconfig::alog_type\fP \fBalog_type\fP"
.br
.RI "\fBType\fP of the access logging policy\&. "
.ti -1c
.RI "typedef \fBconfig::elog_type\fP \fBelog_type\fP"
.br
.RI "\fBType\fP of the error logging policy\&. "
.ti -1c
.RI "typedef \fBconfig::transport_type::transport_con_type\fP \fBtransport_con_type\fP"
.br
.RI "\fBType\fP of the transport component of this connection\&. "
.ti -1c
.RI "typedef transport_con_type::ptr \fBtransport_con_ptr\fP"
.br
.RI "\fBType\fP of a shared pointer to the transport component of this connection\&. "
.ti -1c
.RI "typedef lib::function< void(\fBptr\fP)> \fBtermination_handler\fP"
.br
.ti -1c
.RI "typedef \fBconcurrency_type::scoped_lock_type\fP \fBscoped_lock_type\fP"
.br
.ti -1c
.RI "typedef \fBconcurrency_type::mutex_type\fP \fBmutex_type\fP"
.br
.ti -1c
.RI "typedef \fBconfig::request_type\fP \fBrequest_type\fP"
.br
.ti -1c
.RI "typedef \fBconfig::response_type\fP \fBresponse_type\fP"
.br
.ti -1c
.RI "typedef \fBconfig::message_type\fP \fBmessage_type\fP"
.br
.ti -1c
.RI "typedef message_type::ptr \fBmessage_ptr\fP"
.br
.ti -1c
.RI "typedef \fBconfig::con_msg_manager_type\fP \fBcon_msg_manager_type\fP"
.br
.ti -1c
.RI "typedef con_msg_manager_type::ptr \fBcon_msg_manager_ptr\fP"
.br
.ti -1c
.RI "typedef \fBconfig::rng_type\fP \fBrng_type\fP"
.br
.RI "\fBType\fP of RNG\&. "
.ti -1c
.RI "typedef \fBprocessor::processor\fP< \fBconfig\fP > \fBprocessor_type\fP"
.br
.ti -1c
.RI "typedef lib::shared_ptr< \fBprocessor_type\fP > \fBprocessor_ptr\fP"
.br
.ti -1c
.RI "typedef lib::function< void(\fBconnection_hdl\fP, message_ptr)> \fBmessage_handler\fP"
.br
.ti -1c
.RI "typedef transport_con_type::timer_ptr \fBtimer_ptr\fP"
.br
.RI "\fBType\fP of a pointer to a transport timer handle\&. "
.ti -1c
.RI "typedef session::internal_state::value \fBistate_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBconnection\fP (bool p_is_server, std::string const &ua, \fBalog_type\fP &alog, \fBelog_type\fP &elog, \fBrng_type\fP &rng)"
.br
.ti -1c
.RI "\fBptr\fP \fBget_shared\fP ()"
.br
.RI "Get a shared pointer to this component\&. "
.ti -1c
.RI "void \fBset_open_handler\fP (\fBopen_handler\fP h)"
.br
.RI "Set open handler\&. "
.ti -1c
.RI "void \fBset_close_handler\fP (\fBclose_handler\fP h)"
.br
.RI "Set close handler\&. "
.ti -1c
.RI "void \fBset_fail_handler\fP (\fBfail_handler\fP h)"
.br
.RI "Set fail handler\&. "
.ti -1c
.RI "void \fBset_ping_handler\fP (\fBping_handler\fP h)"
.br
.RI "Set ping handler\&. "
.ti -1c
.RI "void \fBset_pong_handler\fP (\fBpong_handler\fP h)"
.br
.RI "Set pong handler\&. "
.ti -1c
.RI "void \fBset_pong_timeout_handler\fP (\fBpong_timeout_handler\fP h)"
.br
.RI "Set pong timeout handler\&. "
.ti -1c
.RI "void \fBset_interrupt_handler\fP (\fBinterrupt_handler\fP h)"
.br
.RI "Set interrupt handler\&. "
.ti -1c
.RI "void \fBset_http_handler\fP (\fBhttp_handler\fP h)"
.br
.RI "Set http handler\&. "
.ti -1c
.RI "void \fBset_validate_handler\fP (\fBvalidate_handler\fP h)"
.br
.RI "Set validate handler\&. "
.ti -1c
.RI "void \fBset_message_handler\fP (message_handler h)"
.br
.RI "Set message handler\&. "
.ti -1c
.RI "void \fBset_open_handshake_timeout\fP (long dur)"
.br
.RI "Set open handshake timeout\&. "
.ti -1c
.RI "void \fBset_close_handshake_timeout\fP (long dur)"
.br
.RI "Set close handshake timeout\&. "
.ti -1c
.RI "void \fBset_pong_timeout\fP (long dur)"
.br
.RI "Set pong timeout\&. "
.ti -1c
.RI "size_t \fBget_max_message_size\fP () const"
.br
.RI "Get maximum message size\&. "
.ti -1c
.RI "void \fBset_max_message_size\fP (size_t new_value)"
.br
.RI "Set maximum message size\&. "
.ti -1c
.RI "size_t \fBget_max_http_body_size\fP () const"
.br
.RI "Get maximum HTTP message body size\&. "
.ti -1c
.RI "void \fBset_max_http_body_size\fP (size_t new_value)"
.br
.RI "Set maximum HTTP message body size\&. "
.ti -1c
.RI "size_t \fBget_buffered_amount\fP () const"
.br
.RI "Get the size of the outgoing write buffer (in payload bytes) "
.ti -1c
.RI "size_t \fBbuffered_amount\fP () const"
.br
.RI "Get the size of the outgoing write buffer (in payload bytes) "
.ti -1c
.RI "lib::error_code \fBsend\fP (std::string const &payload, frame::opcode::value op=frame::opcode::text)"
.br
.RI "Create a message and then add it to the outgoing send queue\&. "
.ti -1c
.RI "lib::error_code \fBsend\fP (void const *payload, size_t len, frame::opcode::value op=frame::opcode::binary)"
.br
.RI "Send a message (raw array overload) "
.ti -1c
.RI "lib::error_code \fBsend\fP (message_ptr msg)"
.br
.RI "Add a message to the outgoing send queue\&. "
.ti -1c
.RI "lib::error_code \fBinterrupt\fP ()"
.br
.RI "Asyncronously invoke handler::on_inturrupt\&. "
.ti -1c
.RI "void \fBhandle_interrupt\fP ()"
.br
.RI "Transport inturrupt callback\&. "
.ti -1c
.RI "lib::error_code \fBpause_reading\fP ()"
.br
.RI "Pause reading of new data\&. "
.ti -1c
.RI "void \fBhandle_pause_reading\fP ()"
.br
.RI "Pause reading callback\&. "
.ti -1c
.RI "lib::error_code \fBresume_reading\fP ()"
.br
.RI "Resume reading of new data\&. "
.ti -1c
.RI "void \fBhandle_resume_reading\fP ()"
.br
.RI "Resume reading callback\&. "
.ti -1c
.RI "void \fBping\fP (std::string const &payload)"
.br
.RI "Send a ping\&. "
.ti -1c
.RI "void \fBping\fP (std::string const &payload, lib::error_code &ec)"
.br
.RI "exception free variant of ping "
.ti -1c
.RI "void \fBhandle_pong_timeout\fP (std::string payload, lib::error_code const &ec)"
.br
.RI "Utility method that gets called back when the ping timer expires\&. "
.ti -1c
.RI "void \fBpong\fP (std::string const &payload)"
.br
.RI "Send a pong\&. "
.ti -1c
.RI "void \fBpong\fP (std::string const &payload, lib::error_code &ec)"
.br
.RI "exception free variant of pong "
.ti -1c
.RI "void \fBclose\fP (\fBclose::status::value\fP const code, std::string const &reason)"
.br
.RI "Close the connection\&. "
.ti -1c
.RI "void \fBclose\fP (\fBclose::status::value\fP const code, std::string const &reason, lib::error_code &ec)"
.br
.RI "exception free variant of close "
.ti -1c
.RI "bool \fBget_secure\fP () const"
.br
.RI "Returns the secure flag from the connection URI\&. "
.ti -1c
.RI "std::string const  & \fBget_host\fP () const"
.br
.RI "Returns the host component of the connection URI\&. "
.ti -1c
.RI "std::string const  & \fBget_resource\fP () const"
.br
.RI "Returns the resource component of the connection URI\&. "
.ti -1c
.RI "uint16_t \fBget_port\fP () const"
.br
.RI "Returns the port component of the connection URI\&. "
.ti -1c
.RI "\fBuri_ptr\fP \fBget_uri\fP () const"
.br
.RI "Gets the connection URI\&. "
.ti -1c
.RI "void \fBset_uri\fP (\fBuri_ptr\fP \fBuri\fP)"
.br
.RI "Sets the connection URI\&. "
.ti -1c
.RI "std::string const  & \fBget_subprotocol\fP () const"
.br
.RI "Gets the negotated subprotocol\&. "
.ti -1c
.RI "\fBstd::vector\fP< std::string > const  & \fBget_requested_subprotocols\fP () const"
.br
.RI "Gets all of the subprotocols requested by the client\&. "
.ti -1c
.RI "void \fBadd_subprotocol\fP (std::string const &request, lib::error_code &ec)"
.br
.RI "Adds the given subprotocol string to the request list (exception free) "
.ti -1c
.RI "void \fBadd_subprotocol\fP (std::string const &request)"
.br
.RI "Adds the given subprotocol string to the request list\&. "
.ti -1c
.RI "void \fBselect_subprotocol\fP (std::string const &value, lib::error_code &ec)"
.br
.RI "Select a subprotocol to use (exception free) "
.ti -1c
.RI "void \fBselect_subprotocol\fP (std::string const &value)"
.br
.RI "Select a subprotocol to use\&. "
.ti -1c
.RI "std::string const  & \fBget_request_header\fP (std::string const &key) const"
.br
.RI "Retrieve a request header\&. "
.ti -1c
.RI "std::string const  & \fBget_request_body\fP () const"
.br
.RI "Retrieve a request body\&. "
.ti -1c
.RI "std::string const  & \fBget_response_header\fP (std::string const &key) const"
.br
.RI "Retrieve a response header\&. "
.ti -1c
.RI "http::status_code::value \fBget_response_code\fP () const"
.br
.RI "Get response HTTP status code\&. "
.ti -1c
.RI "std::string const  & \fBget_response_msg\fP () const"
.br
.RI "Get response HTTP status message\&. "
.ti -1c
.RI "void \fBset_status\fP (http::status_code::value code)"
.br
.RI "Set response status code and message\&. "
.ti -1c
.RI "void \fBset_status\fP (http::status_code::value code, std::string const &msg)"
.br
.RI "Set response status code and message\&. "
.ti -1c
.RI "void \fBset_body\fP (std::string const &value)"
.br
.RI "Set response body content\&. "
.ti -1c
.RI "void \fBappend_header\fP (std::string const &key, std::string const &val)"
.br
.RI "Append a header\&. "
.ti -1c
.RI "void \fBreplace_header\fP (std::string const &key, std::string const &val)"
.br
.RI "Replace a header\&. "
.ti -1c
.RI "void \fBremove_header\fP (std::string const &key)"
.br
.RI "Remove a header\&. "
.ti -1c
.RI "\fBrequest_type\fP const  & \fBget_request\fP () const"
.br
.RI "Get request object\&. "
.ti -1c
.RI "\fBresponse_type\fP const  & \fBget_response\fP () const"
.br
.RI "Get response object\&. "
.ti -1c
.RI "lib::error_code \fBdefer_http_response\fP ()"
.br
.RI "Defer HTTP Response until later (Exception free) "
.ti -1c
.RI "void \fBsend_http_response\fP (lib::error_code &ec)"
.br
.RI "Send deferred HTTP Response (exception free) "
.ti -1c
.RI "void \fBsend_http_response\fP ()"
.br
.RI "Send deferred HTTP Response\&. "
.ti -1c
.RI "\fBconnection_hdl\fP \fBget_handle\fP () const"
.br
.RI "Get Connection Handle\&. "
.ti -1c
.RI "bool \fBis_server\fP () const"
.br
.RI "Get whether or not this connection is part of a server or client\&. "
.ti -1c
.RI "std::string const  & \fBget_origin\fP () const"
.br
.RI "Return the same origin policy origin value from the opening request\&. "
.ti -1c
.RI "session::state::value \fBget_state\fP () const"
.br
.RI "Return the connection state\&. "
.ti -1c
.RI "\fBclose::status::value\fP \fBget_local_close_code\fP () const"
.br
.RI "Get the WebSocket close code sent by this endpoint\&. "
.ti -1c
.RI "std::string const  & \fBget_local_close_reason\fP () const"
.br
.RI "Get the WebSocket close reason sent by this endpoint\&. "
.ti -1c
.RI "\fBclose::status::value\fP \fBget_remote_close_code\fP () const"
.br
.RI "Get the WebSocket close code sent by the remote endpoint\&. "
.ti -1c
.RI "std::string const  & \fBget_remote_close_reason\fP () const"
.br
.RI "Get the WebSocket close reason sent by the remote endpoint\&. "
.ti -1c
.RI "lib::error_code \fBget_ec\fP () const"
.br
.RI "Get the internal error code for a closed/failed connection\&. "
.ti -1c
.RI "message_ptr \fBget_message\fP (websocketpp::frame::opcode::value op, size_t size) const"
.br
.RI "Get a message buffer\&. "
.ti -1c
.RI "void \fBread_handshake\fP (size_t num_bytes)"
.br
.ti -1c
.RI "void \fBhandle_read_handshake\fP (lib::error_code const &ec, size_t bytes_transferred)"
.br
.ti -1c
.RI "void \fBhandle_read_http_response\fP (lib::error_code const &ec, size_t bytes_transferred)"
.br
.ti -1c
.RI "void \fBhandle_write_http_response\fP (lib::error_code const &ec)"
.br
.ti -1c
.RI "void \fBhandle_send_http_request\fP (lib::error_code const &ec)"
.br
.ti -1c
.RI "void \fBhandle_open_handshake_timeout\fP (lib::error_code const &ec)"
.br
.ti -1c
.RI "void \fBhandle_close_handshake_timeout\fP (lib::error_code const &ec)"
.br
.ti -1c
.RI "void \fBhandle_read_frame\fP (lib::error_code const &ec, size_t bytes_transferred)"
.br
.ti -1c
.RI "void \fBread_frame\fP ()"
.br
.RI "Issue a new transport read unless reading is paused\&. "
.ti -1c
.RI "\fBstd::vector\fP< int > const  & \fBget_supported_versions\fP () const"
.br
.RI "Get array of WebSocket protocol versions that this connection supports\&. "
.ti -1c
.RI "void \fBset_termination_handler\fP (termination_handler new_handler)"
.br
.ti -1c
.RI "void \fBterminate\fP (lib::error_code const &ec)"
.br
.ti -1c
.RI "void \fBhandle_terminate\fP (terminate_status tstat, lib::error_code const &ec)"
.br
.ti -1c
.RI "void \fBwrite_frame\fP ()"
.br
.RI "Checks if there are frames in the send queue and if there are sends one\&. "
.ti -1c
.RI "void \fBhandle_write_frame\fP (lib::error_code const &ec)"
.br
.RI "Process the results of a frame write operation and start the next write\&. "
.ti -1c
.RI "void \fBstart\fP ()"
.br
.RI "Start the connection state machine\&. "
.ti -1c
.RI "void \fBset_handle\fP (\fBconnection_hdl\fP hdl)"
.br
.RI "Set Connection Handle\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBhandle_transport_init\fP (lib::error_code const &ec)"
.br
.ti -1c
.RI "lib::error_code \fBinitialize_processor\fP ()"
.br
.ti -1c
.RI "lib::error_code \fBprocess_handshake_request\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename config>
.br
class websocketpp::connection< config >"
Represents an individual WebSocket connection\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::add_subprotocol (std::string const & request, lib::error_code & ec)"

.PP
Adds the given subprotocol string to the request list (exception free) Adds a subprotocol to the list to send with the opening handshake\&. This may be called multiple times to request more than one\&. If the server supports one of these, it may choose one\&. If so, it will return it in it's handshake reponse and the value will be available via \fBget_subprotocol()\fP\&. Subprotocol requests should be added in order of preference\&.
.PP
\fBParameters:\fP
.RS 4
\fIrequest\fP The subprotocol to request 
.br
\fIec\fP \fBA\fP reference to an error code that will be filled in the case of errors 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::add_subprotocol (std::string const & request)"

.PP
Adds the given subprotocol string to the request list\&. Adds a subprotocol to the list to send with the opening handshake\&. This may be called multiple times to request more than one\&. If the server supports one of these, it may choose one\&. If so, it will return it in it's handshake reponse and the value will be available via \fBget_subprotocol()\fP\&. Subprotocol requests should be added in order of preference\&.
.PP
\fBParameters:\fP
.RS 4
\fIrequest\fP The subprotocol to request 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::append_header (std::string const & key, std::string const & val)"

.PP
Append a header\&. If a header with this name already exists the value will be appended to the existing header to form a comma separated list of values\&. Use \fC\fBconnection::replace_header\fP\fP to overwrite existing values\&.
.PP
This member function is valid only from the http() and \fBvalidate()\fP handler callbacks, or to a client connection before connect has been called\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP Name of the header to set 
.br
\fIval\fP \fBValue\fP to add 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBreplace_header\fP 
.PP
websocketpp::http::parser::append_header 
.RE
.PP

.SS "template<typename config> size_t \fBwebsocketpp::connection\fP< \fBconfig\fP >::buffered_amount () const\fC [inline]\fP"

.PP
Get the size of the outgoing write buffer (in payload bytes) 
.PP
\fBDeprecated\fP
.RS 4
use \fCget_buffered_amount\fP instead 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::close (\fBclose::status::value\fP const code, std::string const & reason)"

.PP
Close the connection\&. Initiates the close handshake process\&.
.PP
If close returns successfully the connection will be in the closing state and no additional messages may be sent\&. All messages sent prior to calling close will be written out before the connection is closed\&.
.PP
If no reason is specified none will be sent\&. If no code is specified then no code will be sent\&.
.PP
The handler's on_close callback will be called once the close handshake is complete\&.
.PP
Reasons will be automatically truncated to the maximum length (123 bytes) if necessary\&.
.PP
\fBParameters:\fP
.RS 4
\fIcode\fP The close code to send 
.br
\fIreason\fP The close reason to send 
.RE
.PP

.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::defer_http_response ()"

.PP
Defer HTTP Response until later (Exception free) Defer HTTP Response until later\&.
.PP
Used in the http handler to defer the HTTP response for this connection until later\&. Handshake timers will be canceled and the connection will be left open until \fCsend_http_response\fP or an equivalent is called\&.
.PP
Warning: deferred connections won't time out and as a result can tie up resources\&.
.PP
\fBSince:\fP
.RS 4
0\&.6\&.0
.RE
.PP
\fBReturns:\fP
.RS 4
\fBA\fP status code, zero on success, non-zero otherwise
.RE
.PP
Used in the http handler to defer the HTTP response for this connection until later\&. Handshake timers will be canceled and the connection will be left open until \fCsend_http_response\fP or an equivalent is called\&.
.PP
Warning: deferred connections won't time out and as a result can tie up resources\&.
.PP
\fBReturns:\fP
.RS 4
\fBA\fP status code, zero on success, non-zero otherwise 
.RE
.PP

.SS "template<typename config > size_t \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_buffered_amount () const"

.PP
Get the size of the outgoing write buffer (in payload bytes) Retrieves the number of bytes in the outgoing write buffer that have not already been dispatched to the transport layer\&. This represents the bytes that are presently cancelable without uncleanly ending the websocket connection
.PP
This method invokes the m_write_lock mutex
.PP
\fBReturns:\fP
.RS 4
The current number of bytes in the outgoing send buffer\&. 
.RE
.PP

.SS "template<typename config> lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_ec () const\fC [inline]\fP"

.PP
Get the internal error code for a closed/failed connection\&. Retrieves a machine readable detailed error code indicating the reason that the connection was closed or failed\&. Valid only after the close or fail handler is called\&.
.PP
\fBReturns:\fP
.RS 4
Error code indicating the reason the connection was closed or failed 
.RE
.PP

.SS "template<typename config> \fBconnection_hdl\fP \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_handle () const\fC [inline]\fP"

.PP
Get Connection Handle\&. The connection handle is a token that can be shared outside the WebSocket++ core for the purposes of identifying a connection and sending it messages\&.
.PP
\fBReturns:\fP
.RS 4
\fBA\fP handle to the connection 
.RE
.PP

.SS "template<typename config > std::string const  & \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_host () const"

.PP
Returns the host component of the connection URI\&. This value is available after the HTTP request has been fully read and may be called from any thread\&.
.PP
\fBReturns:\fP
.RS 4
The host component of the connection URI 
.RE
.PP

.SS "template<typename config> \fBclose::status::value\fP \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_local_close_code () const\fC [inline]\fP"

.PP
Get the WebSocket close code sent by this endpoint\&. 
.PP
\fBReturns:\fP
.RS 4
The WebSocket close code sent by this endpoint\&. 
.RE
.PP

.SS "template<typename config> std::string const& \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_local_close_reason () const\fC [inline]\fP"

.PP
Get the WebSocket close reason sent by this endpoint\&. 
.PP
\fBReturns:\fP
.RS 4
The WebSocket close reason sent by this endpoint\&. 
.RE
.PP

.SS "template<typename config> size_t \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_max_http_body_size () const\fC [inline]\fP"

.PP
Get maximum HTTP message body size\&. Get maximum HTTP message body size\&. Maximum message body size determines the point at which the connection will stop reading an HTTP request whose body is too large\&.
.PP
The default is set by the endpoint that creates the connection\&.
.PP
\fBSince:\fP
.RS 4
0\&.5\&.0
.RE
.PP
\fBReturns:\fP
.RS 4
The maximum HTTP message body size 
.RE
.PP

.SS "template<typename config> size_t \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_max_message_size () const\fC [inline]\fP"

.PP
Get maximum message size\&. Get maximum message size\&. Maximum message size determines the point at which the connection will fail with the message_too_big protocol error\&.
.PP
The default is set by the endpoint that creates the connection\&.
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0 
.RE
.PP

.SS "template<typename config> message_ptr \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_message (websocketpp::frame::opcode::value op, size_t size) const\fC [inline]\fP"

.PP
Get a message buffer\&. Warning: The API related to directly sending message buffers may change before the 1\&.0 release\&. If you plan to use it, please keep an eye on any breaking changes notifications in future release notes\&. Also if you have any feedback about usage and capabilities now is a great time to provide it\&.
.PP
Message buffers are used to store message payloads and other message metadata\&.
.PP
The size parameter is a hint only\&. Your final payload does not need to match it\&. There may be some performance benefits if the initial size guess is equal to or slightly higher than the final payload size\&.
.PP
\fBParameters:\fP
.RS 4
\fIop\fP The opcode for the new message 
.br
\fIsize\fP \fBA\fP hint to optimize the initial allocation of payload space\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBA\fP new message buffer 
.RE
.PP

.SS "template<typename config > std::string const  & \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_origin () const"

.PP
Return the same origin policy origin value from the opening request\&. This value is available after the HTTP request has been fully read and may be called from any thread\&.
.PP
\fBReturns:\fP
.RS 4
The connection's origin value from the opening handshake\&. 
.RE
.PP

.SS "template<typename config > uint16_t \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_port () const"

.PP
Returns the port component of the connection URI\&. This value is available after the HTTP request has been fully read and may be called from any thread\&.
.PP
\fBReturns:\fP
.RS 4
The port component of the connection URI 
.RE
.PP

.SS "template<typename config> \fBclose::status::value\fP \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_remote_close_code () const\fC [inline]\fP"

.PP
Get the WebSocket close code sent by the remote endpoint\&. 
.PP
\fBReturns:\fP
.RS 4
The WebSocket close code sent by the remote endpoint\&. 
.RE
.PP

.SS "template<typename config> std::string const& \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_remote_close_reason () const\fC [inline]\fP"

.PP
Get the WebSocket close reason sent by the remote endpoint\&. 
.PP
\fBReturns:\fP
.RS 4
The WebSocket close reason sent by the remote endpoint\&. 
.RE
.PP

.SS "template<typename config> \fBrequest_type\fP const& \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_request () const\fC [inline]\fP"

.PP
Get request object\&. Direct access to request object\&. This can be used to call methods of the request object that are not part of the standard request API that connection wraps\&.
.PP
Note use of this method involves using behavior specific to the configured HTTP policy\&. Such behavior may not work with alternate HTTP policies\&.
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0-alpha3
.RE
.PP
\fBReturns:\fP
.RS 4
\fBA\fP const reference to the raw request object 
.RE
.PP

.SS "template<typename config > std::string const  & \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_request_body () const"

.PP
Retrieve a request body\&. Retrieve the value of the request body\&. This value is typically used with PUT and POST requests to upload files or other data\&. Only HTTP connections will ever have bodies\&. WebSocket connection's will always have blank bodies\&.
.PP
\fBReturns:\fP
.RS 4
The value of the request body\&. 
.RE
.PP

.SS "template<typename config > std::string const  & \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_request_header (std::string const & key) const"

.PP
Retrieve a request header\&. Retrieve the value of a header from the handshake HTTP request\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP Name of the header to get 
.RE
.PP
\fBReturns:\fP
.RS 4
The value of the header 
.RE
.PP

.SS "template<typename config > \fBstd::vector\fP< std::string > const  & \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_requested_subprotocols () const"

.PP
Gets all of the subprotocols requested by the client\&. Retrieves the subprotocols that were requested during the handshake\&. This method is valid in the validate handler and later\&.
.PP
\fBReturns:\fP
.RS 4
\fBA\fP vector of the requested subprotocol 
.RE
.PP

.SS "template<typename config > std::string const  & \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_resource () const"

.PP
Returns the resource component of the connection URI\&. This value is available after the HTTP request has been fully read and may be called from any thread\&.
.PP
\fBReturns:\fP
.RS 4
The resource component of the connection URI 
.RE
.PP

.SS "template<typename config> \fBresponse_type\fP const& \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_response () const\fC [inline]\fP"

.PP
Get response object\&. Direct access to the HTTP response sent or received as a part of the opening handshake\&. This can be used to call methods of the response object that are not part of the standard request API that connection wraps\&.
.PP
Note use of this method involves using behavior specific to the configured HTTP policy\&. Such behavior may not work with alternate HTTP policies\&.
.PP
\fBSince:\fP
.RS 4
0\&.7\&.0
.RE
.PP
\fBReturns:\fP
.RS 4
\fBA\fP const reference to the raw response object 
.RE
.PP

.SS "template<typename config> http::status_code::value \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_response_code () const\fC [inline]\fP"

.PP
Get response HTTP status code\&. Gets the response status code
.PP
\fBSince:\fP
.RS 4
0\&.7\&.0
.RE
.PP
\fBReturns:\fP
.RS 4
The response status code sent 
.RE
.PP

.SS "template<typename config > std::string const  & \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_response_header (std::string const & key) const"

.PP
Retrieve a response header\&. Retrieve the value of a header from the handshake HTTP request\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP Name of the header to get 
.RE
.PP
\fBReturns:\fP
.RS 4
The value of the header 
.RE
.PP

.SS "template<typename config> std::string const& \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_response_msg () const\fC [inline]\fP"

.PP
Get response HTTP status message\&. Gets the response status message
.PP
\fBSince:\fP
.RS 4
0\&.7\&.0
.RE
.PP
\fBReturns:\fP
.RS 4
The response status message sent 
.RE
.PP

.SS "template<typename config > bool \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_secure () const"

.PP
Returns the secure flag from the connection URI\&. This value is available after the HTTP request has been fully read and may be called from any thread\&.
.PP
\fBReturns:\fP
.RS 4
Whether or not the connection URI is flagged secure\&. 
.RE
.PP

.SS "template<typename config > session::state::value \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_state () const"

.PP
Return the connection state\&. Values can be connecting, open, closing, and closed
.PP
\fBReturns:\fP
.RS 4
The connection's current state\&. 
.RE
.PP

.SS "template<typename config > std::string const  & \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_subprotocol () const"

.PP
Gets the negotated subprotocol\&. Retrieves the subprotocol that was negotiated during the handshake\&. This method is valid in the open handler and later\&.
.PP
\fBReturns:\fP
.RS 4
The negotiated subprotocol 
.RE
.PP

.SS "template<typename config > \fBuri_ptr\fP \fBwebsocketpp::connection\fP< \fBconfig\fP >::get_uri () const"

.PP
Gets the connection URI\&. This should really only be called by internal library methods unless you really know what you are doing\&.
.PP
\fBReturns:\fP
.RS 4
\fBA\fP pointer to the connection's URI 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::handle_pause_reading ()"

.PP
Pause reading callback\&. Pause reading handler\&. Not safe to call directly\&. 
.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::handle_resume_reading ()"

.PP
Resume reading callback\&. Resume reading helper method\&. Not safe to call directly\&. 
.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::handle_write_frame (lib::error_code const & ec)"

.PP
Process the results of a frame write operation and start the next write\&. 
.PP
\fBTodo\fP
.RS 4
unit tests
.RE
.PP
.PP
This method locks the m_write_lock mutex
.PP
\fBParameters:\fP
.RS 4
\fIterminate\fP Whether or not to terminate the connection upon completion of this write\&.
.br
\fIec\fP \fBA\fP status code from the transport layer, zero on success, non-zero otherwise\&. 
.RE
.PP

.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::initialize_processor ()\fC [protected]\fP"
Set m_processor based on information in m_request\&. Set m_response status and return an error code indicating status\&. 
.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::interrupt ()"

.PP
Asyncronously invoke handler::on_inturrupt\&. Trigger the on_interrupt handler\&.
.PP
Signals to the connection to asyncronously invoke the on_inturrupt callback for this connection's handler once it is safe to do so\&.
.PP
When the on_inturrupt handler callback is called it will be from within the transport event loop with all the thread safety features guaranteed by the transport to regular handlers
.PP
Multiple inturrupt signals can be active at once on the same connection
.PP
\fBReturns:\fP
.RS 4
An error code
.RE
.PP
This is thread safe if the transport is thread safe 
.SS "template<typename config> bool \fBwebsocketpp::connection\fP< \fBconfig\fP >::is_server () const\fC [inline]\fP"

.PP
Get whether or not this connection is part of a server or client\&. 
.PP
\fBReturns:\fP
.RS 4
whether or not the connection is attached to a server endpoint 
.RE
.PP

.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::pause_reading ()"

.PP
Pause reading of new data\&. Signals to the connection to halt reading of new data\&. While reading is paused, the connection will stop reading from its associated socket\&. In turn this will result in TCP based flow control kicking in and slowing data flow from the remote endpoint\&.
.PP
This is useful for applications that push new requests to a queue to be processed by another thread and need a way to signal when their request queue is full without blocking the network processing thread\&.
.PP
Use \fC\fBresume_reading()\fP\fP to resume\&.
.PP
If supported by the transport this is done asynchronously\&. As such reading may not stop until the current read operation completes\&. Typically you can expect to receive no more bytes after initiating a read pause than the size of the read buffer\&.
.PP
If reading is paused for this connection already nothing is changed\&. 
.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::ping (std::string const & payload)"

.PP
Send a ping\&. Initiates a ping with the given payload/
.PP
There is no feedback directly from ping except in cases of immediately detectable errors\&. Feedback will be provided via on_pong or on_pong_timeout callbacks\&.
.PP
Ping locks the m_write_lock mutex
.PP
\fBParameters:\fP
.RS 4
\fIpayload\fP Payload to be used for the ping 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::pong (std::string const & payload)"

.PP
Send a pong\&. Initiates a pong with the given payload\&.
.PP
There is no feedback from a pong once sent\&.
.PP
Pong locks the m_write_lock mutex
.PP
\fBParameters:\fP
.RS 4
\fIpayload\fP Payload to be used for the pong 
.RE
.PP

.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::process_handshake_request ()\fC [protected]\fP"
Perform WebSocket handshake validation of m_request using m_processor\&. set m_response and return an error code indicating status\&. 
.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::remove_header (std::string const & key)"

.PP
Remove a header\&. Removes a header from the response\&.
.PP
This member function is valid only from the http() and \fBvalidate()\fP handler callbacks, or to a client connection before connect has been called\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP The name of the header to remove 
.RE
.PP
\fBSee also:\fP
.RS 4
websocketpp::http::parser::remove_header 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::replace_header (std::string const & key, std::string const & val)"

.PP
Replace a header\&. If a header with this name already exists the old value will be replaced Use \fC\fBconnection::append_header\fP\fP to append to a list of existing values\&.
.PP
This member function is valid only from the http() and \fBvalidate()\fP handler callbacks, or to a client connection before connect has been called\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP Name of the header to set 
.br
\fIval\fP \fBValue\fP to set 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBappend_header\fP 
.PP
websocketpp::http::parser::replace_header 
.RE
.PP

.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::resume_reading ()"

.PP
Resume reading of new data\&. Signals to the connection to resume reading of new data after it was paused by \fC\fBpause_reading()\fP\fP\&.
.PP
If reading is not paused for this connection already nothing is changed\&. 
.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::select_subprotocol (std::string const & value, lib::error_code & ec)"

.PP
Select a subprotocol to use (exception free) Indicates which subprotocol should be used for this connection\&. Valid only during the validate handler callback\&. Subprotocol selected must have been requested by the client\&. Consult \fBget_requested_subprotocols()\fP for a list of valid subprotocols\&.
.PP
This member function is valid on server endpoints/connections only
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP The subprotocol to select 
.br
\fIec\fP \fBA\fP reference to an error code that will be filled in the case of errors 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::select_subprotocol (std::string const & value)"

.PP
Select a subprotocol to use\&. Indicates which subprotocol should be used for this connection\&. Valid only during the validate handler callback\&. Subprotocol selected must have been requested by the client\&. Consult \fBget_requested_subprotocols()\fP for a list of valid subprotocols\&.
.PP
This member function is valid on server endpoints/connections only
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP The subprotocol to select 
.RE
.PP

.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::send (std::string const & payload, frame::opcode::value op = \fCframe::opcode::text\fP)"

.PP
Create a message and then add it to the outgoing send queue\&. Convenience method to send a message given a payload string and optionally an opcode\&. Default opcode is utf8 text\&.
.PP
This method locks the m_write_lock mutex
.PP
\fBParameters:\fP
.RS 4
\fIpayload\fP The payload string to generated the message with
.br
\fIop\fP The opcode to generated the message with\&. Default is frame::opcode::text 
.RE
.PP

.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::send (void const * payload, size_t len, frame::opcode::value op = \fCframe::opcode::binary\fP)"

.PP
Send a message (raw array overload) Convenience method to send a message given a raw array and optionally an opcode\&. Default opcode is binary\&.
.PP
This method locks the m_write_lock mutex
.PP
\fBParameters:\fP
.RS 4
\fIpayload\fP \fBA\fP pointer to the array containing the bytes to send\&.
.br
\fIlen\fP Length of the array\&.
.br
\fIop\fP The opcode to generated the message with\&. Default is frame::opcode::binary 
.RE
.PP

.SS "template<typename config > lib::error_code \fBwebsocketpp::connection\fP< \fBconfig\fP >::send (message_ptr msg)"

.PP
Add a message to the outgoing send queue\&. If presented with a prepared message it is added without validation or framing\&. If presented with an unprepared message it is validated, framed, and then added
.PP
Errors are returned via an exception 
.PP
\fBTodo\fP
.RS 4
make exception system_error rather than error_code
.RE
.PP
.PP
This method invokes the m_write_lock mutex
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP \fBA\fP message_ptr to the message to send\&. 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::send_http_response (lib::error_code & ec)"

.PP
Send deferred HTTP Response (exception free) Sends an http response to an HTTP connection that was deferred\&. This will send a complete response including all headers, status line, and body text\&. The connection will be closed afterwards\&.
.PP
\fBSince:\fP
.RS 4
0\&.6\&.0
.RE
.PP
\fBParameters:\fP
.RS 4
\fIec\fP \fBA\fP status code, zero on success, non-zero otherwise 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_body (std::string const & value)"

.PP
Set response body content\&. Set the body content of the HTTP response to the parameter string\&. Note set_body will also set the Content-Length HTTP header to the appropriate value\&. If you want the Content-Length header to be something else set it to something else after calling set_body
.PP
This member function is valid only from the http() and \fBvalidate()\fP handler callbacks\&.
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP String data to include as the body content\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
websocketpp::http::response::set_body 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_close_handler (\fBclose_handler\fP h)\fC [inline]\fP"

.PP
Set close handler\&. The close handler is called immediately after the connection is closed\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new close_handler 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_close_handshake_timeout (long dur)\fC [inline]\fP"

.PP
Set close handshake timeout\&. Sets the length of time the library will wait after a closing handshake has been initiated before cancelling it\&. This can be used to prevent excessive wait times for outgoing clients or excessive resource usage from broken clients or DoS attacks on servers\&.
.PP
Connections that time out will have their close handlers called with the close_handshake_timeout error code\&.
.PP
The default value is specified via the compile time config value 'timeout_close_handshake'\&. The default value in the core config is 5000ms\&. \fBA\fP value of 0 will disable the timer entirely\&.
.PP
To be effective, the transport you are using must support timers\&. See the documentation for your transport policy for details about its timer support\&.
.PP
\fBParameters:\fP
.RS 4
\fIdur\fP The length of the close handshake timeout in ms 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_fail_handler (\fBfail_handler\fP h)\fC [inline]\fP"

.PP
Set fail handler\&. The fail handler is called whenever the connection fails while the handshake is bring processed\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new fail_handler 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_handle (\fBconnection_hdl\fP hdl)\fC [inline]\fP"

.PP
Set Connection Handle\&. The connection handle is a token that can be shared outside the WebSocket++ core for the purposes of identifying a connection and sending it messages\&.
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP \fBA\fP connection_hdl that the connection will use to refer to itself\&. 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_http_handler (\fBhttp_handler\fP h)\fC [inline]\fP"

.PP
Set http handler\&. The http handler is called after an HTTP request other than a WebSocket upgrade request is received\&. It allows a WebSocket++ server to respond to regular HTTP requests on the same port as it processes WebSocket connections\&. This can be useful for hosting error messages, flash policy files, status pages, and other simple HTTP responses\&. It is not intended to be used as a primary web server\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new http_handler 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_interrupt_handler (\fBinterrupt_handler\fP h)\fC [inline]\fP"

.PP
Set interrupt handler\&. The interrupt handler is called whenever the connection is manually interrupted by the application\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new interrupt_handler 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_max_http_body_size (size_t new_value)\fC [inline]\fP"

.PP
Set maximum HTTP message body size\&. Set maximum HTTP message body size\&. Maximum message body size determines the point at which the connection will stop reading an HTTP request whose body is too large\&.
.PP
The default is set by the endpoint that creates the connection\&.
.PP
\fBSince:\fP
.RS 4
0\&.5\&.0
.RE
.PP
\fBParameters:\fP
.RS 4
\fInew_value\fP The value to set as the maximum message size\&. 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_max_message_size (size_t new_value)\fC [inline]\fP"

.PP
Set maximum message size\&. Set maximum message size\&. Maximum message size determines the point at which the connection will fail with the message_too_big protocol error\&. This value may be changed during the connection\&.
.PP
The default is set by the endpoint that creates the connection\&.
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0
.RE
.PP
\fBParameters:\fP
.RS 4
\fInew_value\fP The value to set as the maximum message size\&. 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_message_handler (message_handler h)\fC [inline]\fP"

.PP
Set message handler\&. The message handler is called after a new message has been received\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new message_handler 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_open_handler (\fBopen_handler\fP h)\fC [inline]\fP"

.PP
Set open handler\&. The open handler is called after the WebSocket handshake is complete and the connection is considered OPEN\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new open_handler 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_open_handshake_timeout (long dur)\fC [inline]\fP"

.PP
Set open handshake timeout\&. Sets the length of time the library will wait after an opening handshake has been initiated before cancelling it\&. This can be used to prevent excessive wait times for outgoing clients or excessive resource usage from broken clients or DoS attacks on servers\&.
.PP
Connections that time out will have their fail handlers called with the open_handshake_timeout error code\&.
.PP
The default value is specified via the compile time config value 'timeout_open_handshake'\&. The default value in the core config is 5000ms\&. \fBA\fP value of 0 will disable the timer entirely\&.
.PP
To be effective, the transport you are using must support timers\&. See the documentation for your transport policy for details about its timer support\&.
.PP
\fBParameters:\fP
.RS 4
\fIdur\fP The length of the open handshake timeout in ms 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_ping_handler (\fBping_handler\fP h)\fC [inline]\fP"

.PP
Set ping handler\&. The ping handler is called whenever the connection receives a ping control frame\&. The ping payload is included\&.
.PP
The ping handler's return time controls whether or not a pong is sent in response to this ping\&. Returning false will suppress the return pong\&. If no ping handler is set a pong will be sent\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new ping_handler 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_pong_handler (\fBpong_handler\fP h)\fC [inline]\fP"

.PP
Set pong handler\&. The pong handler is called whenever the connection receives a pong control frame\&. The pong payload is included\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new pong_handler 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_pong_timeout (long dur)\fC [inline]\fP"

.PP
Set pong timeout\&. Sets the length of time the library will wait for a pong response to a ping\&. This can be used as a keepalive or to detect broken connections\&.
.PP
Pong responses that time out will have the pong timeout handler called\&.
.PP
The default value is specified via the compile time config value 'timeout_pong'\&. The default value in the core config is 5000ms\&. \fBA\fP value of 0 will disable the timer entirely\&.
.PP
To be effective, the transport you are using must support timers\&. See the documentation for your transport policy for details about its timer support\&.
.PP
\fBParameters:\fP
.RS 4
\fIdur\fP The length of the pong timeout in ms 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_pong_timeout_handler (\fBpong_timeout_handler\fP h)\fC [inline]\fP"

.PP
Set pong timeout handler\&. If the transport component being used supports timers, the pong timeout handler is called whenever a pong control frame is not received with the configured timeout period after the application sends a ping\&.
.PP
The config setting \fCtimeout_pong\fP controls the length of the timeout period\&. It is specified in milliseconds\&.
.PP
This can be used to probe the health of the remote endpoint's WebSocket implementation\&. This does not guarantee that the remote application itself is still healthy but can be a useful diagnostic\&.
.PP
Note: receipt of this callback doesn't mean the pong will never come\&. This functionality will not suppress delivery of the pong in question should it arrive after the timeout\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new pong_timeout_handler 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_status (http::status_code::value code)"

.PP
Set response status code and message\&. Sets the response status code to \fCcode\fP and looks up the corresponding message for standard codes\&. Non-standard codes will be entered as Unknown use set_status(status_code::value,std::string) overload to set both values explicitly\&.
.PP
This member function is valid only from the http() and \fBvalidate()\fP handler callbacks\&.
.PP
\fBParameters:\fP
.RS 4
\fIcode\fP Code to set 
.br
\fImsg\fP Message to set 
.RE
.PP
\fBSee also:\fP
.RS 4
websocketpp::http::response::set_status 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_status (http::status_code::value code, std::string const & msg)"

.PP
Set response status code and message\&. Sets the response status code and message to independent custom values\&. use set_status(status_code::value) to set the code and have the standard message be automatically set\&.
.PP
This member function is valid only from the http() and \fBvalidate()\fP handler callbacks\&.
.PP
\fBParameters:\fP
.RS 4
\fIcode\fP Code to set 
.br
\fImsg\fP Message to set 
.RE
.PP
\fBSee also:\fP
.RS 4
websocketpp::http::response::set_status 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_termination_handler (termination_handler new_handler)"
Sets the handler for a terminating connection\&. Should only be used internally by the endpoint class\&. 
.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_uri (\fBuri_ptr\fP uri)"

.PP
Sets the connection URI\&. This should really only be called by internal library methods unless you really know what you are doing\&.
.PP
\fBParameters:\fP
.RS 4
\fIuri\fP The new URI to set 
.RE
.PP

.SS "template<typename config> void \fBwebsocketpp::connection\fP< \fBconfig\fP >::set_validate_handler (\fBvalidate_handler\fP h)\fC [inline]\fP"

.PP
Set validate handler\&. The validate handler is called after a WebSocket handshake has been parsed but before a response is returned\&. It provides the application a chance to examine the request and determine whether or not it wants to accept the connection\&.
.PP
Returning false from the validate handler will reject the connection\&. If no validate handler is present, all connections will be allowed\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The new validate_handler 
.RE
.PP

.SS "template<typename config > void \fBwebsocketpp::connection\fP< \fBconfig\fP >::write_frame ()"

.PP
Checks if there are frames in the send queue and if there are sends one\&. 
.PP
\fBTodo\fP
.RS 4
unit tests
.RE
.PP
.PP
This method locks the m_write_lock mutex 

.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
