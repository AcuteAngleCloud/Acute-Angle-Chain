.TH "aacio::fixed_point32< Q >" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
aacio::fixed_point32< Q > \- 32 bits representation of Fixed Point class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fixedpoint\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP (const \fBfixed_point64\fP< QR > &r)"
.br
.ti -1c
.RI "\fBfixed_point32\fP (int32_t param=0)"
.br
.ti -1c
.RI "int32_t \fBint_part\fP () const"
.br
.RI "To get the integer part of the fixed number\&. "
.ti -1c
.RI "uint32_t \fBfrac_part\fP () const"
.br
.ti -1c
.RI "void \fBprint\fP () const"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP & \fBoperator=\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP & \fBoperator=\fP (const \fBfixed_point64\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP<(Q >QR)?Q:QR > \fBoperator+\fP (const \fBfixed_point32\fP< QR > &r) const"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP<(Q >QR)?Q:QR > \fBoperator\-\fP (const \fBfixed_point32\fP< QR > &r) const"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point64\fP< Q+QR > \fBoperator*\fP (const \fBfixed_point32\fP< QR > &r) const"
.br
.RI "Multiplication operator for \fBfixed_point32\fP\&. The result goes to \fBfixed_point64\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point64\fP< Q+32\-QR > \fBoperator/\fP (const \fBfixed_point32\fP< QR > &r) const"
.br
.RI "Division of two \fBfixed_point32\fP result will be stored in \fBfixed_point64\fP\&. "
.ti -1c
.RI "template<uint8_t QR> bool \fBoperator==\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> bool \fBoperator>\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> bool \fBoperator<\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP< Q > & \fBoperator=\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP< Q > & \fBoperator=\fP (const \fBfixed_point64\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP<(Q >QR)?Q:QR > \fBoperator+\fP (const \fBfixed_point32\fP< QR > &rhs) const"
.br
.RI "Addition between two \fBfixed_point32\fP variables and the result goes to \fBfixed_point32\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP<(Q >QR)?Q:QR > \fBoperator\-\fP (const \fBfixed_point32\fP< QR > &rhs) const"
.br
.RI "Subtraction between two \fBfixed_point32\fP variables and the result goes to \fBfixed_point32\fP\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "int32_t \fBval\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<uint8_t Q>
.br
struct aacio::fixed_point32< Q >"
32 bits representation of Fixed Point class\&. 

This class is implemented to to replace the floating point variables It can resolve floating point undetermenistic related issues
.PP
Example: 
.PP
.nf
fixed_point32<17> b(9\&.654);
fixed_point32<18> c = a*b;
fixed_point32<24> d = a+b+c;
fixed_point32<24> e = b/a;

.fi
.PP
 
.SH "Member Function Documentation"
.PP 
.SS "template<uint8_t Q> int32_t \fBaacio::fixed_point32\fP< Q >::int_part () const\fC [inline]\fP"

.PP
To get the integer part of the fixed number\&. Get the integer part of the 64 bit fixed number 
.PP
\fBReturns:\fP
.RS 4
Returns integer part of the fixed number
.RE
.PP
Example: 
.PP
.nf
fixed_point32<18> a(1234\&.455667)
std::cout << a\&.int_part(); // Output: 1234

.fi
.PP
 

.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
