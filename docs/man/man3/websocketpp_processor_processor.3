.TH "websocketpp::processor::processor< config >" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
websocketpp::processor::processor< config > \- WebSocket protocol processor abstract base class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <processor\&.hpp>\fP
.PP
Inherited by \fBwebsocketpp::processor::hybi00< config >\fP, and \fBwebsocketpp::processor::hybi13< config >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBprocessor\fP< \fBconfig\fP > \fBtype\fP"
.br
.ti -1c
.RI "typedef \fBconfig::request_type\fP \fBrequest_type\fP"
.br
.ti -1c
.RI "typedef \fBconfig::response_type\fP \fBresponse_type\fP"
.br
.ti -1c
.RI "typedef config::message_type::ptr \fBmessage_ptr\fP"
.br
.ti -1c
.RI "typedef std::pair< lib::error_code, std::string > \fBerr_str_pair\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBprocessor\fP (bool secure, bool p_is_server)"
.br
.ti -1c
.RI "virtual int \fBget_version\fP () const =0"
.br
.RI "Get the protocol version of this processor\&. "
.ti -1c
.RI "size_t \fBget_max_message_size\fP () const"
.br
.RI "Get maximum message size\&. "
.ti -1c
.RI "void \fBset_max_message_size\fP (size_t new_value)"
.br
.RI "Set maximum message size\&. "
.ti -1c
.RI "virtual bool \fBhas_permessage_compress\fP () const"
.br
.RI "Returns whether or not the permessage_compress extension is implemented\&. "
.ti -1c
.RI "virtual err_str_pair \fBnegotiate_extensions\fP (\fBrequest_type\fP const &)"
.br
.RI "Initializes extensions based on the Sec-WebSocket-Extensions header\&. "
.ti -1c
.RI "virtual err_str_pair \fBnegotiate_extensions\fP (\fBresponse_type\fP const &)"
.br
.RI "Initializes extensions based on the Sec-WebSocket-Extensions header\&. "
.ti -1c
.RI "virtual lib::error_code \fBvalidate_handshake\fP (\fBrequest_type\fP const &request) const =0"
.br
.RI "validate a WebSocket handshake request for this version "
.ti -1c
.RI "virtual lib::error_code \fBprocess_handshake\fP (\fBrequest_type\fP const &req, std::string const &subprotocol, \fBresponse_type\fP &res) const =0"
.br
.RI "Calculate the appropriate response for this websocket request\&. "
.ti -1c
.RI "virtual lib::error_code \fBclient_handshake_request\fP (\fBrequest_type\fP &req, \fBuri_ptr\fP \fBuri\fP, \fBstd::vector\fP< std::string > const &subprotocols) const =0"
.br
.RI "Fill in an HTTP request for an outgoing connection handshake\&. "
.ti -1c
.RI "virtual lib::error_code \fBvalidate_server_handshake_response\fP (\fBrequest_type\fP const &req, \fBresponse_type\fP &res) const =0"
.br
.RI "Validate the server's response to an outgoing handshake request\&. "
.ti -1c
.RI "virtual std::string \fBget_raw\fP (\fBresponse_type\fP const &request) const =0"
.br
.RI "Given a completed response, get the raw bytes to put on the wire\&. "
.ti -1c
.RI "virtual std::string const  & \fBget_origin\fP (\fBrequest_type\fP const &request) const =0"
.br
.RI "Return the value of the header containing the CORS origin\&. "
.ti -1c
.RI "virtual lib::error_code \fBextract_subprotocols\fP (const \fBrequest_type\fP &req, \fBstd::vector\fP< std::string > &subprotocol_list)=0"
.br
.RI "Extracts requested subprotocols from a handshake request\&. "
.ti -1c
.RI "virtual \fBuri_ptr\fP \fBget_uri\fP (\fBrequest_type\fP const &request) const =0"
.br
.RI "Extracts client uri from a handshake request\&. "
.ti -1c
.RI "virtual size_t \fBconsume\fP (uint8_t *buf, size_t len, lib::error_code &ec)=0"
.br
.RI "process new websocket connection bytes "
.ti -1c
.RI "virtual bool \fBready\fP () const =0"
.br
.RI "Checks if there is a message ready\&. "
.ti -1c
.RI "virtual message_ptr \fBget_message\fP ()=0"
.br
.RI "Retrieves the most recently processed message\&. "
.ti -1c
.RI "virtual bool \fBget_error\fP () const =0"
.br
.RI "Tests whether the processor is in a fatal error state\&. "
.ti -1c
.RI "virtual size_t \fBget_bytes_needed\fP () const"
.br
.ti -1c
.RI "virtual lib::error_code \fBprepare_data_frame\fP (message_ptr in, message_ptr out)=0"
.br
.RI "Prepare a data message for writing\&. "
.ti -1c
.RI "virtual lib::error_code \fBprepare_ping\fP (std::string const &in, message_ptr out) const =0"
.br
.RI "Prepare a ping frame\&. "
.ti -1c
.RI "virtual lib::error_code \fBprepare_pong\fP (std::string const &in, message_ptr out) const =0"
.br
.RI "Prepare a pong frame\&. "
.ti -1c
.RI "virtual lib::error_code \fBprepare_close\fP (\fBclose::status::value\fP code, std::string const &reason, message_ptr out) const =0"
.br
.RI "Prepare a close frame\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool const \fBm_secure\fP"
.br
.ti -1c
.RI "bool const \fBm_server\fP"
.br
.ti -1c
.RI "size_t \fBm_max_message_size\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename config>
.br
class websocketpp::processor::processor< config >"
WebSocket protocol processor abstract base class\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::client_handshake_request (\fBrequest_type\fP & req, \fBuri_ptr\fP uri, \fBstd::vector\fP< std::string > const & subprotocols) const\fC [pure virtual]\fP"

.PP
Fill in an HTTP request for an outgoing connection handshake\&. 
.PP
\fBParameters:\fP
.RS 4
\fIreq\fP The request to process\&.
.RE
.PP
\fBReturns:\fP
.RS 4
An error code, 0 on success, non-zero for other errors 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, \fBwebsocketpp::processor::hybi13< stub_config >\fP, \fBwebsocketpp::processor::hybi00< config >\fP, \fBwebsocketpp::processor::hybi00< stub_config >\fP, \fBwebsocketpp::processor::hybi08< config >\fP, and \fBwebsocketpp::processor::hybi07< config >\fP\&.
.SS "template<typename config> virtual size_t \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::consume (uint8_t * buf, size_t len, lib::error_code & ec)\fC [pure virtual]\fP"

.PP
process new websocket connection bytes WebSocket connections are a continous stream of bytes that must be interpreted by a protocol processor into discrete frames\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Buffer from which bytes should be read\&. 
.br
\fIlen\fP Length of buffer 
.br
\fIec\fP Reference to an error code to return any errors in 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of bytes processed 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, \fBwebsocketpp::processor::hybi13< stub_config >\fP, \fBwebsocketpp::processor::hybi00< config >\fP, and \fBwebsocketpp::processor::hybi00< stub_config >\fP\&.
.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::extract_subprotocols (const \fBrequest_type\fP & req, \fBstd::vector\fP< std::string > & subprotocol_list)\fC [pure virtual]\fP"

.PP
Extracts requested subprotocols from a handshake request\&. Extracts a list of all subprotocols that the client has requested in the given opening handshake request\&.
.PP
\fBParameters:\fP
.RS 4
\fIreq\fP The request to extract from 
.br
\fIsubprotocol_list\fP \fBA\fP reference to a vector of strings to store the results in\&. 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, \fBwebsocketpp::processor::hybi13< stub_config >\fP, \fBwebsocketpp::processor::hybi00< config >\fP, and \fBwebsocketpp::processor::hybi00< stub_config >\fP\&.
.SS "template<typename config> virtual size_t \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::get_bytes_needed () const\fC [inline]\fP, \fC [virtual]\fP"
Retrieves the number of bytes presently needed by the processor This value may be used as a hint to the transport layer as to how many bytes to wait for before running consume again\&. 
.PP
Reimplemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, and \fBwebsocketpp::processor::hybi13< stub_config >\fP\&.
.SS "template<typename config> size_t \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::get_max_message_size () const\fC [inline]\fP"

.PP
Get maximum message size\&. Get maximum message size\&. Maximum message size determines the point at which the processor will fail a connection with the message_too_big protocol error\&.
.PP
The default is retrieved from the max_message_size value from the template config
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0 
.RE
.PP

.SS "template<typename config> virtual message_ptr \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::get_message ()\fC [pure virtual]\fP"

.PP
Retrieves the most recently processed message\&. Retrieves a shared pointer to the recently completed message if there is one\&. If \fBready()\fP returns true then there is a message available\&. Retrieving the message with get_message will reset the state of ready\&. As such, each new message may be retrieved only once\&. Calling get_message when there is no message available will result in a null pointer being returned\&.
.PP
\fBReturns:\fP
.RS 4
\fBA\fP pointer to the most recently processed message or a null shared pointer\&. 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, \fBwebsocketpp::processor::hybi13< stub_config >\fP, \fBwebsocketpp::processor::hybi00< config >\fP, and \fBwebsocketpp::processor::hybi00< stub_config >\fP\&.
.SS "template<typename config> virtual bool \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::has_permessage_compress () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Returns whether or not the permessage_compress extension is implemented\&. Compile time flag that indicates whether this processor has implemented the permessage_compress extension\&. By default this is false\&. 
.SS "template<typename config> virtual err_str_pair \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::negotiate_extensions (\fBrequest_type\fP const &)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Initializes extensions based on the Sec-WebSocket-Extensions header\&. Reads the Sec-WebSocket-Extensions header and determines if any of the requested extensions are supported by this processor\&. If they are their settings data is initialized and an extension string to send to the is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fIrequest\fP The request or response headers to look at\&. 
.RE
.PP

.PP
Reimplemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, and \fBwebsocketpp::processor::hybi13< stub_config >\fP\&.
.SS "template<typename config> virtual err_str_pair \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::negotiate_extensions (\fBresponse_type\fP const &)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Initializes extensions based on the Sec-WebSocket-Extensions header\&. Reads the Sec-WebSocket-Extensions header and determines if any of the requested extensions were accepted by the server\&. If they are their settings data is initialized\&. If they are not a list of required extensions (if any) is returned\&. This list may be sent back to the server as a part of the 1010/Extension required close code\&.
.PP
\fBParameters:\fP
.RS 4
\fIresponse\fP The request or response headers to look at\&. 
.RE
.PP

.PP
Reimplemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, and \fBwebsocketpp::processor::hybi13< stub_config >\fP\&.
.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::prepare_close (\fBclose::status::value\fP code, std::string const & reason, message_ptr out) const\fC [pure virtual]\fP"

.PP
Prepare a close frame\&. Close preparation is entirely state free\&. The code and reason are both subject to validation\&. Reason must be valid UTF-8\&. Code must be a valid un-reserved WebSocket close code\&. Use close::status::no_status to indicate no code\&. If no code is supplied a reason may not be specified\&.
.PP
\fBParameters:\fP
.RS 4
\fIcode\fP The close code to send 
.br
\fIreason\fP The reason string to send 
.br
\fIout\fP The message buffer to prepare the fame in 
.RE
.PP
\fBReturns:\fP
.RS 4
Status code, zero on success, non-zero on failure 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, and \fBwebsocketpp::processor::hybi00< config >\fP\&.
.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::prepare_data_frame (message_ptr in, message_ptr out)\fC [pure virtual]\fP"

.PP
Prepare a data message for writing\&. Performs validation, masking, compression, etc\&. will return an error if there was an error, otherwise msg will be ready to be written 
.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, and \fBwebsocketpp::processor::hybi00< config >\fP\&.
.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::prepare_ping (std::string const & in, message_ptr out) const\fC [pure virtual]\fP"

.PP
Prepare a ping frame\&. Ping preparation is entirely state free\&. There is no payload validation other than length\&. Payload need not be UTF-8\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The string to use for the ping payload 
.br
\fIout\fP The message buffer to prepare the ping in\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Status code, zero on success, non-zero on failure 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, and \fBwebsocketpp::processor::hybi00< config >\fP\&.
.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::prepare_pong (std::string const & in, message_ptr out) const\fC [pure virtual]\fP"

.PP
Prepare a pong frame\&. Pong preparation is entirely state free\&. There is no payload validation other than length\&. Payload need not be UTF-8\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The string to use for the pong payload 
.br
\fIout\fP The message buffer to prepare the pong in\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Status code, zero on success, non-zero on failure 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, and \fBwebsocketpp::processor::hybi00< config >\fP\&.
.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::process_handshake (\fBrequest_type\fP const & req, std::string const & subprotocol, \fBresponse_type\fP & res) const\fC [pure virtual]\fP"

.PP
Calculate the appropriate response for this websocket request\&. 
.PP
\fBParameters:\fP
.RS 4
\fIreq\fP The request to process
.br
\fIsubprotocol\fP The subprotocol in use
.br
\fIres\fP The response to store the processed response in
.RE
.PP
\fBReturns:\fP
.RS 4
An error code, 0 on success, non-zero for other errors 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, \fBwebsocketpp::processor::hybi13< stub_config >\fP, \fBwebsocketpp::processor::hybi00< config >\fP, and \fBwebsocketpp::processor::hybi00< stub_config >\fP\&.
.SS "template<typename config> virtual bool \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::ready () const\fC [pure virtual]\fP"

.PP
Checks if there is a message ready\&. Checks if the most recent consume operation processed enough bytes to complete a new WebSocket message\&. The message can be retrieved by calling \fBget_message()\fP which will reset the internal state to not-ready and allow consume to read more bytes\&.
.PP
\fBReturns:\fP
.RS 4
Whether or not a message is ready\&. 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, \fBwebsocketpp::processor::hybi13< stub_config >\fP, \fBwebsocketpp::processor::hybi00< config >\fP, and \fBwebsocketpp::processor::hybi00< stub_config >\fP\&.
.SS "template<typename config> void \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::set_max_message_size (size_t new_value)\fC [inline]\fP"

.PP
Set maximum message size\&. Set maximum message size\&. Maximum message size determines the point at which the processor will fail a connection with the message_too_big protocol error\&.
.PP
The default is retrieved from the max_message_size value from the template config
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0
.RE
.PP
\fBParameters:\fP
.RS 4
\fInew_value\fP The value to set as the maximum message size\&. 
.RE
.PP

.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::validate_handshake (\fBrequest_type\fP const & request) const\fC [pure virtual]\fP"

.PP
validate a WebSocket handshake request for this version 
.PP
\fBParameters:\fP
.RS 4
\fIrequest\fP The WebSocket handshake request to validate\&. is_websocket_handshake(request) must be true and get_websocket_version(request) must equal this->\fBget_version()\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
\fBA\fP status code, 0 on success, non-zero for specific sorts of failure 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, \fBwebsocketpp::processor::hybi13< stub_config >\fP, \fBwebsocketpp::processor::hybi00< config >\fP, and \fBwebsocketpp::processor::hybi00< stub_config >\fP\&.
.SS "template<typename config> virtual lib::error_code \fBwebsocketpp::processor::processor\fP< \fBconfig\fP >::validate_server_handshake_response (\fBrequest_type\fP const & req, \fBresponse_type\fP & res) const\fC [pure virtual]\fP"

.PP
Validate the server's response to an outgoing handshake request\&. 
.PP
\fBParameters:\fP
.RS 4
\fIreq\fP The original request sent 
.br
\fIres\fP The reponse to generate 
.RE
.PP
\fBReturns:\fP
.RS 4
An error code, 0 on success, non-zero for other errors 
.RE
.PP

.PP
Implemented in \fBwebsocketpp::processor::hybi13< config >\fP, \fBwebsocketpp::processor::hybi13< stub_config_ext >\fP, \fBwebsocketpp::processor::hybi13< stub_config >\fP, \fBwebsocketpp::processor::hybi00< config >\fP, and \fBwebsocketpp::processor::hybi00< stub_config >\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
