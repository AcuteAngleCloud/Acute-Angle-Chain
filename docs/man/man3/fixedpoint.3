.TH "fixedpoint" 3 "Sun Jun 3 2018" "Acute-Angle-Chain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
fixedpoint \- 32,64,128,256 bits version of Fixed Point variables  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBaacio::fixed_point32< Q >\fP"
.br
.RI "32 bits representation of Fixed Point class\&. "
.ti -1c
.RI "struct \fBaacio::fixed_point64< Q >\fP"
.br
.RI "64 bits representation of Fixed Point class\&. "
.ti -1c
.RI "struct \fBaacio::fixed_point128< Q >\fP"
.br
.RI "128 bits representation of Fixed Point class\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > \fBT\fP \fBaacio::assignHelper\fP (\fBT\fP rhs_val, uint8_t q, uint8_t qr)"
.br
.ti -1c
.RI "template<uint8_t Q> \fBfixed_point64\fP< Q > \fBaacio::fixed_divide\fP (uint32_t lhs, uint32_t rhs)"
.br
.RI "Wrapper function for dividing two unit64 variable and stores result in \fBfixed_point64\fP\&. "
.ti -1c
.RI "template<uint8_t Q> \fBfixed_point128\fP< Q > \fBaacio::fixed_divide\fP (uint64_t lhs, uint64_t rhs)"
.br
.RI "Wrapper function for dividing two unit64 variable and stores result in \fBfixed_point128\fP Wrapper function for dividing two unit64 variable and stores result in \fBfixed_point128\fP\&. "
.ti -1c
.RI "template<uint8_t qr> \fBaacio::fixed_point128< Q >::fixed_point128\fP (const \fBfixed_point128\fP< qr > &r)"
.br
.ti -1c
.RI "template<uint8_t qr> \fBaacio::fixed_point128< Q >::fixed_point128\fP (const \fBfixed_point64\fP< qr > &r)"
.br
.ti -1c
.RI "template<uint8_t qr> \fBaacio::fixed_point128< Q >::fixed_point128\fP (const \fBfixed_point32\fP< qr > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBaacio::fixed_point64< Q >::fixed_point64\fP (const \fBfixed_point64\fP< QR > &r)"
.br
.RI "Can create \fBfixed_point64\fP instance from int64_t, \fBfixed_point64\fP,32 instances\&. "
.ti -1c
.RI "template<uint8_t QR> \fBaacio::fixed_point64< Q >::fixed_point64\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point64\fP<(Q >QR)?Q:QR > \fBaacio::fixed_point64< Q >::operator+\fP (const \fBfixed_point64\fP< QR > &rhs) const"
.br
.RI "Addition between two \fBfixed_point64\fP variables and the result goes to \fBfixed_point64\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point64\fP<(Q >QR)?Q:QR > \fBaacio::fixed_point64< Q >::operator\-\fP (const \fBfixed_point64\fP< QR > &rhs) const"
.br
.RI "Subtraction between two \fBfixed_point64\fP variables and the result goes to \fBfixed_point64\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point128\fP< Q+QR > \fBaacio::fixed_point64< Q >::operator*\fP (const \fBfixed_point64\fP< QR > &r) const"
.br
.RI "Multiplication operator for \fBfixed_point64\fP\&. The result goes to \fBfixed_point64\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point128\fP< Q+64\-QR > \fBaacio::fixed_point64< Q >::operator/\fP (const \fBfixed_point64\fP< QR > &r) const"
.br
.RI "Division of two \fBfixed_point64\fP result will be stored in \fBfixed_point128\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBaacio::fixed_point32< Q >::fixed_point32\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBaacio::fixed_point32< Q >::fixed_point32\fP (const \fBfixed_point64\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP< Q > & \fBaacio::fixed_point32< Q >::operator=\fP (const \fBfixed_point32\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP< Q > & \fBaacio::fixed_point32< Q >::operator=\fP (const \fBfixed_point64\fP< QR > &r)"
.br
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP<(Q >QR)?Q:QR > \fBaacio::fixed_point32< Q >::operator+\fP (const \fBfixed_point32\fP< QR > &rhs) const"
.br
.RI "Addition between two \fBfixed_point32\fP variables and the result goes to \fBfixed_point32\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point32\fP<(Q >QR)?Q:QR > \fBaacio::fixed_point32< Q >::operator\-\fP (const \fBfixed_point32\fP< QR > &rhs) const"
.br
.RI "Subtraction between two \fBfixed_point32\fP variables and the result goes to \fBfixed_point32\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point64\fP< Q+QR > \fBaacio::fixed_point32< Q >::operator*\fP (const \fBfixed_point32\fP< QR > &r) const"
.br
.RI "Multiplication operator for \fBfixed_point32\fP\&. The result goes to \fBfixed_point64\fP\&. "
.ti -1c
.RI "template<uint8_t QR> \fBfixed_point64\fP< Q+32\-QR > \fBaacio::fixed_point32< Q >::operator/\fP (const \fBfixed_point32\fP< QR > &r) const"
.br
.RI "Division of two \fBfixed_point32\fP result will be stored in \fBfixed_point64\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 
32,64,128,256 bits version of Fixed Point variables 

Floating point operations are indeterministic, hence is prevented in smart contract\&. The smart contract developers should use the appropriate Fixed_Point template class by passing the number to be represented in integer format and the number of decimals required\&. These template classes also support the arithmetic operations and basic comparison operators 
.SH "Function Documentation"
.PP 
.SS "template<uint8_t Q> \fBfixed_point64\fP<Q> aacio::fixed_divide (uint32_t lhs, uint32_t rhs)"

.PP
Wrapper function for dividing two unit64 variable and stores result in \fBfixed_point64\fP\&. Wrapper function for dividing two unit32 variable and stores result in \fBfixed_point64\fP
.PP
Example: 
.PP
.nf
fixed_point64<33> result = fixed_divide(131313, 2323)

.fi
.PP
 
.SS "template<uint8_t Q> \fBfixed_point128\fP<Q> aacio::fixed_divide (uint64_t lhs, uint64_t rhs)"

.PP
Wrapper function for dividing two unit64 variable and stores result in \fBfixed_point128\fP Wrapper function for dividing two unit64 variable and stores result in \fBfixed_point128\fP\&. Example: 
.PP
.nf
fixed_point128<33> result = fixed_divide(131313, 2323)

.fi
.PP
 
.SS "template<uint8_t Q> template<uint8_t QR> \fBaacio::fixed_point64\fP< Q >::\fBfixed_point64\fP (const \fBfixed_point64\fP< QR > & r)"

.PP
Can create \fBfixed_point64\fP instance from int64_t, \fBfixed_point64\fP,32 instances\&. Various constructors for \fBfixed_point64\fP Example: 
.PP
.nf
fixed_point32<18> a(1234\&.455667);
fixed_point64<3> b(a);
fixed_point64<6> b(13324\&.32323);
fixed_point64<5> c(a);

.fi
.PP
 
.SS "template<uint8_t Q> template<uint8_t QR> \fBfixed_point128\fP< Q+QR > \fBaacio::fixed_point64\fP< Q >::operator* (const \fBfixed_point64\fP< QR > & r) const"

.PP
Multiplication operator for \fBfixed_point64\fP\&. The result goes to \fBfixed_point64\fP\&. Multiplication operator for \fBfixed_point64\fP\&. The result goes to \fBfixed_point128\fP Number of decimal on result will be sum of number of decimals of lhs and rhs
.PP
Example: 
.PP
.nf
fixed_point128<33> result = fixed_point64<0>(131313) / fixed_point64<0>(2323)

.fi
.PP
 
.SS "template<uint8_t Q> template<uint8_t QR> \fBfixed_point64\fP< Q+QR > \fBaacio::fixed_point32\fP< Q >::operator* (const \fBfixed_point32\fP< QR > & r) const"

.PP
Multiplication operator for \fBfixed_point32\fP\&. The result goes to \fBfixed_point64\fP\&. Multiplication operator for \fBfixed_point32\fP\&. The result goes to \fBfixed_point64\fP Number of decimal on result will be sum of number of decimals of lhs and rhs
.PP
Example: 
.PP
.nf
fixed_point64<33> result = fixed_point32<0>(131313) / fixed_point32<0>(2323)

.fi
.PP
 
.SS "template<uint8_t Q> template<uint8_t QR> \fBfixed_point64\fP< (Q>QR)?Q:QR > \fBaacio::fixed_point64\fP< Q >::operator+ (const \fBfixed_point64\fP< QR > & rhs) const"

.PP
Addition between two \fBfixed_point64\fP variables and the result goes to \fBfixed_point64\fP\&. Addition between two \fBfixed_point64\fP variables Number of decimal on result will be max of decimals of lhs and rhs 
.SS "template<uint8_t Q> template<uint8_t QR> \fBfixed_point32\fP< (Q>QR)?Q:QR > \fBaacio::fixed_point32\fP< Q >::operator+ (const \fBfixed_point32\fP< QR > & rhs) const"

.PP
Addition between two \fBfixed_point32\fP variables and the result goes to \fBfixed_point32\fP\&. Addition between two \fBfixed_point32\fP variables Number of decimal on result will be max of decimals of lhs and rhs 
.SS "template<uint8_t Q> template<uint8_t QR> \fBfixed_point64\fP< (Q>QR)?Q:QR > \fBaacio::fixed_point64\fP< Q >::operator\- (const \fBfixed_point64\fP< QR > & rhs) const"

.PP
Subtraction between two \fBfixed_point64\fP variables and the result goes to \fBfixed_point64\fP\&. Subtraction between two \fBfixed_point64\fP variables Number of decimal on result will be max of decimals of lhs and rhs 
.SS "template<uint8_t Q> template<uint8_t QR> \fBfixed_point32\fP< (Q>QR)?Q:QR > \fBaacio::fixed_point32\fP< Q >::operator\- (const \fBfixed_point32\fP< QR > & rhs) const"

.PP
Subtraction between two \fBfixed_point32\fP variables and the result goes to \fBfixed_point32\fP\&. Subtraction between two \fBfixed_point32\fP variables Number of decimal on result will be max of decimals of lhs and rhs 
.SS "template<uint8_t Q> template<uint8_t QR> \fBfixed_point128\fP< Q+64\-QR > \fBaacio::fixed_point64\fP< Q >::operator/ (const \fBfixed_point64\fP< QR > & r) const"

.PP
Division of two \fBfixed_point64\fP result will be stored in \fBfixed_point128\fP\&. Division operator for \fBfixed_point64\fP
.PP
Example: 
.PP
.nf
fixed_point128<33> result = fixed_point64<0>(131313) / fixed_point64<0>(2323)

.fi
.PP
 
.SS "template<uint8_t Q> template<uint8_t QR> \fBfixed_point64\fP< Q+32\-QR > \fBaacio::fixed_point32\fP< Q >::operator/ (const \fBfixed_point32\fP< QR > & r) const"

.PP
Division of two \fBfixed_point32\fP result will be stored in \fBfixed_point64\fP\&. Division operator for \fBfixed_point32\fP
.PP
Example: 
.PP
.nf
fixed_point64<33> result = fixed_point32<0>(131313) / fixed_point32<0>(2323)

.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for Acute-Angle-Chain from the source code\&.
