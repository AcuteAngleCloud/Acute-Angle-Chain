.TH "websocketpp::endpoint< connection, config >" 3 "Sun Jun 3 2018" "AcuteAngleChain" \" -*- nroff -*-
.ad l
.nh
.SH NAME
websocketpp::endpoint< connection, config > \- Creates and manages connections associated with a WebSocket endpoint\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <endpoint\&.hpp>\fP
.PP
Inherits \fBwebsocketpp::transport::asio::endpoint< config >\fP, and endpoint_base\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBendpoint\fP< \fBconnection\fP, \fBconfig\fP > \fBtype\fP"
.br
.ti -1c
.RI "typedef \fBconfig::transport_type\fP \fBtransport_type\fP"
.br
.RI "\fBType\fP of the transport component of this endpoint\&. "
.ti -1c
.RI "typedef \fBconfig::concurrency_type\fP \fBconcurrency_type\fP"
.br
.RI "\fBType\fP of the concurrency component of this endpoint\&. "
.ti -1c
.RI "typedef \fBconnection\fP \fBconnection_type\fP"
.br
.RI "\fBType\fP of the connections that this endpoint creates\&. "
.ti -1c
.RI "typedef \fBconnection_type::ptr\fP \fBconnection_ptr\fP"
.br
.RI "Shared pointer to connection_type\&. "
.ti -1c
.RI "typedef \fBconnection_type::weak_ptr\fP \fBconnection_weak_ptr\fP"
.br
.RI "Weak pointer to connection type\&. "
.ti -1c
.RI "typedef \fBtransport_type::transport_con_type\fP \fBtransport_con_type\fP"
.br
.ti -1c
.RI "typedef transport_con_type::ptr \fBtransport_con_ptr\fP"
.br
.ti -1c
.RI "typedef connection_type::message_handler \fBmessage_handler\fP"
.br
.RI "\fBType\fP of message_handler\&. "
.ti -1c
.RI "typedef connection_type::message_ptr \fBmessage_ptr\fP"
.br
.RI "\fBType\fP of message pointers that this endpoint uses\&. "
.ti -1c
.RI "typedef \fBconfig::elog_type\fP \fBelog_type\fP"
.br
.RI "\fBType\fP of error logger\&. "
.ti -1c
.RI "typedef \fBconfig::alog_type\fP \fBalog_type\fP"
.br
.RI "\fBType\fP of access logger\&. "
.ti -1c
.RI "typedef \fBconcurrency_type::scoped_lock_type\fP \fBscoped_lock_type\fP"
.br
.RI "\fBType\fP of our concurrency policy's scoped lock object\&. "
.ti -1c
.RI "typedef \fBconcurrency_type::mutex_type\fP \fBmutex_type\fP"
.br
.RI "\fBType\fP of our concurrency policy's mutex object\&. "
.ti -1c
.RI "typedef \fBconfig::rng_type\fP \fBrng_type\fP"
.br
.RI "\fBType\fP of RNG\&. "
.ti -1c
.RI "typedef connection_type::termination_handler \fBtermination_handler\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBendpoint\fP (bool p_is_server)"
.br
.ti -1c
.RI "\fB~endpoint\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "std::string \fBget_user_agent\fP () const"
.br
.RI "Returns the user agent string that this endpoint will use\&. "
.ti -1c
.RI "void \fBset_user_agent\fP (std::string const &ua)"
.br
.RI "Sets the user agent string that this endpoint will use\&. "
.ti -1c
.RI "bool \fBis_server\fP () const"
.br
.RI "Returns whether or not this endpoint is a server\&. "
.ti -1c
.RI "void \fBset_access_channels\fP (log::level channels)"
.br
.RI "Set Access logging channel\&. "
.ti -1c
.RI "void \fBclear_access_channels\fP (log::level channels)"
.br
.RI "Clear Access logging channels\&. "
.ti -1c
.RI "void \fBset_error_channels\fP (log::level channels)"
.br
.RI "Set Error logging channel\&. "
.ti -1c
.RI "void \fBclear_error_channels\fP (log::level channels)"
.br
.RI "Clear Error logging channels\&. "
.ti -1c
.RI "\fBalog_type\fP & \fBget_alog\fP ()"
.br
.RI "Get reference to access logger\&. "
.ti -1c
.RI "\fBelog_type\fP & \fBget_elog\fP ()"
.br
.RI "Get reference to error logger\&. "
.ti -1c
.RI "void \fBset_open_handler\fP (\fBopen_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_close_handler\fP (\fBclose_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_fail_handler\fP (\fBfail_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_ping_handler\fP (\fBping_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_pong_handler\fP (\fBpong_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_pong_timeout_handler\fP (\fBpong_timeout_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_interrupt_handler\fP (\fBinterrupt_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_http_handler\fP (\fBhttp_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_validate_handler\fP (\fBvalidate_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_message_handler\fP (\fBmessage_handler\fP h)"
.br
.ti -1c
.RI "void \fBset_open_handshake_timeout\fP (long dur)"
.br
.RI "Set open handshake timeout\&. "
.ti -1c
.RI "void \fBset_close_handshake_timeout\fP (long dur)"
.br
.RI "Set close handshake timeout\&. "
.ti -1c
.RI "void \fBset_pong_timeout\fP (long dur)"
.br
.RI "Set pong timeout\&. "
.ti -1c
.RI "size_t \fBget_max_message_size\fP () const"
.br
.RI "Get default maximum message size\&. "
.ti -1c
.RI "void \fBset_max_message_size\fP (size_t new_value)"
.br
.RI "Set default maximum message size\&. "
.ti -1c
.RI "size_t \fBget_max_http_body_size\fP () const"
.br
.RI "Get maximum HTTP message body size\&. "
.ti -1c
.RI "void \fBset_max_http_body_size\fP (size_t new_value)"
.br
.RI "Set maximum HTTP message body size\&. "
.ti -1c
.RI "void \fBinterrupt\fP (\fBconnection_hdl\fP hdl, lib::error_code &ec)"
.br
.ti -1c
.RI "void \fBinterrupt\fP (\fBconnection_hdl\fP hdl)"
.br
.ti -1c
.RI "void \fBpause_reading\fP (\fBconnection_hdl\fP hdl, lib::error_code &ec)"
.br
.RI "Pause reading of new data (exception free) "
.ti -1c
.RI "void \fBpause_reading\fP (\fBconnection_hdl\fP hdl)"
.br
.RI "Pause reading of new data\&. "
.ti -1c
.RI "void \fBresume_reading\fP (\fBconnection_hdl\fP hdl, lib::error_code &ec)"
.br
.RI "Resume reading of new data (exception free) "
.ti -1c
.RI "void \fBresume_reading\fP (\fBconnection_hdl\fP hdl)"
.br
.RI "Resume reading of new data\&. "
.ti -1c
.RI "void \fBsend_http_response\fP (\fBconnection_hdl\fP hdl, lib::error_code &ec)"
.br
.RI "Send deferred HTTP Response\&. "
.ti -1c
.RI "void \fBsend_http_response\fP (\fBconnection_hdl\fP hdl)"
.br
.RI "Send deferred HTTP Response (exception free) "
.ti -1c
.RI "void \fBsend\fP (\fBconnection_hdl\fP hdl, std::string const &payload, frame::opcode::value op, lib::error_code &ec)"
.br
.RI "Create a message and add it to the outgoing send queue (exception free) "
.ti -1c
.RI "void \fBsend\fP (\fBconnection_hdl\fP hdl, std::string const &payload, frame::opcode::value op)"
.br
.RI "Create a message and add it to the outgoing send queue\&. "
.ti -1c
.RI "void \fBsend\fP (\fBconnection_hdl\fP hdl, void const *payload, size_t len, frame::opcode::value op, lib::error_code &ec)"
.br
.ti -1c
.RI "void \fBsend\fP (\fBconnection_hdl\fP hdl, void const *payload, size_t len, frame::opcode::value op)"
.br
.ti -1c
.RI "void \fBsend\fP (\fBconnection_hdl\fP hdl, \fBmessage_ptr\fP msg, lib::error_code &ec)"
.br
.ti -1c
.RI "void \fBsend\fP (\fBconnection_hdl\fP hdl, \fBmessage_ptr\fP msg)"
.br
.ti -1c
.RI "void \fBclose\fP (\fBconnection_hdl\fP hdl, \fBclose::status::value\fP const code, std::string const &reason, lib::error_code &ec)"
.br
.ti -1c
.RI "void \fBclose\fP (\fBconnection_hdl\fP hdl, \fBclose::status::value\fP const code, std::string const &reason)"
.br
.ti -1c
.RI "void \fBping\fP (\fBconnection_hdl\fP hdl, std::string const &payload, lib::error_code &ec)"
.br
.RI "Send a ping to a specific connection\&. "
.ti -1c
.RI "void \fBping\fP (\fBconnection_hdl\fP hdl, std::string const &payload)"
.br
.RI "Send a ping to a specific connection\&. "
.ti -1c
.RI "void \fBpong\fP (\fBconnection_hdl\fP hdl, std::string const &payload, lib::error_code &ec)"
.br
.RI "Send a pong to a specific connection\&. "
.ti -1c
.RI "void \fBpong\fP (\fBconnection_hdl\fP hdl, std::string const &payload)"
.br
.RI "Send a pong to a specific connection\&. "
.ti -1c
.RI "\fBconnection_ptr\fP \fBget_con_from_hdl\fP (\fBconnection_hdl\fP hdl, lib::error_code &ec)"
.br
.RI "Retrieves a connection_ptr from a connection_hdl (exception free) "
.ti -1c
.RI "\fBconnection_ptr\fP \fBget_con_from_hdl\fP (\fBconnection_hdl\fP hdl)"
.br
.RI "Retrieves a connection_ptr from a connection_hdl (exception version) "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBconnection_ptr\fP \fBcreate_connection\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBalog_type\fP \fBm_alog\fP"
.br
.ti -1c
.RI "\fBelog_type\fP \fBm_elog\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename connection, typename config>
.br
class websocketpp::endpoint< connection, config >"
Creates and manages connections associated with a WebSocket endpoint\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename connection, typename config> typedef transport_con_type::ptr \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::\fBtransport_con_ptr\fP"
\fBType\fP of a shared pointer to the transport component of the connections that this endpoint creates\&. 
.SS "template<typename connection, typename config> typedef \fBtransport_type::transport_con_type\fP \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::\fBtransport_con_type\fP"
\fBType\fP of the transport component of the connections that this endpoint creates 
.SH "Member Function Documentation"
.PP 
.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::clear_access_channels (log::level channels)\fC [inline]\fP"

.PP
Clear Access logging channels\&. Clear the access logger's channel value\&. The value is a number whose interpretation depends on the logging policy in use\&.
.PP
\fBParameters:\fP
.RS 4
\fIchannels\fP The channel value(s) to clear 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::clear_error_channels (log::level channels)\fC [inline]\fP"

.PP
Clear Error logging channels\&. Clear the error logger's channel value\&. The value is a number whose interpretation depends on the logging policy in use\&.
.PP
\fBParameters:\fP
.RS 4
\fIchannels\fP The channel value(s) to clear 
.RE
.PP

.SS "template<typename connection, typename config> \fBalog_type\fP& \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::get_alog ()\fC [inline]\fP"

.PP
Get reference to access logger\&. 
.PP
\fBReturns:\fP
.RS 4
\fBA\fP reference to the access logger 
.RE
.PP

.SS "template<typename connection, typename config> \fBconnection_ptr\fP \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::get_con_from_hdl (\fBconnection_hdl\fP hdl, lib::error_code & ec)\fC [inline]\fP"

.PP
Retrieves a connection_ptr from a connection_hdl (exception free) Converting a weak pointer to shared_ptr is not thread safe because the pointer could be deleted at any time\&.
.PP
NOTE: This method may be called by handler to upgrade its handle to a full connection_ptr\&. That full connection may then be used safely for the remainder of the handler body\&. get_con_from_hdl and the resulting connection_ptr are NOT safe to use outside the handler loop\&.
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The connection handle to translate
.RE
.PP
\fBReturns:\fP
.RS 4
the connection_ptr\&. May be NULL if the handle was invalid\&. 
.RE
.PP

.SS "template<typename connection, typename config> \fBelog_type\fP& \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::get_elog ()\fC [inline]\fP"

.PP
Get reference to error logger\&. 
.PP
\fBReturns:\fP
.RS 4
\fBA\fP reference to the error logger 
.RE
.PP

.SS "template<typename connection, typename config> size_t \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::get_max_http_body_size () const\fC [inline]\fP"

.PP
Get maximum HTTP message body size\&. Get maximum HTTP message body size\&. Maximum message body size determines the point at which the connection will stop reading an HTTP request whose body is too large\&.
.PP
The default is set by the max_http_body_size value from the template config
.PP
\fBSince:\fP
.RS 4
0\&.5\&.0
.RE
.PP
\fBReturns:\fP
.RS 4
The maximum HTTP message body size 
.RE
.PP

.SS "template<typename connection, typename config> size_t \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::get_max_message_size () const\fC [inline]\fP"

.PP
Get default maximum message size\&. Get the default maximum message size that will be used for new connections created by this endpoint\&. The maximum message size determines the point at which the connection will fail a connection with the message_too_big protocol error\&.
.PP
The default is set by the max_message_size value from the template config
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0 
.RE
.PP

.SS "template<typename connection, typename config> std::string \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::get_user_agent () const\fC [inline]\fP"

.PP
Returns the user agent string that this endpoint will use\&. Returns the user agent string that this endpoint will use when creating new connections\&.
.PP
The default value for this version is stored in websocketpp::user_agent
.PP
\fBReturns:\fP
.RS 4
The user agent string\&. 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::interrupt (\fBconnection_hdl\fP hdl, lib::error_code & ec)"
These functions act as adaptors to their counterparts in connection\&. They can produce one additional type of error, the bad_connection error, that indicates that the conversion from connection_hdl to connection_ptr failed due to the connection not existing anymore\&. Each method has a default and an exception free varient\&. 
.SS "template<typename connection, typename config> bool \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::is_server () const\fC [inline]\fP"

.PP
Returns whether or not this endpoint is a server\&. 
.PP
\fBReturns:\fP
.RS 4
Whether or not this endpoint is a server 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::pause_reading (\fBconnection_hdl\fP hdl, lib::error_code & ec)"

.PP
Pause reading of new data (exception free) Signals to the connection to halt reading of new data\&. While reading is paused, the connection will stop reading from its associated socket\&. In turn this will result in TCP based flow control kicking in and slowing data flow from the remote endpoint\&.
.PP
This is useful for applications that push new requests to a queue to be processed by another thread and need a way to signal when their request queue is full without blocking the network processing thread\&.
.PP
Use \fC\fBresume_reading()\fP\fP to resume\&.
.PP
If supported by the transport this is done asynchronously\&. As such reading may not stop until the current read operation completes\&. Typically you can expect to receive no more bytes after initiating a read pause than the size of the read buffer\&.
.PP
If reading is paused for this connection already nothing is changed\&. 
.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::ping (\fBconnection_hdl\fP hdl, std::string const & payload, lib::error_code & ec)"

.PP
Send a ping to a specific connection\&. 
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0-alpha3
.RE
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The connection_hdl of the connection to send to\&. 
.br
\fIpayload\fP The payload string to send\&. 
.br
\fIec\fP \fBA\fP reference to an error code to fill in 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::ping (\fBconnection_hdl\fP hdl, std::string const & payload)"

.PP
Send a ping to a specific connection\&. Exception variant of \fCping\fP
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0-alpha3
.RE
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The connection_hdl of the connection to send to\&. 
.br
\fIpayload\fP The payload string to send\&. 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::pong (\fBconnection_hdl\fP hdl, std::string const & payload, lib::error_code & ec)"

.PP
Send a pong to a specific connection\&. 
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0-alpha3
.RE
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The connection_hdl of the connection to send to\&. 
.br
\fIpayload\fP The payload string to send\&. 
.br
\fIec\fP \fBA\fP reference to an error code to fill in 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::pong (\fBconnection_hdl\fP hdl, std::string const & payload)"

.PP
Send a pong to a specific connection\&. Exception variant of \fCpong\fP
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0-alpha3
.RE
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The connection_hdl of the connection to send to\&. 
.br
\fIpayload\fP The payload string to send\&. 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::resume_reading (\fBconnection_hdl\fP hdl, lib::error_code & ec)"

.PP
Resume reading of new data (exception free) Signals to the connection to resume reading of new data after it was paused by \fC\fBpause_reading()\fP\fP\&.
.PP
If reading is not paused for this connection already nothing is changed\&. 
.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::send (\fBconnection_hdl\fP hdl, std::string const & payload, frame::opcode::value op, lib::error_code & ec)"

.PP
Create a message and add it to the outgoing send queue (exception free) Convenience method to send a message given a payload string and an opcode
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The handle identifying the connection to send via\&. 
.br
\fIpayload\fP The payload string to generated the message with 
.br
\fIop\fP The opcode to generated the message with\&. 
.br
\fIec\fP \fBA\fP code to fill in for errors 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::send (\fBconnection_hdl\fP hdl, std::string const & payload, frame::opcode::value op)"

.PP
Create a message and add it to the outgoing send queue\&. Convenience method to send a message given a payload string and an opcode
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The handle identifying the connection to send via\&. 
.br
\fIpayload\fP The payload string to generated the message with 
.br
\fIop\fP The opcode to generated the message with\&. 
.br
\fIec\fP \fBA\fP code to fill in for errors 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::send_http_response (\fBconnection_hdl\fP hdl, lib::error_code & ec)"

.PP
Send deferred HTTP Response\&. Sends an http response to an HTTP connection that was deferred\&. This will send a complete response including all headers, status line, and body text\&. The connection will be closed afterwards\&.
.PP
Exception free variant
.PP
\fBSince:\fP
.RS 4
0\&.6\&.0
.RE
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The connection to send the response on 
.br
\fIec\fP \fBA\fP status code, zero on success, non-zero otherwise 
.RE
.PP

.SS "template<typename connection , typename config > void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::send_http_response (\fBconnection_hdl\fP hdl)"

.PP
Send deferred HTTP Response (exception free) Sends an http response to an HTTP connection that was deferred\&. This will send a complete response including all headers, status line, and body text\&. The connection will be closed afterwards\&.
.PP
Exception variant
.PP
\fBSince:\fP
.RS 4
0\&.6\&.0
.RE
.PP
\fBParameters:\fP
.RS 4
\fIhdl\fP The connection to send the response on 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::set_access_channels (log::level channels)\fC [inline]\fP"

.PP
Set Access logging channel\&. Set the access logger's channel value\&. The value is a number whose interpretation depends on the logging policy in use\&.
.PP
\fBParameters:\fP
.RS 4
\fIchannels\fP The channel value(s) to set 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::set_close_handshake_timeout (long dur)\fC [inline]\fP"

.PP
Set close handshake timeout\&. Sets the length of time the library will wait after a closing handshake has been initiated before cancelling it\&. This can be used to prevent excessive wait times for outgoing clients or excessive resource usage from broken clients or DoS attacks on servers\&.
.PP
Connections that time out will have their close handlers called with the close_handshake_timeout error code\&.
.PP
The default value is specified via the compile time config value 'timeout_close_handshake'\&. The default value in the core config is 5000ms\&. \fBA\fP value of 0 will disable the timer entirely\&.
.PP
To be effective, the transport you are using must support timers\&. See the documentation for your transport policy for details about its timer support\&.
.PP
\fBParameters:\fP
.RS 4
\fIdur\fP The length of the close handshake timeout in ms 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::set_error_channels (log::level channels)\fC [inline]\fP"

.PP
Set Error logging channel\&. Set the error logger's channel value\&. The value is a number whose interpretation depends on the logging policy in use\&.
.PP
\fBParameters:\fP
.RS 4
\fIchannels\fP The channel value(s) to set 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::set_max_http_body_size (size_t new_value)\fC [inline]\fP"

.PP
Set maximum HTTP message body size\&. Set maximum HTTP message body size\&. Maximum message body size determines the point at which the connection will stop reading an HTTP request whose body is too large\&.
.PP
The default is set by the max_http_body_size value from the template config
.PP
\fBSince:\fP
.RS 4
0\&.5\&.1
.RE
.PP
\fBParameters:\fP
.RS 4
\fInew_value\fP The value to set as the maximum message size\&. 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::set_max_message_size (size_t new_value)\fC [inline]\fP"

.PP
Set default maximum message size\&. Set the default maximum message size that will be used for new connections created by this endpoint\&. Maximum message size determines the point at which the connection will fail a connection with the message_too_big protocol error\&.
.PP
The default is set by the max_message_size value from the template config
.PP
\fBSince:\fP
.RS 4
0\&.3\&.0
.RE
.PP
\fBParameters:\fP
.RS 4
\fInew_value\fP The value to set as the maximum message size\&. 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::set_open_handshake_timeout (long dur)\fC [inline]\fP"

.PP
Set open handshake timeout\&. Sets the length of time the library will wait after an opening handshake has been initiated before cancelling it\&. This can be used to prevent excessive wait times for outgoing clients or excessive resource usage from broken clients or DoS attacks on servers\&.
.PP
Connections that time out will have their fail handlers called with the open_handshake_timeout error code\&.
.PP
The default value is specified via the compile time config value 'timeout_open_handshake'\&. The default value in the core config is 5000ms\&. \fBA\fP value of 0 will disable the timer entirely\&.
.PP
To be effective, the transport you are using must support timers\&. See the documentation for your transport policy for details about its timer support\&.
.PP
\fBParameters:\fP
.RS 4
\fIdur\fP The length of the open handshake timeout in ms 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::set_pong_timeout (long dur)\fC [inline]\fP"

.PP
Set pong timeout\&. Sets the length of time the library will wait for a pong response to a ping\&. This can be used as a keepalive or to detect broken connections\&.
.PP
Pong responses that time out will have the pong timeout handler called\&.
.PP
The default value is specified via the compile time config value 'timeout_pong'\&. The default value in the core config is 5000ms\&. \fBA\fP value of 0 will disable the timer entirely\&.
.PP
To be effective, the transport you are using must support timers\&. See the documentation for your transport policy for details about its timer support\&.
.PP
\fBParameters:\fP
.RS 4
\fIdur\fP The length of the pong timeout in ms 
.RE
.PP

.SS "template<typename connection, typename config> void \fBwebsocketpp::endpoint\fP< \fBconnection\fP, \fBconfig\fP >::set_user_agent (std::string const & ua)\fC [inline]\fP"

.PP
Sets the user agent string that this endpoint will use\&. Sets the identifier that this endpoint will use when creating new connections\&. Changing this value will only affect future connections\&. For client endpoints this will be sent as the 'User-Agent' header in outgoing requests\&. For server endpoints this will be sent in the 'Server' response header\&.
.PP
Setting this value to the empty string will suppress the use of the Server and User-Agent headers\&. This is typically done to hide implementation details for security purposes\&.
.PP
For best results set this before accepting or opening connections\&.
.PP
The default value for this version is stored in websocketpp::user_agent
.PP
This can be overridden on an individual connection basis by setting a custom 'Server' header during the validate handler or 'User-Agent' header on a connection before calling connect()\&.
.PP
\fBParameters:\fP
.RS 4
\fIua\fP The string to set the user agent to\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for AcuteAngleChain from the source code\&.
