\hypertarget{classfc_1_1unhandled__exception}{}\section{fc\+:\+:unhandled\+\_\+exception Class Reference}
\label{classfc_1_1unhandled__exception}\index{fc\+::unhandled\+\_\+exception@{fc\+::unhandled\+\_\+exception}}


re-\/thrown whenever an unhandled exception is caught.

Any exceptions thrown by 3rd party libraries that are not caught get wrapped in an \mbox{\hyperlink{classfc_1_1unhandled__exception}{unhandled\+\_\+exception}} exception.  




{\ttfamily \#include $<$exception.\+hpp$>$}



Inheritance diagram for fc\+:\+:unhandled\+\_\+exception\+:
% FIG 0


Collaboration diagram for fc\+:\+:unhandled\+\_\+exception\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classfc_1_1unhandled__exception_a9b059031419041311998822df4d27ac1}\label{classfc_1_1unhandled__exception_a9b059031419041311998822df4d27ac1}} 
enum {\bfseries code\+\_\+enum} \{ {\bfseries code\+\_\+value} = unhandled\+\_\+exception\+\_\+code
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classfc_1_1unhandled__exception_a1f9c263f19732a3cbe153e98c5b8a9d3}\label{classfc_1_1unhandled__exception_a1f9c263f19732a3cbe153e98c5b8a9d3}} 
{\bfseries unhandled\+\_\+exception} (\mbox{\hyperlink{classfc_1_1log__message}{log\+\_\+message}} \&\&m, std\+::exception\+\_\+ptr e=std\+::current\+\_\+exception())
\item 
\mbox{\Hypertarget{classfc_1_1unhandled__exception_ac274c1f499e26a47b759a8356636b296}\label{classfc_1_1unhandled__exception_ac274c1f499e26a47b759a8356636b296}} 
{\bfseries unhandled\+\_\+exception} (\mbox{\hyperlink{classstd_1_1vector}{log\+\_\+messages}})
\item 
\mbox{\Hypertarget{classfc_1_1unhandled__exception_a819e457fd9bd6f9d941133d6527758d0}\label{classfc_1_1unhandled__exception_a819e457fd9bd6f9d941133d6527758d0}} 
{\bfseries unhandled\+\_\+exception} (const \mbox{\hyperlink{classfc_1_1exception}{exception}} \&)
\item 
\mbox{\Hypertarget{classfc_1_1unhandled__exception_a85c226973a5ba415554b39b5082c1a77}\label{classfc_1_1unhandled__exception_a85c226973a5ba415554b39b5082c1a77}} 
std\+::exception\+\_\+ptr {\bfseries get\+\_\+inner\+\_\+exception} () const
\item 
virtual N\+O\+\_\+\+R\+E\+T\+U\+RN void \mbox{\hyperlink{classfc_1_1unhandled__exception_a8177e0f7154591583154cf4e4ccf0c9e}{dynamic\+\_\+rethrow\+\_\+exception}} () const
\item 
virtual std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classfc_1_1exception}{exception}} $>$ \mbox{\hyperlink{classfc_1_1unhandled__exception_a7946c956fb83ac7167173be9fdcac3e8}{dynamic\+\_\+copy\+\_\+exception}} () const
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
re-\/thrown whenever an unhandled exception is caught.

Any exceptions thrown by 3rd party libraries that are not caught get wrapped in an \mbox{\hyperlink{classfc_1_1unhandled__exception}{unhandled\+\_\+exception}} exception. 

The original exception is captured as a std\+::exception\+\_\+ptr which may be rethrown. The std\+::exception\+\_\+ptr does not propgate across process boundaries. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classfc_1_1unhandled__exception_a7946c956fb83ac7167173be9fdcac3e8}\label{classfc_1_1unhandled__exception_a7946c956fb83ac7167173be9fdcac3e8}} 
\index{fc\+::unhandled\+\_\+exception@{fc\+::unhandled\+\_\+exception}!dynamic\+\_\+copy\+\_\+exception@{dynamic\+\_\+copy\+\_\+exception}}
\index{dynamic\+\_\+copy\+\_\+exception@{dynamic\+\_\+copy\+\_\+exception}!fc\+::unhandled\+\_\+exception@{fc\+::unhandled\+\_\+exception}}
\subsubsection{\texorpdfstring{dynamic\+\_\+copy\+\_\+exception()}{dynamic\_copy\_exception()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classfc_1_1exception}{exception}} $>$ fc\+::unhandled\+\_\+exception\+::dynamic\+\_\+copy\+\_\+exception (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

This is equivalent to\+: 
\begin{DoxyCode}
\textcolor{keywordflow}{try} \{ throwAsDynamic\_exception(); \}
\textcolor{keywordflow}{catch}( ... ) \{ \textcolor{keywordflow}{return} std::current\_exception(); \}
\end{DoxyCode}
 

Reimplemented from \mbox{\hyperlink{classfc_1_1exception_a38ac38d910ba13a339ce5855a51c9127}{fc\+::exception}}.

\mbox{\Hypertarget{classfc_1_1unhandled__exception_a8177e0f7154591583154cf4e4ccf0c9e}\label{classfc_1_1unhandled__exception_a8177e0f7154591583154cf4e4ccf0c9e}} 
\index{fc\+::unhandled\+\_\+exception@{fc\+::unhandled\+\_\+exception}!dynamic\+\_\+rethrow\+\_\+exception@{dynamic\+\_\+rethrow\+\_\+exception}}
\index{dynamic\+\_\+rethrow\+\_\+exception@{dynamic\+\_\+rethrow\+\_\+exception}!fc\+::unhandled\+\_\+exception@{fc\+::unhandled\+\_\+exception}}
\subsubsection{\texorpdfstring{dynamic\+\_\+rethrow\+\_\+exception()}{dynamic\_rethrow\_exception()}}
{\footnotesize\ttfamily N\+O\+\_\+\+R\+E\+T\+U\+RN void fc\+::unhandled\+\_\+exception\+::dynamic\+\_\+rethrow\+\_\+exception (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

Throw this exception as its most derived type.

\begin{DoxyNote}{Note}
does not return.
\end{DoxyNote}
Rethrows the exception restoring the proper type based upon the error code. This is used to propagate exception types across conversions to/from J\+S\+ON 

Reimplemented from \mbox{\hyperlink{classfc_1_1exception_ace951e3b4efa51ea203b0e111f7e99a2}{fc\+::exception}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
libraries/fc/include/fc/exception/\mbox{\hyperlink{exception_8hpp}{exception.\+hpp}}\item 
libraries/fc/src/exception.\+cpp\end{DoxyCompactItemize}
