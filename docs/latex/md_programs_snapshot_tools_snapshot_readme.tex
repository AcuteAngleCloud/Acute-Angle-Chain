
\begin{DoxyItemize}
\item \href{#installation}{\tt Installation}
\begin{DoxyItemize}
\item \href{#docker-installation-and-usage}{\tt Docker}
\item \href{#manual-installation}{\tt Manual}
\end{DoxyItemize}
\item \href{#manual-install-usage}{\tt Usage}
\item \href{#development}{\tt Development}
\item \href{#how-it-works}{\tt How it Works}
\begin{DoxyItemize}
\item \href{#high-level}{\tt High Level}
\item \href{#low-level}{\tt Low Level}
\end{DoxyItemize}
\item \href{#difference-between-testnet-and-mainnet}{\tt Logic differences between mainnet and testnet}
\end{DoxyItemize}

\subsection*{Snapshot Generator}

\subsubsection*{Installation}

\paragraph*{Docker Installation and Usage}

{\itshape Docker installation is a work in progress}

\paragraph*{Manual Installation}

Manual install is recommended for advanced users only.

\paragraph*{Prerequisites}


\begin{DoxyEnumerate}
\item My\+S\+QL
\item Redis-\/\+Server
\item Parity 1.\+7.\+8 (Recommended) or Geth
\item \mbox{\hyperlink{struct_node}{Node}} v0.\+6.\+X
\end{DoxyEnumerate}

\paragraph*{System requirements}


\begin{DoxyEnumerate}
\item 8\+GB Ram Recommended, can make due with 4gb
\item Fast processor recommended
\item S\+SD recommended
\end{DoxyEnumerate}

\label{_snapshot-install-manual-config}%
 \subsubsection*{User Configurable Options}

There are three methods for configuration
\begin{DoxyEnumerate}
\item {\itshape Config File} (recommended)
\item {\itshape User Prompt}, fast if your using default mysql, redis and web3 settings.
\item {\itshape C\+LI} args, will override {\itshape Prompt}
\end{DoxyEnumerate}
\begin{DoxyItemize}
\item {\ttfamily period} (integer) The period to sync to, it will sync to the last block of any given period.
\item {\ttfamily include\+\_\+b1} (true, false) Include block.\+one distribution
\item {\ttfamily fallback} (true, false) Use fallback registration
\item {\ttfamily cache} (true, false) Will cache successful fallbacks, including full paper trail\+: Block number, address, transaction, public key and generated A\+AC key. Can speed up the slow fallback method if running several times.
\item {\ttfamily eth\+\_\+node\+\_\+type} (http, ipc , ws) \mbox{[}default\+: http\mbox{]} Based on testing, I\+PC is recommended for performance
\item {\ttfamily eth\+\_\+node\+\_\+path} (valid host/path) Relative to type as defined above
\item {\ttfamily redis\+\_\+host}
\item {\ttfamily redis\+\_\+port}
\item {\ttfamily mysql\+\_\+db}
\item {\ttfamily mysql\+\_\+user}
\item {\ttfamily mysql\+\_\+pass}
\item {\ttfamily mysql\+\_\+host}
\item {\ttfamily mysql\+\_\+port}
\end{DoxyItemize}

\subsubsection*{Important notes on Parity}

Since Parity v1.\+7.\+8 {\ttfamily -\/-\/warp} is enabled by default, it is {\bfseries absolutely necessary} that you include the flag {\ttfamily -\/-\/no-\/warp}. Warping will skip over historical data that the snapshot requires, tricking web3 into thinking the chain is synced when it is not. Warping is useful for miners, whereas for this situation it is poison and will throw errors/produce an inaccurate snapshot.

\subsubsection*{Manual Install Usage}


\begin{DoxyEnumerate}
\item Configure using one of three available options
\item Import schema into mysql database, found in {\ttfamily /bin/schema.sql} (Sequalize Migrate presently not configured)
\item Install dependencies {\ttfamily npm install}
\item Make sure all systems are go
\begin{DoxyEnumerate}
\item Parity is running with R\+PC ports accessible to application
\item Mysql is running
\item Redis is running ({\ttfamily bash\+: redis-\/server})
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Run script {\ttfamily node snapshot.\+js} from {\bfseries project root}
\item Go outside or to bed.
\end{DoxyEnumerate}

\subsubsection*{Notes}


\begin{DoxyItemize}
\item For your convenience, if web3 is syncing, the app will attempt to start every 30 seconds until it Parity is fully synced
\item If parity crashes, you\textquotesingle{}ll need to start over.
\end{DoxyItemize}

\subsubsection*{How it Works}

\paragraph*{High Level}

The snapshot parameters this software proposes are as follows


\begin{DoxyEnumerate}
\item All data is constrained by block range determined by period (for testnet)
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item A\+AC Balance of an address must be greater-\/than or equal to one A\+AC to be considered for inclusion in Genesis block
\item An A\+AC key must be associated to an account either by registration or fallback
\item Contract addresses are not included in the distribution, public keys derived from contracts have no matching private key as the public key is generated by E\+VM.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item If an ethereum address sent A\+AC E\+R\+C20 tokens to the A\+AC Crowdsale or A\+AC Token contract within the block range of the snapshot, these tokens are allocated to the respective address.
\item If an address has unclaimed A\+AC in the A\+AC Crowdsale contract within block range, these tokens are allocated to the respective address.
\end{DoxyEnumerate}

\label{_snapshot-install-manual-about-lowlevel}%
 \paragraph*{Low Level}

The script employs strict patterns to encourage predictable output, often at the expense of performance. The pattern is {\itshape aggregate -\/ calculate -\/ validate} and closely resembles an E\+TL or {\itshape extract, transform and load} pattern. This decision came after numerous iterations and determining that debugging from state was more efficient than debugging from logs.

Below is the script transposed to plain english.


\begin{DoxyEnumerate}
\item User Configured Parameters are set through one of three methods.
\item Check Connections to My\+S\+QL, Redis and Web3
\item Truncate Databases
\item Generate Period Map
\begin{DoxyEnumerate}
\item Used to define block ranges of periods
\item Determines the block range that the snapshot is based upon
\end{DoxyEnumerate}
\item Set Application State Variables (including user configurations)
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Sync history of token and crowdsale contract.
\begin{DoxyEnumerate}
\item A\+AC Transfers
\item Buys
\item Claims
\item Registrations
\item Reclaimable Transfers
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Compile list of every address that has ever had an A\+AC balance, for each address\+:
\begin{DoxyEnumerate}
\item \mbox{\hyperlink{struct_aggregate}{Aggregate}} relevant txs
\begin{DoxyEnumerate}
\item Claims and Buys, required for Unclaimed Balance Calculation
\item Transfers, all incoming and outgoing tx from address
\item Reclaimable Transfers, every reclaimable has a corresponding transfer \mbox{[}special case\mbox{]}
\item The last registration transaction to occur within defined block range
\end{DoxyEnumerate}
\item Calculate
\begin{DoxyEnumerate}
\item Sum Wallet Balance (sum(transfers\+\_\+in) -\/ sum(transfers\+\_\+out))
\item Calculate Unclaimed Balance
\item Sum Reclaimed Transfer Balances
\item Sum Balances
\item Convert balances from gwei
\end{DoxyEnumerate}
\item Validate
\begin{DoxyEnumerate}
\item Check Wallet Balance
\item Validate A\+AC \mbox{\hyperlink{struct_key}{Key}}, if valid set {\ttfamily registered} to {\ttfamily true}
\item If A\+AC key error, save error to column {\ttfamily register\+\_\+error}
\item If all validated, set {\ttfamily valid} to true.
\end{DoxyEnumerate}
\item Process
\begin{DoxyEnumerate}
\item Save every wallet regardless of validation or balance to {\ttfamily wallets} table
\end{DoxyEnumerate}
\item Fallback {\itshape if {\ttfamily balance is gte 1} and {\ttfamily register\+\_\+error is not null}}
\begin{DoxyEnumerate}
\item Fast Fallback
\begin{DoxyEnumerate}
\item Check database for any outgoing transactions (or keys cache), if found...
\begin{DoxyEnumerate}
\item Query TX and grab Ethereum public key
\item Generate and validate A\+AC \mbox{\hyperlink{struct_key}{Key}}
\item If found and valid, set {\ttfamily valid} to {\ttfamily true} otherwise save error into {\ttfamily fallback\+\_\+error} column
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\end{DoxyEnumerate}

Slow fallback
\begin{DoxyEnumerate}
\item Obtain list of unique addresses with balance gte 1 A\+AC and no A\+AC key and save them as keys in index (redis is used as index)
\item Scan every {\ttfamily from} value in every transaction transaction included in every block between block 0 to end of block range for snapshot for against {\itshape index}
\item If public key is found, execute fallback registration and revalidate entry, update database row appropriately
\end{DoxyEnumerate}

\mbox{\hyperlink{struct_test}{Test}}
\begin{DoxyEnumerate}
\item Daily Totals from DB against daily totals from A\+AC Utility Contract, failure here would not fail the below tests, but would instead result in inaccurate unclaimed balances. Difficult problem to detect without this test.
\item Total Supply, margin of error should be low due to {\itshape dust} from rounding (generally 0.\+00000001\%)
\item Negative Balances, there should be {\bfseries zero} negative balances
\end{DoxyEnumerate}

Output
\begin{DoxyEnumerate}
\item {\bfseries snapshot.\+csv} -\/ comma-\/delimited list of E\+TH addresses, A\+AC keys and Total Balances (user, key, balance respectively)
\begin{DoxyEnumerate}
\item Move all valid entries from db state to a snapshot table, ordered by balance D\+E\+SC.
\item Generate snapshot.\+csv from table
\end{DoxyEnumerate}
\end{DoxyEnumerate}

{\bfseries snapshot.\+json} -\/ Snapshot meta data


\begin{DoxyEnumerate}
\item Snapshot parameters
\item \mbox{\hyperlink{struct_test}{Test}} results
\item General Statistics
\item Generate M\+D5 Checksums
\begin{DoxyEnumerate}
\item From generated {\bfseries snapshot.\+csv} file, useful for debugging and auditing
\item From mysql checksum for every table in database (useful for debugging)
\end{DoxyEnumerate}
\item Pass any other useful state variables into object
\end{DoxyEnumerate}

With the output, you can use the Genesis Generator to create a well-\/formed genesis.\+json file for the A\+AC platform.

\label{_snapshot-development}%
 \subsubsection*{Development}


\begin{DoxyItemize}
\item Do all you work in a separate branch, and submit a pull request. PR\textquotesingle{}s containing changes to snapshot.\+csv will not be accepted without proof of accuracy and detailed information on the anomaly that was solved. ~\newline
-\/ Write your own snapshot script! Use the same high level parameters and see if your generated snapshot.\+csv is the same checksum as the one generated by this script. This script was written as a baseline, where accuracy and ability to extend as a service were priority. Write a faster one.
\item Share your results or ask questions in \href{https://t.me/joinchat/GgxZkRDT3PF5tVFm9m06gw}{\tt Telegram}
\end{DoxyItemize}

\label{_snapshot-networks}%
 \subsubsection*{Difference between Testnet and Mainnet}

There are some differences between testnet and mainnet snapshots that need to be mentioned.


\begin{DoxyItemize}
\item Testnet snapshots will produce accurate output based on period by constraining all blockchain activity to that range. This means that some seemingly superfluous calculations are conducted for testnet
\begin{DoxyItemize}
\item Balances are calculated cumulatively, instead of using {\ttfamily balance\+Of} method in Token Contract
\item A\+AC \mbox{\hyperlink{struct_key}{Key}} Registration is concluded by last registration within the block range.
\end{DoxyItemize}
\item Mainnet simplifies a few things. However, it would be recommended that a cutoff block be enforced to encourage network consensus (primarily for registration transactions)
\begin{DoxyItemize}
\item Balances are not calculated but inferred from state returned by {\ttfamily balance\+Of} function in Token Contract.
\item A\+AC key registration is inferred from state returned by {\ttfamily keys} map in Crowdsale Contract. 
\end{DoxyItemize}
\end{DoxyItemize}