\hypertarget{namespacewebsocketpp_1_1transport}{}\section{websocketpp\+:\+:transport Namespace Reference}
\label{namespacewebsocketpp_1_1transport}\index{websocketpp\+::transport@{websocketpp\+::transport}}


Transport policies provide network connectivity and timers.  


\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespacewebsocketpp_1_1transport_1_1asio}{asio}}
\begin{DoxyCompactList}\small\item\em Transport policy that uses asio. \end{DoxyCompactList}\item 
 \mbox{\hyperlink{namespacewebsocketpp_1_1transport_1_1debug}{debug}}
\item 
 \mbox{\hyperlink{namespacewebsocketpp_1_1transport_1_1error}{error}}
\begin{DoxyCompactList}\small\item\em Generic transport related errors. \end{DoxyCompactList}\item 
 \mbox{\hyperlink{namespacewebsocketpp_1_1transport_1_1iostream}{iostream}}
\begin{DoxyCompactList}\small\item\em Transport policy that uses S\+TL iostream for I/O and does not support timers. \end{DoxyCompactList}\item 
 \mbox{\hyperlink{namespacewebsocketpp_1_1transport_1_1stub}{stub}}
\begin{DoxyCompactList}\small\item\em Stub transport policy that has no input or output. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structwebsocketpp_1_1transport_1_1buffer}{buffer}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{struct_a}{A}} simple utility buffer class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_aeae75e675c1a334b3b33ab7120b480a5}\label{namespacewebsocketpp_1_1transport_aeae75e675c1a334b3b33ab7120b480a5}} 
typedef lib\+::function$<$ void(lib\+::error\+\_\+code const \&)$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_aeae75e675c1a334b3b33ab7120b480a5}{init\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the init hook. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb}\label{namespacewebsocketpp_1_1transport_a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb}} 
typedef lib\+::function$<$ void(lib\+::error\+\_\+code const \&, size\+\_\+t)$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb}{read\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the read method. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_addf5d728159e7aa2bce2a0df947b1560}\label{namespacewebsocketpp_1_1transport_addf5d728159e7aa2bce2a0df947b1560}} 
typedef lib\+::function$<$ void(lib\+::error\+\_\+code const \&)$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_addf5d728159e7aa2bce2a0df947b1560}{write\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the write method. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_a946cc56ff41139f3002149c15fd87bc9}\label{namespacewebsocketpp_1_1transport_a946cc56ff41139f3002149c15fd87bc9}} 
typedef lib\+::function$<$ void(lib\+::error\+\_\+code const \&)$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_a946cc56ff41139f3002149c15fd87bc9}{timer\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the read method. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_af39aff6fc4cb76f7df0d5322b734d156}\label{namespacewebsocketpp_1_1transport_af39aff6fc4cb76f7df0d5322b734d156}} 
typedef lib\+::function$<$ void(lib\+::error\+\_\+code const \&)$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_af39aff6fc4cb76f7df0d5322b734d156}{shutdown\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the shutdown method. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_a8090563b066d7e8e31f7165be18dee51}\label{namespacewebsocketpp_1_1transport_a8090563b066d7e8e31f7165be18dee51}} 
typedef lib\+::function$<$ void()$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_a8090563b066d7e8e31f7165be18dee51}{interrupt\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the interrupt method. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_a6658447b2e10f4c712dd792aad0e0c78}\label{namespacewebsocketpp_1_1transport_a6658447b2e10f4c712dd792aad0e0c78}} 
typedef lib\+::function$<$ void()$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_a6658447b2e10f4c712dd792aad0e0c78}{dispatch\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the dispatch method. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_a9326ea831379368ee47841b2e46cb009}\label{namespacewebsocketpp_1_1transport_a9326ea831379368ee47841b2e46cb009}} 
typedef lib\+::function$<$ void(lib\+::error\+\_\+code const \&)$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_a9326ea831379368ee47841b2e46cb009}{accept\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the accept method. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}\label{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}} 
typedef lib\+::function$<$ void(lib\+::error\+\_\+code const \&)$>$ \mbox{\hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\+\_\+handler}}
\begin{DoxyCompactList}\small\item\em The type and signature of the callback passed to the connect method. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Transport policies provide network connectivity and timers. 

\paragraph*{Connection Interface}

Transport connection components needs to provide\+:

{\bfseries init}~\newline
{\ttfamily void init(init\+\_\+handler handler)}~\newline
Called once shortly after construction to give the policy the chance to perform one time initialization. When complete, the policy must call the supplied {\ttfamily init\+\_\+handler} to continue setup. The handler takes one argument with the error code if any. If an error is returned here setup will fail and the connection will be aborted or terminated.

Web\+Socket++ will call init only once. The transport must call {\ttfamily handler} exactly once.

{\bfseries async\+\_\+read\+\_\+at\+\_\+least}~\newline
{\ttfamily void async\+\_\+read\+\_\+at\+\_\+least(size\+\_\+t num\+\_\+bytes, char $\ast$buf, size\+\_\+t len, read\+\_\+handler handler)}~\newline
start an async read for at least num\+\_\+bytes and at most len bytes into buf. Call handler when done with number of bytes read.

Web\+Socket++ promises to have only one async\+\_\+read\+\_\+at\+\_\+least in flight at a time. The transport must promise to only call read\+\_\+handler once per async read.

{\bfseries async\+\_\+write}~\newline
{\ttfamily void async\+\_\+write(const char$\ast$ buf, size\+\_\+t len, write\+\_\+handler handler)}~\newline
{\ttfamily void async\+\_\+write(\mbox{\hyperlink{classstd_1_1vector}{std\+::vector}}$<$buffer$>$ \& bufs, write\+\_\+handler handler)}~\newline
Start a write of all of the data in buf or bufs. In second case data is written sequentially and in place without copying anything to a temporary location.

Websocket++ promises to have only one async\+\_\+write in flight at a time. The transport must promise to only call the write\+\_\+handler once per async write

{\bfseries set\+\_\+handle}~\newline
{\ttfamily void set\+\_\+handle(connection\+\_\+hdl hdl)}~\newline
Called by Web\+Socket++ to let this policy know the hdl to the connection. It may be stored for later use or ignored/discarded. This handle should be used if the policy adds any connection handlers. Connection handlers must be called with the handle as the first argument so that the handler code knows which connection generated the callback.

{\bfseries set\+\_\+timer}~\newline
{\ttfamily timer\+\_\+ptr set\+\_\+timer(long duration, timer\+\_\+handler handler)}~\newline
Web\+Socket++ uses the timers provided by the transport policy as the implementation of timers is often highly coupled with the implementation of the networking event loops.

Transport timer support is an optional feature. \mbox{\hyperlink{struct_a}{A}} transport method may elect to implement a dummy timer object and have this method return an empty pointer. If so, all timer related features of Web\+Socket++ core will be disabled. This includes many security features designed to prevent denial of service attacks. Use timer-\/free transport policies with caution.

{\bfseries get\+\_\+remote\+\_\+endpoint}~\newline
{\ttfamily std\+::string get\+\_\+remote\+\_\+endpoint()}~\newline
retrieve address of remote endpoint

{\bfseries is\+\_\+secure}~\newline
{\ttfamily void is\+\_\+secure()}~\newline
whether or not the connection to the remote endpoint is secure

{\bfseries dispatch}~\newline
{\ttfamily lib\+::error\+\_\+code dispatch(dispatch\+\_\+handler handler)}\+: invoke handler within the transport\textquotesingle{}s event system if it uses one. Otherwise, this method should simply call {\ttfamily handler} immediately.

{\bfseries async\+\_\+shutdown}~\newline
{\ttfamily void async\+\_\+shutdown(shutdown\+\_\+handler handler)}~\newline
Perform any cleanup necessary (if any). Call {\ttfamily handler} when complete.

\paragraph*{Endpoint Interface}

Transport endpoint components needs to provide\+:

{\bfseries init}~\newline
{\ttfamily lib\+::error\+\_\+code init(transport\+\_\+con\+\_\+ptr tcon)}~\newline
init is called by an endpoint once for each newly created connection. It\textquotesingle{}s purpose is to give the transport policy the chance to perform any transport specific initialization that couldn\textquotesingle{}t be done via the default constructor.

{\bfseries is\+\_\+secure}~\newline
{\ttfamily bool is\+\_\+secure() const}~\newline
\mbox{\hyperlink{struct_test}{Test}} whether the transport component of this endpoint is capable of secure connections.

{\bfseries async\+\_\+connect}~\newline
{\ttfamily void async\+\_\+connect(transport\+\_\+con\+\_\+ptr tcon, uri\+\_\+ptr location, connect\+\_\+handler handler)}~\newline
Initiate a connection to {\ttfamily location} using the given connection {\ttfamily tcon}. {\ttfamily tcon} is a pointer to the transport connection component of the connection. When complete, {\ttfamily handler} should be called with the the connection\textquotesingle{}s {\ttfamily connection\+\_\+hdl} and any error that occurred.

{\bfseries init\+\_\+logging} {\ttfamily void init\+\_\+logging(alog\+\_\+type $\ast$ a, elog\+\_\+type $\ast$ e)}~\newline
Called once after construction to provide pointers to the endpoint\textquotesingle{}s access and error loggers. These may be stored and used to log messages or ignored. 