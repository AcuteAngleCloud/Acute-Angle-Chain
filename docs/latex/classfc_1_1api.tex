\hypertarget{classfc_1_1api}{}\section{fc\+:\+:api$<$ Interface, Transform $>$ Class Template Reference}
\label{classfc_1_1api}\index{fc\+::api$<$ Interface, Transform $>$@{fc\+::api$<$ Interface, Transform $>$}}


Inheritance diagram for fc\+:\+:api$<$ Interface, Transform $>$\+:
% FIG 0


Collaboration diagram for fc\+:\+:api$<$ Interface, Transform $>$\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classfc_1_1api_a11b72f22d33b7b21a6e3768f2f5876a2}\label{classfc_1_1api_a11b72f22d33b7b21a6e3768f2f5876a2}} 
typedef \mbox{\hyperlink{structfc_1_1vtable}{vtable}}$<$ Interface, Transform $>$ {\bfseries vtable\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\\mbox{\hyperlink{classfc_1_1api_aa98da82a201c30c8efd4cad46c878a8b}{api}} (const \mbox{\hyperlink{struct_t}{T}} \&p)
\item 
\mbox{\Hypertarget{classfc_1_1api_a6c20ba1caacd7897d0d0579df8a6ba1a}\label{classfc_1_1api_a6c20ba1caacd7897d0d0579df8a6ba1a}} 
{\bfseries api} (const \mbox{\hyperlink{classfc_1_1api}{api}} \&cpy)
\item 
\mbox{\Hypertarget{classfc_1_1api_a3a8b466e0de4641b7afec6cf846492c5}\label{classfc_1_1api_a3a8b466e0de4641b7afec6cf846492c5}} 
virtual uint64\+\_\+t {\bfseries get\+\_\+handle} () const override
\item 
virtual api\+\_\+id\+\_\+type \mbox{\hyperlink{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}{register\+\_\+api}} (\mbox{\hyperlink{classfc_1_1api__connection}{api\+\_\+connection}} \&conn) const override
\item 
\mbox{\Hypertarget{classfc_1_1api_a5340a6682e5f47f2e0a6761fb126391f}\label{classfc_1_1api_a5340a6682e5f47f2e0a6761fb126391f}} 
\mbox{\hyperlink{structfc_1_1vtable}{vtable\+\_\+type}} \& {\bfseries operator$\ast$} () const
\item 
\mbox{\Hypertarget{classfc_1_1api_a0e0506ac81fd37177b65e4ed9633a360}\label{classfc_1_1api_a0e0506ac81fd37177b65e4ed9633a360}} 
\mbox{\hyperlink{structfc_1_1vtable}{vtable\+\_\+type}} $\ast$ {\bfseries operator-\/$>$} () const
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classfc_1_1api_ad1617b790322c5a8e41f2af06c88c0e6}\label{classfc_1_1api_ad1617b790322c5a8e41f2af06c88c0e6}} 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structfc_1_1vtable}{vtable\+\_\+type}} $>$ {\bfseries \+\_\+vtable}
\item 
\mbox{\Hypertarget{classfc_1_1api_a8f70f7e0e85f5fa0a7ab1f5667f3a88f}\label{classfc_1_1api_a8f70f7e0e85f5fa0a7ab1f5667f3a88f}} 
std\+::shared\+\_\+ptr$<$ fc\+::any $>$ {\bfseries \+\_\+data}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classfc_1_1api_a200d5382cff45db8633a0fc427650338}\label{classfc_1_1api_a200d5382cff45db8633a0fc427650338}} 
bool {\bfseries operator==} (const \mbox{\hyperlink{classfc_1_1api}{api}} \&a, const \mbox{\hyperlink{classfc_1_1api}{api}} \&b)
\item 
\mbox{\Hypertarget{classfc_1_1api_abc65e9cb0c531a4fe0ba91ee2eea6644}\label{classfc_1_1api_abc65e9cb0c531a4fe0ba91ee2eea6644}} 
bool {\bfseries operator!=} (const \mbox{\hyperlink{classfc_1_1api}{api}} \&a, const \mbox{\hyperlink{classfc_1_1api}{api}} \&b)
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classfc_1_1api_aa98da82a201c30c8efd4cad46c878a8b}\label{classfc_1_1api_aa98da82a201c30c8efd4cad46c878a8b}} 
\index{fc\+::api@{fc\+::api}!api@{api}}
\index{api@{api}!fc\+::api@{fc\+::api}}
\subsubsection{\texorpdfstring{api()}{api()}}
{\footnotesize\ttfamily template$<$typename Interface, typename Transform = identity\+\_\+member$>$ \\
template$<$typename T $>$ \\
\mbox{\hyperlink{classfc_1_1api}{fc\+::api}}$<$ Interface, Transform $>$\+::\mbox{\hyperlink{classfc_1_1api}{api}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_t}{T}} \&}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\hyperlink{struct_t}{T}} is anything with pointer semantics 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}\label{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}} 
\index{fc\+::api@{fc\+::api}!register\+\_\+api@{register\+\_\+api}}
\index{register\+\_\+api@{register\+\_\+api}!fc\+::api@{fc\+::api}}
\subsubsection{\texorpdfstring{register\+\_\+api()}{register\_api()}}
{\footnotesize\ttfamily template$<$typename Interface , typename Transform $>$ \\
api\+\_\+id\+\_\+type \mbox{\hyperlink{classfc_1_1api}{fc\+::api}}$<$ Interface, Transform $>$\+::register\+\_\+api (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classfc_1_1api__connection}{api\+\_\+connection}} \&}]{conn }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

It is slightly unclean tight coupling to have this method in the api class. It breaks encapsulation by requiring an api class method to have a pointer to an \mbox{\hyperlink{classfc_1_1api__connection}{api\+\_\+connection}}. The reason this is necessary is we have a goal of being able to call \mbox{\hyperlink{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}{register\+\_\+api()}} on an api$<$\+T$>$ through its base class \mbox{\hyperlink{classfc_1_1api__base}{api\+\_\+base}}. But \mbox{\hyperlink{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}{register\+\_\+api()}} must know the template parameters!

The only reasonable way to achieve the goal is to implement \mbox{\hyperlink{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}{register\+\_\+api()}} as a method in api$<$\+T$>$ (which obviously knows the template parameter \mbox{\hyperlink{struct_t}{T}}), then make the implementation accessible through the base class (by making it a pure virtual method in the base class which is overridden by the subclass\textquotesingle{}s implementation).

It is slightly unclean tight coupling to have this method in the api class. It breaks encapsulation by requiring an api class method to have a pointer to an \mbox{\hyperlink{classfc_1_1binary__api__connection}{binary\+\_\+api\+\_\+connection}}. The reason this is necessary is we have a goal of being able to call \mbox{\hyperlink{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}{register\+\_\+api()}} on an api$<$\+T$>$ through its base class \mbox{\hyperlink{classfc_1_1api__base}{api\+\_\+base}}. But \mbox{\hyperlink{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}{register\+\_\+api()}} must know the template parameters!

The only reasonable way to achieve the goal is to implement \mbox{\hyperlink{classfc_1_1api_a0fc48f47c158c42785ac9a7b21bf8788}{register\+\_\+api()}} as a method in api$<$\+T$>$ (which obviously knows the template parameter \mbox{\hyperlink{struct_t}{T}}), then make the implementation accessible through the base class (by making it a pure virtual method in the base class which is overridden by the subclass\textquotesingle{}s implementation). 

Implements \mbox{\hyperlink{classfc_1_1api__base}{fc\+::api\+\_\+base}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
libraries/fc/include/fc/api.\+hpp\item 
libraries/fc/include/fc/rpc/api\+\_\+connection.\+hpp\item 
libraries/fc/include/fc/rpc/binary\+\_\+api\+\_\+connection.\+hpp\end{DoxyCompactItemize}
