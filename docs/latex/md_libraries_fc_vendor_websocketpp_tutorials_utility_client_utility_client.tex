\subsection*{Chapter 1\+: Initial Setup \& Basics }

Setting up the basic types, opening and closing connections, sending and receiving messages.

\subsubsection*{Step 1}

\mbox{\hyperlink{struct_a}{A}} basic program loop that prompts the user for a command and then processes it. In this tutorial we will modify this program to perform tasks and retrieve data from a remote server over a Web\+Socket connection.

\paragraph*{Build}

{\ttfamily clang++ step1.\+cpp}

\paragraph*{Code so far}

{\itshape note} \mbox{\hyperlink{struct_a}{A}} code snapshot for each step is present next to this tutorial file in the git repository.


\begin{DoxyCode}
\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include <string>}

\textcolor{keywordtype}{int} main() \{
    \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};
    std::string input;

    \textcolor{keywordflow}{while} (!done) \{
        std::cout << \textcolor{stringliteral}{"Enter Command: "};
        std::getline(std::cin, input);

        \textcolor{keywordflow}{if} (input == \textcolor{stringliteral}{"quit"}) \{
            done = \textcolor{keyword}{true};
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input == \textcolor{stringliteral}{"help"}) \{
            std::cout
                << \textcolor{stringliteral}{"\(\backslash\)nCommand List:\(\backslash\)n"}
                << \textcolor{stringliteral}{"help: Display this help text\(\backslash\)n"}
                << \textcolor{stringliteral}{"quit: Exit the program\(\backslash\)n"}
                << std::endl;
        \} \textcolor{keywordflow}{else} \{
            std::cout << \textcolor{stringliteral}{"Unrecognized Command"} << std::endl;
        \}
    \}

    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


\subsubsection*{Step 2}

{\itshape Add Web\+Socket++ includes and set up an endpoint type.}

Web\+Socket++ includes two major object types. The endpoint and the connection. The endpoint creates and launches new connections and maintains default settings for those connections. Endpoints also manage any shared network resources.

The connection stores information specific to each Web\+Socket session.

\begin{quote}
{\bfseries Note\+:} Once a connection is launched, there is no link between the endpoint and the connection. All default settings are copied into the new connection by the endpoint. Changing default settings on an endpoint will only affect future connections. \end{quote}
Connections do not maintain a link back to their associated endpoint. Endpoints do not maintain a list of outstanding connections. If your application needs to iterate over all connections it will need to maintain a list of them itself.

Web\+Socket++ endpoints are built by combining an endpoint role with an endpoint config. There are two different types of endpoint roles, one each for the client and server roles in a Web\+Socket session. This is a client tutorial so we will use the client role {\ttfamily \mbox{\hyperlink{classwebsocketpp_1_1client}{websocketpp\+::client}}} which is provided by the {\ttfamily $<$\mbox{\hyperlink{client_8hpp_source}{websocketpp/client.\+hpp}}$>$} header.

\begin{quote}
\subparagraph*{Terminology\+: Endpoint Config}

Web\+Socket++ endpoints have a group of settings that may be configured at compile time via the {\ttfamily config} template parameter. \mbox{\hyperlink{struct_a}{A}} config is a struct that contains types and static constants that are used to produce an endpoint with specific properties. Depending on which config is being used the endpoint will have different methods available and may have additional third party dependencies. \end{quote}


The endpoint role takes a template parameter called {\ttfamily config} that is used to configure the behavior of endpoint at compile time. For this example we are going to use a default config provided by the library called {\ttfamily asio\+\_\+client}, provided by {\ttfamily $<$\mbox{\hyperlink{asio__no__tls__client_8hpp_source}{websocketpp/config/asio\+\_\+no\+\_\+tls\+\_\+client.\+hpp}}$>$}. This is a client config that uses boost\+::asio to provide network transport and does not support T\+LS based security. Later on we will discuss how to introduce T\+LS based security into a Web\+Socket++ application, more about the other stock configs, and how to build your own custom configs.

Combine a config with an endpoint role to produce a fully configured endpoint. This type will be used frequently so I would recommend a typedef here.

{\ttfamily typedef \mbox{\hyperlink{classwebsocketpp_1_1client}{websocketpp\+::client}}$<$\mbox{\hyperlink{structwebsocketpp_1_1config_1_1asio__client}{websocketpp\+::config\+::asio\+\_\+client}}$>$ client}

\paragraph*{Build}

Adding Web\+Socket++ has added a few dependencies to our program that must be addressed in the build system. Firstly, the Web\+Socket++ and Boost library headers must be in the include search path of your build system. How exactly this is done depends on where you have the Web\+Socket++ headers installed and what build system you are using.

In addition to the new headers, boost\+::asio depends on the {\ttfamily boost\+\_\+system} shared library. This will need to be added (either as a static or dynamic) to the linker. Refer to your build environment documentation for instructions on linking to shared libraries.

{\ttfamily clang++ step2.\+cpp -\/lboost\+\_\+system}

\#\#\#\# Code so far 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <websocketpp/config/asio\_no\_tls\_client.hpp>}
\textcolor{preprocessor}{#include <websocketpp/client.hpp>}

\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include <string>}

\textcolor{keyword}{typedef} \mbox{\hyperlink{classwebsocketpp_1_1client}{websocketpp::client<websocketpp::config::asio\_client>}}
       \mbox{\hyperlink{classwebsocketpp_1_1client}{client}};

\textcolor{keywordtype}{int} main() \{
    \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};
    std::string input;

    \textcolor{keywordflow}{while} (!done) \{
        std::cout << \textcolor{stringliteral}{"Enter Command: "};
        std::getline(std::cin, input);

        \textcolor{keywordflow}{if} (input == \textcolor{stringliteral}{"quit"}) \{
            done = \textcolor{keyword}{true};
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input == \textcolor{stringliteral}{"help"}) \{
            std::cout
                << \textcolor{stringliteral}{"\(\backslash\)nCommand List:\(\backslash\)n"}
                << \textcolor{stringliteral}{"help: Display this help text\(\backslash\)n"}
                << \textcolor{stringliteral}{"quit: Exit the program\(\backslash\)n"}
                << std::endl;
        \} \textcolor{keywordflow}{else} \{
            std::cout << \textcolor{stringliteral}{"Unrecognized Command"} << std::endl;
        \}
    \}

    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


\subsubsection*{Step 3}

{\itshape Create endpoint wrapper object that handles initialization and setting up the background thread.}

In order to process user input while network processing occurs in the background we are going to use a separate thread for the Web\+Socket++ processing loop. This leaves the main thread free to process foreground user input. In order to enable simple R\+A\+II style resource management for our thread and endpoint we will use a wrapper object that configures them both in its constructor.

\begin{quote}
\subparagraph*{Terminology\+: websocketpp\+::lib namespace}

Web\+Socket++ is designed to be used with a C++11 standard library. As this is not universally available in popular build systems the Boost libraries may be used as polyfills for the C++11 standard library in C++98 build environments. The {\ttfamily websocketpp\+::lib} namespace is used by the library and its associated examples to abstract away the distinctions between the two. {\ttfamily websocketpp\+::lib\+::shared\+\_\+ptr} will evaluate to {\ttfamily std\+::shared\+\_\+ptr} in a C++11 environment and {\ttfamily boost\+::shared\+\_\+ptr} otherwise.

This tutorial uses the {\ttfamily websocketpp\+::lib} wrappers because it doesn\textquotesingle{}t know what the build environment of the reader is. For your applications, unless you are interested in similar portability, are free to use the boost or std versions of these types directly.

$>$\mbox{[}T\+O\+DO\+: link to more information about websocketpp\+::lib namespace and C++11 setup\mbox{]} \end{quote}


Within the {\ttfamily \mbox{\hyperlink{classwebsocket__endpoint}{websocket\+\_\+endpoint}}} constructor several things happen\+:

First, we set the endpoint logging behavior to silent by clearing all of the access and error logging channels. \mbox{[}T\+O\+DO\+: link to more information about logging\mbox{]} 
\begin{DoxyCode}
m\_endpoint.clear\_access\_channels(\mbox{\hyperlink{structwebsocketpp_1_1log_1_1alevel_a853aa0b8976e53f3181af3bc398d493e}{websocketpp::log::alevel::all}});
m\_endpoint.clear\_error\_channels(\mbox{\hyperlink{structwebsocketpp_1_1log_1_1elevel_a9b31ff708c221d314f9f4eb3ff2b1ad7}{websocketpp::log::elevel::all}});
\end{DoxyCode}


Next, we initialize the transport system underlying the endpoint and set it to perpetual mode. In perpetual mode the endpoint\textquotesingle{}s processing loop will not exit automatically when it has no connections. This is important because we want this endpoint to remain active while our application is running and process requests for new Web\+Socket connections on demand as we need them. Both of these methods are specific to the asio transport. They will not be necessary or present in endpoints that use a non-\/asio config. 
\begin{DoxyCode}
m\_endpoint.init\_asio();
m\_endpoint.start\_perpetual();
\end{DoxyCode}


Finally, we launch a thread to run the {\ttfamily run} method of our client endpoint. While the endpoint is running it will process connection tasks (read and deliver incoming messages, frame and send outgoing messages, etc). Because it is running in perpetual mode, when there are no connections active it will wait for a new connection. 
\begin{DoxyCode}
m\_thread.reset(\textcolor{keyword}{new} websocketpp::lib::thread(&client::run, &m\_endpoint));
\end{DoxyCode}


\paragraph*{Build}

Now that our client endpoint template is actually instantiated a few more linker dependencies will show up. In particular, Web\+Socket clients require a cryptographically secure random number generator. Web\+Socket++ is able to use either {\ttfamily boost\+\_\+random} or the C++11 standard library $<$random$>$ for this purpose. Because this example also uses threads, if we do not have C++11 std\+::thread available we will need to include {\ttfamily boost\+\_\+thread}.

\subparagraph*{Clang (C++98 \& boost)}

{\ttfamily clang++ step3.\+cpp -\/lboost\+\_\+system -\/lboost\+\_\+random -\/lboost\+\_\+thread}

\subparagraph*{Clang (C++11)}

{\ttfamily clang++ -\/std=c++0x -\/stdlib=libc++ step3.\+cpp -\/lboost\+\_\+system -\/\+D\+\_\+\+W\+E\+B\+S\+O\+C\+K\+E\+T\+P\+P\+\_\+\+C\+P\+P11\+\_\+\+S\+T\+L\+\_\+}

\subparagraph*{G++ (C++98 \& Boost)}

{\ttfamily g++ step3.\+cpp -\/lboost\+\_\+system -\/lboost\+\_\+random -\/lboost\+\_\+thread}

\subparagraph*{G++ v4.\+6+ (C++11)}

{\ttfamily g++ -\/std=c++0x step3.\+cpp -\/lboost\+\_\+system -\/\+D\+\_\+\+W\+E\+B\+S\+O\+C\+K\+E\+T\+P\+P\+\_\+\+C\+P\+P11\+\_\+\+S\+T\+L\+\_\+}

\paragraph*{Code so far}


\begin{DoxyCode}
\textcolor{preprocessor}{#include <websocketpp/config/asio\_no\_tls\_client.hpp>}
\textcolor{preprocessor}{#include <websocketpp/client.hpp>}

\textcolor{preprocessor}{#include <websocketpp/common/thread.hpp>}
\textcolor{preprocessor}{#include <websocketpp/common/memory.hpp>}

\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include <string>}

\textcolor{keyword}{typedef} \mbox{\hyperlink{classwebsocketpp_1_1client}{websocketpp::client<websocketpp::config::asio\_client>}}
       \mbox{\hyperlink{classwebsocketpp_1_1client}{client}};

\textcolor{keyword}{class }\mbox{\hyperlink{classwebsocket__endpoint}{websocket\_endpoint}} \{
\textcolor{keyword}{public}:
    \mbox{\hyperlink{classwebsocket__endpoint}{websocket\_endpoint}} () \{
        m\_endpoint.\mbox{\hyperlink{classwebsocketpp_1_1endpoint_a3fe357b3c6434273a9965eb52902575d}{clear\_access\_channels}}(
      \mbox{\hyperlink{structwebsocketpp_1_1log_1_1alevel_a853aa0b8976e53f3181af3bc398d493e}{websocketpp::log::alevel::all}});
        m\_endpoint.\mbox{\hyperlink{classwebsocketpp_1_1endpoint_a8cefa4fc37c0df4eb6ed0bcf04bb0da5}{clear\_error\_channels}}(
      \mbox{\hyperlink{structwebsocketpp_1_1log_1_1elevel_a9b31ff708c221d314f9f4eb3ff2b1ad7}{websocketpp::log::elevel::all}});

        m\_endpoint.init\_asio();
        m\_endpoint.start\_perpetual();

        m\_thread.reset(\textcolor{keyword}{new} websocketpp::lib::thread(&client::run, &m\_endpoint));
    \}
\textcolor{keyword}{private}:
    \mbox{\hyperlink{classwebsocketpp_1_1client}{client}} m\_endpoint;
    websocketpp::lib::shared\_ptr<websocketpp::lib::thread> m\_thread;
\};

\textcolor{keywordtype}{int} main() \{
    \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};
    std::string input;
    \mbox{\hyperlink{classwebsocket__endpoint}{websocket\_endpoint}} endpoint;

    \textcolor{keywordflow}{while} (!done) \{
        std::cout << \textcolor{stringliteral}{"Enter Command: "};
        std::getline(std::cin, input);

        \textcolor{keywordflow}{if} (input == \textcolor{stringliteral}{"quit"}) \{
            done = \textcolor{keyword}{true};
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input == \textcolor{stringliteral}{"help"}) \{
            std::cout
                << \textcolor{stringliteral}{"\(\backslash\)nCommand List:\(\backslash\)n"}
                << \textcolor{stringliteral}{"help: Display this help text\(\backslash\)n"}
                << \textcolor{stringliteral}{"quit: Exit the program\(\backslash\)n"}
                << std::endl;
        \} \textcolor{keywordflow}{else} \{
            std::cout << \textcolor{stringliteral}{"Unrecognized Command"} << std::endl;
        \}
    \}

    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


\subsubsection*{Step 4}

{\itshape Opening Web\+Socket connections}

This step adds two new commands to utility\+\_\+client. The ability to open a new connection and the ability to view information about a previously opened connection. Every connection that gets opened will be assigned an integer connection id that the user of the program can use to interact with that connection.

\paragraph*{New Connection Metadata Object}

In order to track information about each connection a {\ttfamily \mbox{\hyperlink{classconnection__metadata}{connection\+\_\+metadata}}} object is defined. This object stores the numeric connection id and a number of fields that will be filled in as the connection is processed. Initially this includes the state of the connection (opening, open, failed, closed, etc), the original U\+RI connected to, an identifying value from the server, and a description of the reason for connection failure/closure. Future steps will add more information to this metadata object.

\paragraph*{Update {\ttfamily \mbox{\hyperlink{classwebsocket__endpoint}{websocket\+\_\+endpoint}}}}

The {\ttfamily \mbox{\hyperlink{classwebsocket__endpoint}{websocket\+\_\+endpoint}}} object has gained some new data members and methods. It now tracks a mapping between connection I\+Ds and their associated metadata as well as the next sequential ID number to hand out. The {\ttfamily connect()} method initiates a new connection. The {\ttfamily get\+\_\+metadata} method retrieves metadata given an ID.

\paragraph*{The connect method}

\mbox{\hyperlink{struct_a}{A}} new Web\+Socket connection is initiated via a three step process. First, a connection request is created by {\ttfamily endpoint\+::get\+\_\+connection(uri)}. Next, the connection request is configured. Lastly, the connection request is submitted back to the endpoint via {\ttfamily endpoint\+::connect()} which adds it to the queue of new connections to make.

\begin{quote}
\subparagraph*{Terminology {\ttfamily connection\+\_\+ptr}}

Web\+Socket++ keeps track of connection related resources using a reference counted shared pointer. The type of this pointer is {\ttfamily endpoint\+::connection\+\_\+ptr}. \mbox{\hyperlink{struct_a}{A}} {\ttfamily connection\+\_\+ptr} allows direct access to information about the connection and allows changing connection settings. Because of this direct access and their internal resource management role within the library it is not safe for end applications to use {\ttfamily connection\+\_\+ptr} except in the specific circumstances detailed below.

{\bfseries When is it safe to use {\ttfamily connection\+\_\+ptr}?}
\begin{DoxyItemize}
\item After {\ttfamily endpoint\+::get\+\_\+connection(...)} and before {\ttfamily endpoint\+::connect()}\+: {\ttfamily get\+\_\+connection} returns a {\ttfamily connection\+\_\+ptr}. It is safe to use this pointer to configure your new connection. Once you submit the connection to {\ttfamily connect} you may no longer use the {\ttfamily connection\+\_\+ptr} and should discard it immediately for optimal memory management.
\item During a handler\+: Web\+Socket++ allows you to register hooks / callbacks / event handlers for specific events that happen during a connection\textquotesingle{}s lifetime. During the invocation of one of these handlers the library guarantees that it is safe to use a {\ttfamily connection\+\_\+ptr} for the connection associated with the currently running handler. 
\end{DoxyItemize}\end{quote}


\begin{quote}
\subparagraph*{Terminology {\ttfamily connection\+\_\+hdl}}

Because of the limited thread safety of the {\ttfamily connection\+\_\+ptr} the library also provides a more flexible connection identifier, the {\ttfamily connection\+\_\+hdl}. The {\ttfamily connection\+\_\+hdl} has type {\ttfamily \mbox{\hyperlink{namespacewebsocketpp_a6b3d26a10ee7229b84b776786332631d}{websocketpp\+::connection\+\_\+hdl}}} and it is defined in {\ttfamily $<$\mbox{\hyperlink{connection__hdl_8hpp_source}{websocketpp/common/connection\+\_\+hdl.\+hpp}}$>$}. Note that unlike {\ttfamily connection\+\_\+ptr} this is not dependent on the type or config of the endpoint. Code that simply stores or transmits {\ttfamily connection\+\_\+hdl} but does not use them can include only the header above and can treat its hdls like values.

Connection handles are not used directly. They are used by endpoint methods to identify the target of the desired action. For example, the endpoint method that sends a new message will take as a parameter the hdl of the connection to send the message to.

{\bfseries When is it safe to use {\ttfamily connection\+\_\+hdl}?} {\ttfamily connection\+\_\+hdl}s may be used at any time from any thread. They may be copied and stored in containers. Deleting a hdl will not affect the connection in any way. Handles may be upgraded to a {\ttfamily connection\+\_\+ptr} during a handler call by using {\ttfamily endpoint\+::get\+\_\+con\+\_\+from\+\_\+hdl()}. The resulting {\ttfamily connection\+\_\+ptr} is safe to use for the duration of that handler invocation.

$\ast$$\ast${\ttfamily connection\+\_\+hdl} F\+A\+Qs$\ast$$\ast$
\begin{DoxyItemize}
\item {\ttfamily connection\+\_\+hdl}s are guaranteed to be unique within a program. Multiple endpoints in a single program will always create connections with unique handles.
\item Using a {\ttfamily connection\+\_\+hdl} with a different endpoint than the one that created its associated connection will result in undefined behavior.
\item Using a {\ttfamily connection\+\_\+hdl} whose associated connection has been closed or deleted is safe. The endpoint will return a specific error saying the operation couldn\textquotesingle{}t be completed because the associated connection doesn\textquotesingle{}t exist. \mbox{[}T\+O\+DO\+: more here? link to a connection\+\_\+hdl F\+AQ elsewhere?\mbox{]} 
\end{DoxyItemize}\end{quote}


{\ttfamily websocket\+\_\+endpoint\+::connect()} begins by calling {\ttfamily endpoint\+::get\+\_\+connection()} using a uri passed as a parameter. Additionally, an error output value is passed to capture any errors that might occur during. If an error does occur an error notice is printed along with a descriptive message and the -\/1 / \textquotesingle{}invalid\textquotesingle{} value is returned as the new ID.

\begin{quote}
\subparagraph*{Terminology\+: {\ttfamily error handling\+: exceptions vs error\+\_\+code}}

Web\+Socket++ uses the error code system defined by the C++11 {\ttfamily $<$system\+\_\+error$>$} library. It can optionally fall back to a similar system provided by the Boost libraries. All user facing endpoint methods that can fail take an {\ttfamily error\+\_\+code} in an output parameter and store the error that occured there before returning. An empty/default constructed value is returned in the case of success.

{\bfseries Exception throwing varients} All user facing endpoint methods that take and use an {\ttfamily error\+\_\+code} parameter have a version that throws an exception instead. These methods are identical in function and signature except for the lack of the final ec parameter. The type of the exception thrown is {\ttfamily \mbox{\hyperlink{classwebsocketpp_1_1exception}{websocketpp\+::exception}}}. This type derives from {\ttfamily std\+::exception} so it can be caught by catch blocks grabbing generic {\ttfamily std\+::exception}s. The {\ttfamily websocketpp\+::exception\+::code()} method may be used to extract the machine readable {\ttfamily error\+\_\+code} value from an exception.

For clarity about error handling the utility\+\_\+client example uses exclusively the exception free varients of these methods. Your application may choose to use either. \end{quote}


If connection creation succeeds, the next sequential connection ID is generated and a {\ttfamily \mbox{\hyperlink{classconnection__metadata}{connection\+\_\+metadata}}} object is inserted into the connection list under that ID. Initially the metadata object stores the connection ID, the {\ttfamily connection\+\_\+hdl}, and the U\+RI the connection was opened to.


\begin{DoxyCode}
\textcolor{keywordtype}{int} new\_id = m\_next\_id++;
metadata\_ptr metadata(\textcolor{keyword}{new} \mbox{\hyperlink{classconnection__metadata}{connection\_metadata}}(new\_id, con->get\_handle(), uri));
m\_connection\_list[new\_id] = metadata;
\end{DoxyCode}


Next, the connection request is configured. For this step the only configuration we will do is setting up a few default handlers. Later on we will return and demonstrate some more detailed configuration that can happen here (setting user agents, origin, proxies, custom headers, subprotocols, etc).

\begin{quote}
\subparagraph*{Terminology\+: Registering handlers}

Web\+Socket++ provides a number of execution points where you can register to have a handler run. Which of these points are available to your endpoint will depend on its config. T\+LS handlers will not exist on non-\/\+T\+LS endpoints for example. \mbox{\hyperlink{struct_a}{A}} complete list of handlers can be found at \href{http://www.zaphoyd.com/websocketpp/manual/reference/handler-list}{\tt http\+://www.\+zaphoyd.\+com/websocketpp/manual/reference/handler-\/list}.

Handlers can be registered at the endpoint level and at the connection level. Endpoint handlers are copied into new connections as they are created. Changing an endpoint handler will affect only future connections. Handlers registered at the connection level will be bound to that specific connection only.

The signature of handler binding methods is the same for endpoints and connections. The format is\+: {\ttfamily set\+\_\+$\ast$\+\_\+handler(...)}. Where $\ast$ is the name of the handler. For example, {\ttfamily set\+\_\+open\+\_\+handler(...)} will set the handler to be called when a new connection is open. {\ttfamily set\+\_\+fail\+\_\+handler(...)} will set the handler to be called when a connection fails to connect.

All handlers take one argument, a callable type that can be converted to a {\ttfamily std\+::function} with the correct count and type of arguments. You can pass free functions, functors, and Lambdas with matching argument lists as handlers. In addition, you can use {\ttfamily std\+::bind} (or {\ttfamily boost\+::bind}) to register functions with non-\/matching argument lists. This is useful for passing additional parameters not present in the handler signature or member functions that need to carry a \textquotesingle{}this\textquotesingle{} pointer.

The function signature of each handler can be looked up in the list above in the manual. In general, all handlers include the {\ttfamily connection\+\_\+hdl} identifying which connection this even is associated with as the first parameter. Some handlers (such as the message handler) include additional parameters. Most handlers have a void return value but some ({\ttfamily validate}, {\ttfamily ping}, {\ttfamily tls\+\_\+init}) do not. The specific meanings of the return values are documented in the handler list linked above. \end{quote}


{\ttfamily utility\+\_\+client} registers an open and a fail handler. We will use these to track whether each connection was successfully opened or failed. If it successfully opens, we will gather some information from the opening handshake and store it with our connection metadata.

In this example we are going to set connection specific handlers that are bound directly to the metadata object associated with our connection. This allows us to avoid performing a lookup in each handler to find the metadata object we plan to update which is a bit more efficient.

Lets look at the parameters being sent to bind in detail\+:


\begin{DoxyCode}
con->set\_open\_handler(websocketpp::lib::bind(
    &connection\_metadata::on\_open,
    metadata,
    &m\_endpoint,
    websocketpp::lib::placeholders::\_1
));
\end{DoxyCode}


{\ttfamily \&connection\+\_\+metadata\+::on\+\_\+open} is the address of the {\ttfamily on\+\_\+open} member function of the {\ttfamily \mbox{\hyperlink{classconnection__metadata}{connection\+\_\+metadata}}} class. {\ttfamily metadata\+\_\+ptr} is a pointer to the {\ttfamily \mbox{\hyperlink{classconnection__metadata}{connection\+\_\+metadata}}} object associated with this class. It will be used as the object on which the {\ttfamily on\+\_\+open} member function will be called. {\ttfamily \&m\+\_\+endpoint} is the address of the endpoint in use. This parameter will be passed as-\/is to the {\ttfamily on\+\_\+open} method. Lastly, {\ttfamily websocketpp\+::lib\+::placeholders\+::\+\_\+1} is a placeholder indicating that the bound function should take one additional argument to be filled in at a later time. Web\+Socket++ will fill in this placeholder with the {\ttfamily connection\+\_\+hdl} when it invokes the handler.

Finally, we call {\ttfamily endpoint\+::connect()} on our configured connection request and return the new connection ID.

\paragraph*{Handler Member Functions}

The open handler we registered, {\ttfamily connection\+\_\+metadata\+::on\+\_\+open}, sets the status metadata field to \char`\"{}\+Open\char`\"{} and retrieves the value of the \char`\"{}\+Server\char`\"{} header from the remote endpoint\textquotesingle{}s H\+T\+TP response and stores it in the metadata object. Servers often set an identifying string in this header.

The fail handler we registered, {\ttfamily connection\+\_\+metadata\+::on\+\_\+fail}, sets the status metadata field to \char`\"{}\+Failed\char`\"{}, the server field similarly to {\ttfamily on\+\_\+open}, and retrieves the error code describing why the connection failed. The human readable message associated with that error code is saved to the metadata object.

\paragraph*{New Commands}

\mbox{\hyperlink{struct_two}{Two}} new commands have been set up. \char`\"{}connect \mbox{[}uri\mbox{]}\char`\"{} will pass the U\+RI to the {\ttfamily \mbox{\hyperlink{classwebsocket__endpoint}{websocket\+\_\+endpoint}}} connect method and report an error or the connection ID of the new connection. \char`\"{}show \mbox{[}connection id\mbox{]}\char`\"{} will retrieve and print out the metadata associated with that connection. The help text has been updated accordingly.


\begin{DoxyCode}
\} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.substr(0,7) == \textcolor{stringliteral}{"connect"}) \{
    \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = endpoint.connect(input.substr(8));
    \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} != -1) \{
        std::cout << \textcolor{stringliteral}{"> Created connection with id "} << \textcolor{keywordtype}{id} << std::endl;
    \}
\} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.substr(0,4) == \textcolor{stringliteral}{"show"}) \{
    \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = atoi(input.substr(5).c\_str());

    connection\_metadata::ptr metadata = endpoint.get\_metadata(\textcolor{keywordtype}{id});
    \textcolor{keywordflow}{if} (metadata) \{
        std::cout << *metadata << std::endl;
    \} \textcolor{keywordflow}{else} \{
        std::cout << \textcolor{stringliteral}{"> Unknown connection id "} << \textcolor{keywordtype}{id} << std::endl;
    \}
\}
\end{DoxyCode}


\paragraph*{Build}

There are no changes to the build instructions from step 3

\paragraph*{Run}


\begin{DoxyCode}
Enter Command: connect not a websocket uri
> Connect initialization error: invalid uri
Enter Command: show 0
> Unknown connection id 0
Enter Command: connect ws://echo.websocket.org
> Created connection with id 0
Enter Command: show 0
> URI: ws://echo.websocket.org
> Status: Open
> Remote Server: Kaazing Gateway
> Error/close reason: N/A
Enter Command: connect ws://wikipedia.org
> Created connection with id 1
Enter Command: show 1
> URI: ws://wikipedia.org
> Status: Failed
> Remote Server: Apache
> Error/close reason: Invalid HTTP status.
\end{DoxyCode}


\paragraph*{Code so far}


\begin{DoxyCode}
\textcolor{preprocessor}{#include <websocketpp/config/asio\_no\_tls\_client.hpp>}
\textcolor{preprocessor}{#include <websocketpp/client.hpp>}

\textcolor{preprocessor}{#include <websocketpp/common/thread.hpp>}
\textcolor{preprocessor}{#include <websocketpp/common/memory.hpp>}

\textcolor{preprocessor}{#include <cstdlib>}
\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include <map>}
\textcolor{preprocessor}{#include <string>}
\textcolor{preprocessor}{#include <sstream>}

\textcolor{keyword}{typedef} \mbox{\hyperlink{classwebsocketpp_1_1client}{websocketpp::client<websocketpp::config::asio\_client>}}
       \mbox{\hyperlink{classwebsocketpp_1_1client}{client}};

\textcolor{keyword}{class }\mbox{\hyperlink{classconnection__metadata}{connection\_metadata}} \{
\textcolor{keyword}{public}:
    \textcolor{keyword}{typedef} websocketpp::lib::shared\_ptr<connection\_metadata> ptr;

    \mbox{\hyperlink{classconnection__metadata}{connection\_metadata}}(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \mbox{\hyperlink{namespacewebsocketpp_a6b3d26a10ee7229b84b776786332631d}{websocketpp::connection\_hdl}} 
      hdl, std::string uri)
      : m\_id(id)
      , m\_hdl(hdl)
      , m\_status(\textcolor{stringliteral}{"Connecting"})
      , m\_uri(uri)
      , m\_server(\textcolor{stringliteral}{"N/A"})
    \{\}

    \textcolor{keywordtype}{void} on\_open(\mbox{\hyperlink{classwebsocketpp_1_1client}{client}} * c, \mbox{\hyperlink{namespacewebsocketpp_a6b3d26a10ee7229b84b776786332631d}{websocketpp::connection\_hdl}} hdl) \{
        m\_status = \textcolor{stringliteral}{"Open"};

        \mbox{\hyperlink{classwebsocketpp_1_1client_a2e187bbb2beac676bbfbc2e8065de83e}{client::connection\_ptr}} con = c->get\_con\_from\_hdl(hdl);
        m\_server = con->get\_response\_header(\textcolor{stringliteral}{"Server"});
    \}

    \textcolor{keywordtype}{void} on\_fail(\mbox{\hyperlink{classwebsocketpp_1_1client}{client}} * c, \mbox{\hyperlink{namespacewebsocketpp_a6b3d26a10ee7229b84b776786332631d}{websocketpp::connection\_hdl}} hdl) \{
        m\_status = \textcolor{stringliteral}{"Failed"};

        \mbox{\hyperlink{classwebsocketpp_1_1client_a2e187bbb2beac676bbfbc2e8065de83e}{client::connection\_ptr}} con = c->get\_con\_from\_hdl(hdl);
        m\_server = con->get\_response\_header(\textcolor{stringliteral}{"Server"});
        m\_error\_reason = con->get\_ec().message();
    \}

    \textcolor{keyword}{friend} std::ostream & operator<< (std::ostream & out, \mbox{\hyperlink{classconnection__metadata}{connection\_metadata}} \textcolor{keyword}{const} & 
      data);
\textcolor{keyword}{private}:
    \textcolor{keywordtype}{int} m\_id;
    \mbox{\hyperlink{namespacewebsocketpp_a6b3d26a10ee7229b84b776786332631d}{websocketpp::connection\_hdl}} m\_hdl;
    std::string m\_status;
    std::string m\_uri;
    std::string m\_server;
    std::string m\_error\_reason;
\};

std::ostream & \mbox{\hyperlink{group__console_cppapi_ga9573031ece85c11fb0baeaab3a36eb73}{operator<< }}(std::ostream & out, \mbox{\hyperlink{classconnection__metadata}{connection\_metadata}} \textcolor{keyword}{const} & 
      data) \{
    out << \textcolor{stringliteral}{"> URI: "} << data.m\_uri << \textcolor{stringliteral}{"\(\backslash\)n"}
        << \textcolor{stringliteral}{"> Status: "} << data.m\_status << \textcolor{stringliteral}{"\(\backslash\)n"}
        << \textcolor{stringliteral}{"> Remote Server: "} << (data.m\_server.empty() ? \textcolor{stringliteral}{"None Specified"} : data.m\_server) << \textcolor{stringliteral}{"\(\backslash\)n"}
        << \textcolor{stringliteral}{"> Error/close reason: "} << (data.m\_error\_reason.empty() ? \textcolor{stringliteral}{"N/A"} : data.m\_error\_reason);

    \textcolor{keywordflow}{return} out;
\}

\textcolor{keyword}{class }\mbox{\hyperlink{classwebsocket__endpoint}{websocket\_endpoint}} \{
\textcolor{keyword}{public}:
    \mbox{\hyperlink{classwebsocket__endpoint}{websocket\_endpoint}} () : m\_next\_id(0) \{
        m\_endpoint.\mbox{\hyperlink{classwebsocketpp_1_1endpoint_a3fe357b3c6434273a9965eb52902575d}{clear\_access\_channels}}(
      \mbox{\hyperlink{structwebsocketpp_1_1log_1_1alevel_a853aa0b8976e53f3181af3bc398d493e}{websocketpp::log::alevel::all}});
        m\_endpoint.\mbox{\hyperlink{classwebsocketpp_1_1endpoint_a8cefa4fc37c0df4eb6ed0bcf04bb0da5}{clear\_error\_channels}}(
      \mbox{\hyperlink{structwebsocketpp_1_1log_1_1elevel_a9b31ff708c221d314f9f4eb3ff2b1ad7}{websocketpp::log::elevel::all}});

        m\_endpoint.init\_asio();
        m\_endpoint.start\_perpetual();

        m\_thread.reset(\textcolor{keyword}{new} websocketpp::lib::thread(&client::run, &m\_endpoint));
    \}

    \textcolor{keywordtype}{int} connect(std::string \textcolor{keyword}{const} & uri) \{
        websocketpp::lib::error\_code ec;

        \mbox{\hyperlink{classwebsocketpp_1_1client_a2e187bbb2beac676bbfbc2e8065de83e}{client::connection\_ptr}} con = m\_endpoint.
      \mbox{\hyperlink{classwebsocketpp_1_1client_aa95cec974921e32bc37a61c683ae240d}{get\_connection}}(uri, ec);

        \textcolor{keywordflow}{if} (ec) \{
            std::cout << \textcolor{stringliteral}{"> Connect initialization error: "} << ec.message() << std::endl;
            \textcolor{keywordflow}{return} -1;
        \}

        \textcolor{keywordtype}{int} new\_id = m\_next\_id++;
        connection\_metadata::ptr metadata\_ptr(\textcolor{keyword}{new} \mbox{\hyperlink{classconnection__metadata}{connection\_metadata}}(new\_id, con->
      get\_handle(), uri));
        m\_connection\_list[new\_id] = metadata\_ptr;

        con->set\_open\_handler(websocketpp::lib::bind(
            &connection\_metadata::on\_open,
            metadata\_ptr,
            &m\_endpoint,
            websocketpp::lib::placeholders::\_1
        ));
        con->set\_fail\_handler(websocketpp::lib::bind(
            &connection\_metadata::on\_fail,
            metadata\_ptr,
            &m\_endpoint,
            websocketpp::lib::placeholders::\_1
        ));

        m\_endpoint.\mbox{\hyperlink{classwebsocketpp_1_1client_a818c30343180123bf1fee6dc21524bae}{connect}}(con);

        \textcolor{keywordflow}{return} new\_id;
    \}

    connection\_metadata::ptr get\_metadata(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id})\textcolor{keyword}{ const }\{
        con\_list::const\_iterator metadata\_it = m\_connection\_list.find(\textcolor{keywordtype}{id});
        \textcolor{keywordflow}{if} (metadata\_it == m\_connection\_list.end()) \{
            \textcolor{keywordflow}{return} connection\_metadata::ptr();
        \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{return} metadata\_it->second;
        \}
    \}
\textcolor{keyword}{private}:
    \textcolor{keyword}{typedef} \mbox{\hyperlink{classstd_1_1map}{std::map<int,connection\_metadata::ptr>}} con\_list;

    \mbox{\hyperlink{classwebsocketpp_1_1client}{client}} m\_endpoint;
    websocketpp::lib::shared\_ptr<websocketpp::lib::thread> m\_thread;

    con\_list m\_connection\_list;
    \textcolor{keywordtype}{int} m\_next\_id;
\};

\textcolor{keywordtype}{int} main() \{
    \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};
    std::string input;
    \mbox{\hyperlink{classwebsocket__endpoint}{websocket\_endpoint}} endpoint;

    \textcolor{keywordflow}{while} (!done) \{
        std::cout << \textcolor{stringliteral}{"Enter Command: "};
        std::getline(std::cin, input);

        \textcolor{keywordflow}{if} (input == \textcolor{stringliteral}{"quit"}) \{
            done = \textcolor{keyword}{true};
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input == \textcolor{stringliteral}{"help"}) \{
            std::cout
                << \textcolor{stringliteral}{"\(\backslash\)nCommand List:\(\backslash\)n"}
                << \textcolor{stringliteral}{"connect <ws uri>\(\backslash\)n"}
                << \textcolor{stringliteral}{"show <connection id>\(\backslash\)n"}
                << \textcolor{stringliteral}{"help: Display this help text\(\backslash\)n"}
                << \textcolor{stringliteral}{"quit: Exit the program\(\backslash\)n"}
                << std::endl;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.substr(0,7) == \textcolor{stringliteral}{"connect"}) \{
            \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = endpoint.connect(input.substr(8));
            \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} != -1) \{
                std::cout << \textcolor{stringliteral}{"> Created connection with id "} << \textcolor{keywordtype}{id} << std::endl;
            \}
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.substr(0,4) == \textcolor{stringliteral}{"show"}) \{
            \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = atoi(input.substr(5).c\_str());

            connection\_metadata::ptr metadata = endpoint.get\_metadata(\textcolor{keywordtype}{id});
            \textcolor{keywordflow}{if} (metadata) \{
                std::cout << *metadata << std::endl;
            \} \textcolor{keywordflow}{else} \{
                std::cout << \textcolor{stringliteral}{"> Unknown connection id "} << \textcolor{keywordtype}{id} << std::endl;
            \}
        \} \textcolor{keywordflow}{else} \{
            std::cout << \textcolor{stringliteral}{"> Unrecognized Command"} << std::endl;
        \}
    \}

    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


\subsubsection*{Step 5}

{\itshape Closing connections}

This step adds a command that allows you to close a Web\+Socket connection and adjusts the quit command so that it cleanly closes all outstanding connections before quitting.

\paragraph*{Getting connection close information out of Web\+Socket++}

\begin{quote}
\subparagraph*{Terminology\+: Web\+Socket close codes \& reasons}

The Web\+Socket close handshake involves an exchange of optional machine readable close codes and human readable reason strings. Each endpoint sends independent close details. The codes are short integers. The reasons are U\+T\+F8 text strings of at most 125 characters. More details about valid close code ranges and the meaning of each code can be found at \href{https://tools.ietf.org/html/rfc6455#section-7.4}{\tt https\+://tools.\+ietf.\+org/html/rfc6455\#section-\/7.\+4} \end{quote}


The {\ttfamily \mbox{\hyperlink{namespacewebsocketpp_1_1close_1_1status}{websocketpp\+::close\+::status}}} namespace contains named constants for all of the I\+A\+NA defined close codes. It also includes free functions to determine whether a value is reserved or invalid and to convert a code to a human readable text representation.

During the close handler call Web\+Socket++ connections offer the following methods for accessing close handshake information\+:


\begin{DoxyItemize}
\item {\ttfamily connection\+::get\+\_\+remote\+\_\+close\+\_\+code()}\+: Get the close code as reported by the remote endpoint
\item {\ttfamily connection\+::get\+\_\+remote\+\_\+close\+\_\+reason()}\+: Get the close reason as reported by the remote endpoint
\item {\ttfamily connection\+::get\+\_\+local\+\_\+close\+\_\+code()}\+: Get the close code that this endpoint sent.
\item {\ttfamily connection\+::get\+\_\+local\+\_\+close\+\_\+reason()}\+: Get the close reason that this endpoint sent.
\item {\ttfamily connection\+::get\+\_\+ec()}\+: Get a more detailed/specific Web\+Socket++ {\ttfamily error\+\_\+code} indicating what library error (if any) ultimately resulted in the connection closure.
\end{DoxyItemize}

{\itshape Note\+:} there are some special close codes that will report a code that was not actually sent on the wire. For example 1005/\char`\"{}no close code\char`\"{} indicates that the endpoint omitted a close code entirely and 1006/\char`\"{}abnormal close\char`\"{} indicates that there was a problem that resulted in the connection closing without having performed a close handshake.

\paragraph*{Add close handler}

The {\ttfamily connection\+\_\+metadata\+::on\+\_\+close} method is added. This method retrieves the close code and reason from the closing handshake and stores it in the local error reason field.


\begin{DoxyCode}
\textcolor{keywordtype}{void} on\_close(\mbox{\hyperlink{classwebsocketpp_1_1client}{client}} * c, \mbox{\hyperlink{namespacewebsocketpp_a6b3d26a10ee7229b84b776786332631d}{websocketpp::connection\_hdl}} hdl) \{
    m\_status = \textcolor{stringliteral}{"Closed"};
    \mbox{\hyperlink{classwebsocketpp_1_1client_a2e187bbb2beac676bbfbc2e8065de83e}{client::connection\_ptr}} con = c->get\_con\_from\_hdl(hdl);
    std::stringstream s;
    s << \textcolor{stringliteral}{"close code: "} << con->get\_remote\_close\_code() << \textcolor{stringliteral}{" ("} 
      << \mbox{\hyperlink{namespacewebsocketpp_1_1close_1_1status_a4bf4987c79165b134ed1207a567ce209}{websocketpp::close::status::get\_string}}(con->
      get\_remote\_close\_code()) 
      << \textcolor{stringliteral}{"), close reason: "} << con->get\_remote\_close\_reason();
    m\_error\_reason = s.str();
\}
\end{DoxyCode}


Similarly to {\ttfamily on\+\_\+open} and {\ttfamily on\+\_\+fail}, {\ttfamily websocket\+\_\+endpoint\+::connect} registers this close handler when a new connection is made.

\paragraph*{Add close method to {\ttfamily \mbox{\hyperlink{classwebsocket__endpoint}{websocket\+\_\+endpoint}}}}

This method starts by looking up the given connection ID in the connection list. Next a close request is sent to the connection\textquotesingle{}s handle with the specified Web\+Socket close code. This is done by calling {\ttfamily endpoint\+::close}. This is a thread safe method that is used to asynchronously dispatch a close signal to the connection with the given handle. When the operation is complete the connection\textquotesingle{}s close handler will be triggered.


\begin{DoxyCode}
\textcolor{keywordtype}{void} close(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \mbox{\hyperlink{namespacewebsocketpp_1_1close_1_1status_a8614a5c4733d708e2d2a32191c5bef84}{websocketpp::close::status::value}} code) \{
    websocketpp::lib::error\_code ec;

    con\_list::iterator metadata\_it = m\_connection\_list.find(\textcolor{keywordtype}{id});
    \textcolor{keywordflow}{if} (metadata\_it == m\_connection\_list.end()) \{
        std::cout << \textcolor{stringliteral}{"> No connection found with id "} << \textcolor{keywordtype}{id} << std::endl;
        \textcolor{keywordflow}{return};
    \}

    m\_endpoint.close(metadata\_it->second->get\_hdl(), code, \textcolor{stringliteral}{""}, ec);
    \textcolor{keywordflow}{if} (ec) \{
        std::cout << \textcolor{stringliteral}{"> Error initiating close: "} << ec.message() << std::endl;
    \}
\}
\end{DoxyCode}


\paragraph*{Add close option to the command loop and help message}

\mbox{\hyperlink{struct_a}{A}} close option is added to the command loop. It takes a connection ID and optionally a close code and a close reason. If no code is specified the default of 1000/\+Normal is used. If no reason is specified, none is sent. The {\ttfamily endpoint\+::close} method will do some error checking and abort the close request if you try and send an invalid code or a reason with invalid U\+T\+F8 formatting. Reason strings longer than 125 characters will be truncated.

An entry is also added to the help system to describe how the new command may be used.


\begin{DoxyCode}
\textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.substr(0,5) == \textcolor{stringliteral}{"close"}) \{
    std::stringstream ss(input);

    std::string cmd;
    \textcolor{keywordtype}{int} id;
    \textcolor{keywordtype}{int} close\_code = websocketpp::close::status::normal;
    std::string reason;

    ss >> cmd >> \textcolor{keywordtype}{id} >> close\_code;
    std::getline(ss,reason);

    endpoint.close(\textcolor{keywordtype}{id}, close\_code, reason);
\}
\end{DoxyCode}


\paragraph*{Close all outstanding connections in {\ttfamily \mbox{\hyperlink{classwebsocket__endpoint}{websocket\+\_\+endpoint}}} destructor}

Until now quitting the program left outstanding connections and the Web\+Socket++ network thread in a lurch. Now that we have a method of closing connections we can clean this up properly.

The destructor for {\ttfamily \mbox{\hyperlink{classwebsocket__endpoint}{websocket\+\_\+endpoint}}} now stops perpetual mode (so the run thread exits after the last connection is closed) and iterates through the list of open connections and requests a clean close for each. Finally, the run thread is joined which causes the program to wait until those connection closes complete.


\begin{DoxyCode}
~\mbox{\hyperlink{classwebsocket__endpoint}{websocket\_endpoint}}() \{
    m\_endpoint.stop\_perpetual();

    \textcolor{keywordflow}{for} (con\_list::const\_iterator it = m\_connection\_list.begin(); it != m\_connection\_list.end(); ++it) \{
        \textcolor{keywordflow}{if} (it->second->get\_status() != \textcolor{stringliteral}{"Open"}) \{
            \textcolor{comment}{// Only close open connections}
            \textcolor{keywordflow}{continue};
        \}

        std::cout << \textcolor{stringliteral}{"> Closing connection "} << it->second->get\_id() << std::endl;

        websocketpp::lib::error\_code ec;
        m\_endpoint.close(it->second->get\_hdl(), websocketpp::close::status::going\_away, \textcolor{stringliteral}{""}, ec);
        \textcolor{keywordflow}{if} (ec) \{
            std::cout << \textcolor{stringliteral}{"> Error closing connection "} << it->second->get\_id() << \textcolor{stringliteral}{": "}  
                      << ec.message() << std::endl;
        \}
    \}

    m\_thread->join();
\}
\end{DoxyCode}


\paragraph*{Build}

There are no changes to the build instructions from step 4

\paragraph*{Run}


\begin{DoxyCode}
Enter Command: connect ws://localhost:9002
> Created connection with id 0
Enter Command: close 0 1001 example message
Enter Command: show 0
> URI: ws://localhost:9002
> Status: Closed
> Remote Server: WebSocket++/0.4.0
> Error/close reason: close code: 1001 (Going away), close reason:  example message
Enter Command: connect ws://localhost:9002
> Created connection with id 1
Enter Command: close 1 1006
> Error initiating close: Invalid close code used
Enter Command: quit
> Closing connection 1
\end{DoxyCode}


\subsubsection*{Step 6}

{\itshape Sending and receiving messages}

This step adds a command to send a message on a given connection and updates the show command to print a transcript of all sent and received messages for that connection.

\begin{quote}
\subparagraph*{Terminology\+: Web\+Socket message types (opcodes)}

Web\+Socket messages have types indicated by their opcode. The protocol currently specifies two different opcodes for data messages, text and binary. Text messages represent U\+T\+F8 text and will be validated as such. \mbox{\hyperlink{struct_binary}{Binary}} messages represent raw binary bytes and are passed through directly with no validation.

Web\+Socket++ provides the values {\ttfamily websocketpp\+::frame\+::opcode\+::text} and {\ttfamily websocketpp\+::frame\+::opcode\+::binary} that can be used to direct how outgoing messages should be sent and to check how incoming messages are formatted. \end{quote}


\paragraph*{Sending Messages}

Messages are sent using {\ttfamily endpoint\+::send}. This is a thread safe method that may be called from anywhere to queue a message for sending on the specified connection. There are three send overloads for use with different scenarios.

Each method takes a {\ttfamily connection\+\_\+hdl} to indicate which connection to send the message on as well as a {\ttfamily frame\+::opcode\+::value} to indicate which opcode to label the message as. All overloads are also available with an exception free varient that fills in a a status/error code instead of throwing.

The first overload, {\ttfamily connection\+\_\+hdl hdl, std\+::string const \& payload, frame\+::opcode\+::value op}, takes a {\ttfamily std\+::string}. The string contents are copied into an internal buffer and can be safely modified after calling send.

The second overload, {\ttfamily connection\+\_\+hdl hdl, void const $\ast$ payload, size\+\_\+t len, frame\+::opcode\+::value op}, takes a void $\ast$ buffer and length. The buffer contents are copied and can be safely modified after calling send.

The third overload, {\ttfamily connection\+\_\+hdl hdl, message\+\_\+ptr msg}, takes a Web\+Socket++ {\ttfamily message\+\_\+ptr}. This overload allows a message to be constructed in place before the call to send. It also may allow a single message buffer to be sent multiple times, including to multiple connections, without copying. Whether or not this actually happens depends on other factors such as whether compression is enabled. The contents of the message buffer may not be safely modified after being sent.

\begin{quote}
\subparagraph*{Terminology\+: Outgoing Web\+Socket message queueing \& flow control}

In many configurations, such as when the Asio based transport is in use, Web\+Socket++ is an asynchronous system. As such the {\ttfamily endpoint\+::send} method may return before any bytes are actually written to the outgoing socket. In cases where send is called multiple times in quick succession messages may be coalesced and sent in the same operation or even the same T\+CP packet. When this happens the message boundaries are preserved (each call to send will produce a separate message).

In the case of applications that call send from inside a handler this means that no messages will be written to the socket until that handler returns. If you are planning to send many messages in this manor or need a message to be written on the wire before continuing you should look into using multiple threads or the built in timer/interrupt handler functionality.

If the outgoing socket link is slow messages may build up in this queue. You can use {\ttfamily connection\+::get\+\_\+buffered\+\_\+amount} to query the current size of the written message queue to decide if you want to change your sending behavior. \end{quote}


\paragraph*{Add send method to {\ttfamily \mbox{\hyperlink{classwebsocket__endpoint}{websocket\+\_\+endpoint}}}}

Like the close method, send will start by looking up the given connection ID in the connection list. Next a send request is sent to the connection\textquotesingle{}s handle with the specified Web\+Socket message and the text opcode. Finally, we record the sent message with our connection metadata object so later our show connection command can print a list of messages sent.


\begin{DoxyCode}
\textcolor{keywordtype}{void} send(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, std::string message) \{
    websocketpp::lib::error\_code ec;

    con\_list::iterator metadata\_it = m\_connection\_list.find(\textcolor{keywordtype}{id});
    \textcolor{keywordflow}{if} (metadata\_it == m\_connection\_list.end()) \{
        std::cout << \textcolor{stringliteral}{"> No connection found with id "} << \textcolor{keywordtype}{id} << std::endl;
        \textcolor{keywordflow}{return};
    \}

    m\_endpoint.send(metadata\_it->second->get\_hdl(), message, websocketpp::frame::opcode::text, ec);
    \textcolor{keywordflow}{if} (ec) \{
        std::cout << \textcolor{stringliteral}{"> Error sending message: "} << ec.message() << std::endl;
        \textcolor{keywordflow}{return};
    \}

    metadata\_it->second->record\_sent\_message(message);
\}
\end{DoxyCode}


\paragraph*{Add send option to the command loop and help message}

\mbox{\hyperlink{struct_a}{A}} send option is added to the command loop. It takes a connection ID and a text message to send. An entry is also added to the help system to describe how the new command may be used.


\begin{DoxyCode}
\textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.substr(0,4) == \textcolor{stringliteral}{"send"}) \{
    std::stringstream ss(input);

        std::string cmd;
        \textcolor{keywordtype}{int} id;
        std::string message = \textcolor{stringliteral}{""};

        ss >> cmd >> id;
        std::getline(ss,message);

        endpoint.send(\textcolor{keywordtype}{id}, message);
\}
\end{DoxyCode}


\paragraph*{Add glue to {\ttfamily \mbox{\hyperlink{classconnection__metadata}{connection\+\_\+metadata}}} for storing sent messages}

In order to store messages sent on this connection some code is added to {\ttfamily \mbox{\hyperlink{classconnection__metadata}{connection\+\_\+metadata}}}. This includes a new data member {\ttfamily \mbox{\hyperlink{classstd_1_1vector}{std\+::vector}}$<$std\+::string$>$ m\+\_\+messages} to keep track of all messages sent and received as well as a method for adding a sent message in that list\+:


\begin{DoxyCode}
\textcolor{keywordtype}{void} record\_sent\_message(std::string message) \{
    m\_messages.push\_back(\textcolor{stringliteral}{">> "} + message);
\}
\end{DoxyCode}


Finally the connection metadata output operator is updated to also print a list of processed messages\+:


\begin{DoxyCode}
out << \textcolor{stringliteral}{"> Messages Processed: ("} << data.m\_messages.size() << \textcolor{stringliteral}{") \(\backslash\)n"};

\mbox{\hyperlink{classstd_1_1vector}{std::vector<std::string>::const\_iterator}} it;
\textcolor{keywordflow}{for} (it = data.m\_messages.begin(); it != data.m\_messages.end(); ++it) \{
    out << *it << \textcolor{stringliteral}{"\(\backslash\)n"};
\}
\end{DoxyCode}


\paragraph*{Receiving Messages}

Messages are received by registering a message handler. This handler will be called once per message received and its signature is {\ttfamily void on\+\_\+message(websocketpp\+::connection\+\_\+hdl hdl, endpoint\+::message\+\_\+ptr msg)}. The {\ttfamily connection\+\_\+hdl}, like the similar parameter from the other handlers is a handle for the connection that the message was received on. The {\ttfamily message\+\_\+ptr} is a pointer to an object that can be queried for the message payload, opcode, and other metadata. Note that the message\+\_\+ptr type, as well as its underlying message type, is dependent on how your endpoint is configured and may be different for different configs.

\paragraph*{Add a message handler to method to {\ttfamily \mbox{\hyperlink{classconnection__metadata}{connection\+\_\+metadata}}}}

The message receiving behave that we are implementing will be to collect all messages sent and received and to print them in order when the show connection command is run. The sent messages are already being added to that list. Now we add a message handler that pushes received messages to the list as well. Text messages are pushed as-\/is. \mbox{\hyperlink{struct_binary}{Binary}} messages are first converted to printable hexadecimal format.


\begin{DoxyCode}
\textcolor{keywordtype}{void} on\_message(\mbox{\hyperlink{namespacewebsocketpp_a6b3d26a10ee7229b84b776786332631d}{websocketpp::connection\_hdl}} hdl, 
      \mbox{\hyperlink{classwebsocketpp_1_1endpoint_a585ecbbfd9689d4e4229e4c8378bd672}{client::message\_ptr}} msg) \{
    \textcolor{keywordflow}{if} (msg->get\_opcode() == websocketpp::frame::opcode::text) \{
        m\_messages.push\_back(msg->get\_payload());
    \} \textcolor{keywordflow}{else} \{
        m\_messages.push\_back(\mbox{\hyperlink{namespacewebsocketpp_1_1utility_a26e5a26395d95d2f6bf3a9edb8d06dd2}{websocketpp::utility::to\_hex}}(msg->get\_payload()));
    \}
\}
\end{DoxyCode}


In order to have this handler called when new messages are received we also register it with our connection. Note that unlike most other handlers, the message handler has two parameters and thus needs two placeholders.


\begin{DoxyCode}
con->set\_message\_handler(websocketpp::lib::bind(
    &connection\_metadata::on\_message,
    metadata\_ptr,
    websocketpp::lib::placeholders::\_1,
    websocketpp::lib::placeholders::\_2
));
\end{DoxyCode}


\paragraph*{Build}

There are no changes to the build instructions from step 5

\paragraph*{Run}

In this example run we are connecting to the Web\+Socket++ example echo\+\_\+server. This server will repeat any message we send back to it. You can also try testing this with the echo server at {\ttfamily ws\+://echo.websocket.\+org} with similar results.


\begin{DoxyCode}
Enter Command: connect ws://localhost:9002
> Created connection with id 0
Enter Command: send 0 example message
Enter Command: show 0
> URI: ws://localhost:9002
> Status: Open
> Remote Server: WebSocket++/0.4.0
> Error/close reason: N/A
> Messages Processed: (2)
>>  example message
<<  example message
\end{DoxyCode}


\subsubsection*{Step 7}

{\itshape Using T\+LS / Secure Web\+Sockets}


\begin{DoxyItemize}
\item Change the includes
\item link to the new library dependencies
\item Switch the config
\item add the {\ttfamily tls\+\_\+init\+\_\+handler}
\item configure the S\+SL context for desired security level
\item mixing secure and non-\/secure connections in one application.
\end{DoxyItemize}

\subsection*{Chapter 2\+: Intermediate Features }

\subsubsection*{Step 8}

{\itshape Intermediate level features}


\begin{DoxyItemize}
\item Subprotocol negotiation
\item Setting and reading custom headers
\item Ping and Pong
\item Proxies?
\item Setting user agent
\item Setting Origin
\item Timers and security
\item Close behavior
\item Send one message to all connections
\end{DoxyItemize}

\subsubsection*{Misc stuff not sure if it should be included here or elsewhere?}

core websocket++ control flow. \mbox{\hyperlink{struct_a}{A}} handshake, followed by a split into 2 independent control strands
\begin{DoxyItemize}
\item Handshake -- use information specified before the call to endpoint\+::connect to construct a Web\+Socket handshake request. -- Pass the Web\+Socket handshake request to the transport policy. The transport policy determines how to get these bytes to the endpoint playing the server role. Depending on which transport policy your endpoint uses this method will be different. -- Receive a handshake response from the underlying transport. This is parsed and checked for conformance to R\+F\+C6455. If the validation fails, the fail handler is called. Otherwise the open handler is called.
\item At this point control splits into two separate strands. \mbox{\hyperlink{struct_one}{One}} that reads new bytes from the transport policy on the incoming channle, the other that accepts new messages from the local application for framing and writing to the outgoing transport channel.
\item Read strand -- Read and process new bytes from transport -- If the bytes contain at least one complete message dispatch each message by calling the appropriate handler. This is either the message handler for data messages, or ping/pong/close handlers for each respective control message. If no handler is registered for a particular message it is ignored. -- Ask the transport layer for more bytes
\item Write strand -- Wait for messages from the application -- Perform error checking on message input, -- Frame message per R\+F\+C6455 -- Queue message for sending -- Pass all outstanding messages to the transport policy for output -- When there are no messages left to send, return to waiting
\end{DoxyItemize}

Important observations Handlers run in line with library processing which has several implications applications should be aware of\+: 