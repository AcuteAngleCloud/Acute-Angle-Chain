<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AcuteAngleChain: websocketpp::transport::asio::basic_socket::connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="aac-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AcuteAngleChain
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewebsocketpp.html">websocketpp</a></li><li class="navelem"><a class="el" href="namespacewebsocketpp_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespacewebsocketpp_1_1transport_1_1asio.html">asio</a></li><li class="navelem"><a class="el" href="namespacewebsocketpp_1_1transport_1_1asio_1_1basic__socket.html">basic_socket</a></li><li class="navelem"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html">connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">websocketpp::transport::asio::basic_socket::connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic Asio connection socket component.  
 <a href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="transport_2asio_2security_2none_8hpp_source.html">none.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for websocketpp::transport::asio::basic_socket::connection:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection__inherit__graph.png" border="0" usemap="#websocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for websocketpp::transport::asio::basic_socket::connection:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection__coll__graph.png" border="0" usemap="#websocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a449a7d627f3e231de1f25668b544478a"><td class="memItemLeft" align="right" valign="top"><a id="a449a7d627f3e231de1f25668b544478a"></a>
typedef <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html">connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a449a7d627f3e231de1f25668b544478a">type</a></td></tr>
<tr class="memdesc:a449a7d627f3e231de1f25668b544478a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of this connection socket component. <br /></td></tr>
<tr class="separator:a449a7d627f3e231de1f25668b544478a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4fa6887235c53c7ddd13307798b280"><td class="memItemLeft" align="right" valign="top"><a id="a1a4fa6887235c53c7ddd13307798b280"></a>
typedef lib::shared_ptr&lt; <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a449a7d627f3e231de1f25668b544478a">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a1a4fa6887235c53c7ddd13307798b280">ptr</a></td></tr>
<tr class="memdesc:a1a4fa6887235c53c7ddd13307798b280"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a shared pointer to this connection socket component. <br /></td></tr>
<tr class="separator:a1a4fa6887235c53c7ddd13307798b280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c876008bd8610fb497c5d5be56faab"><td class="memItemLeft" align="right" valign="top"><a id="af4c876008bd8610fb497c5d5be56faab"></a>
typedef lib::asio::io_service *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#af4c876008bd8610fb497c5d5be56faab">io_service_ptr</a></td></tr>
<tr class="memdesc:af4c876008bd8610fb497c5d5be56faab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a pointer to the Asio io_service being used. <br /></td></tr>
<tr class="separator:af4c876008bd8610fb497c5d5be56faab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8283ac4f3aa27ada9cd899d579e497"><td class="memItemLeft" align="right" valign="top"><a id="aed8283ac4f3aa27ada9cd899d579e497"></a>
typedef lib::shared_ptr&lt; lib::asio::io_service::strand &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#aed8283ac4f3aa27ada9cd899d579e497">strand_ptr</a></td></tr>
<tr class="memdesc:aed8283ac4f3aa27ada9cd899d579e497"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a pointer to the Asio io_service strand being used. <br /></td></tr>
<tr class="separator:aed8283ac4f3aa27ada9cd899d579e497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08ccb2cf63fc0fae8543677daf54839"><td class="memItemLeft" align="right" valign="top"><a id="ad08ccb2cf63fc0fae8543677daf54839"></a>
typedef lib::asio::ip::tcp::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#ad08ccb2cf63fc0fae8543677daf54839">socket_type</a></td></tr>
<tr class="memdesc:ad08ccb2cf63fc0fae8543677daf54839"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of the ASIO socket being used. <br /></td></tr>
<tr class="separator:ad08ccb2cf63fc0fae8543677daf54839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4985155bab6340a0ca9b165ccf51a4"><td class="memItemLeft" align="right" valign="top"><a id="a7a4985155bab6340a0ca9b165ccf51a4"></a>
typedef lib::shared_ptr&lt; <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#ad08ccb2cf63fc0fae8543677daf54839">socket_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a7a4985155bab6340a0ca9b165ccf51a4">socket_ptr</a></td></tr>
<tr class="memdesc:a7a4985155bab6340a0ca9b165ccf51a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a shared pointer to the socket being used. <br /></td></tr>
<tr class="separator:a7a4985155bab6340a0ca9b165ccf51a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade8aecc68665126f6beb82e74169a96d"><td class="memItemLeft" align="right" valign="top"><a id="ade8aecc68665126f6beb82e74169a96d"></a>
<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a1a4fa6887235c53c7ddd13307798b280">ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#ade8aecc68665126f6beb82e74169a96d">get_shared</a> ()</td></tr>
<tr class="memdesc:ade8aecc68665126f6beb82e74169a96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to this component. <br /></td></tr>
<tr class="separator:ade8aecc68665126f6beb82e74169a96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747da29816758e8aae89ff36542c7c7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a747da29816758e8aae89ff36542c7c7d">is_secure</a> () const</td></tr>
<tr class="memdesc:a747da29816758e8aae89ff36542c7c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not this connection is secure.  <a href="#a747da29816758e8aae89ff36542c7c7d">More...</a><br /></td></tr>
<tr class="separator:a747da29816758e8aae89ff36542c7c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea605a8c2ed46812057b36b7a0ddf6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a2ea605a8c2ed46812057b36b7a0ddf6a">set_socket_init_handler</a> (<a class="el" href="namespacewebsocketpp_1_1transport_1_1asio_1_1basic__socket.html#a88f9c59fa40db3188769162db98edb93">socket_init_handler</a> h)</td></tr>
<tr class="memdesc:a2ea605a8c2ed46812057b36b7a0ddf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the socket initialization handler.  <a href="#a2ea605a8c2ed46812057b36b7a0ddf6a">More...</a><br /></td></tr>
<tr class="separator:a2ea605a8c2ed46812057b36b7a0ddf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5026a6893c7bc54be3f7981fceaf849"><td class="memItemLeft" align="right" valign="top">lib::asio::ip::tcp::socket &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#ae5026a6893c7bc54be3f7981fceaf849">get_socket</a> ()</td></tr>
<tr class="memdesc:ae5026a6893c7bc54be3f7981fceaf849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the underlying socket.  <a href="#ae5026a6893c7bc54be3f7981fceaf849">More...</a><br /></td></tr>
<tr class="separator:ae5026a6893c7bc54be3f7981fceaf849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9f1b8fec827bc502f450cbf2c0d583"><td class="memItemLeft" align="right" valign="top">lib::asio::ip::tcp::socket &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#aad9f1b8fec827bc502f450cbf2c0d583">get_next_layer</a> ()</td></tr>
<tr class="memdesc:aad9f1b8fec827bc502f450cbf2c0d583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the underlying socket.  <a href="#aad9f1b8fec827bc502f450cbf2c0d583">More...</a><br /></td></tr>
<tr class="separator:aad9f1b8fec827bc502f450cbf2c0d583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2735b03146b13e956bf58cd9f2e51ff6"><td class="memItemLeft" align="right" valign="top">lib::asio::ip::tcp::socket &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a2735b03146b13e956bf58cd9f2e51ff6">get_raw_socket</a> ()</td></tr>
<tr class="memdesc:a2735b03146b13e956bf58cd9f2e51ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the underlying socket.  <a href="#a2735b03146b13e956bf58cd9f2e51ff6">More...</a><br /></td></tr>
<tr class="separator:a2735b03146b13e956bf58cd9f2e51ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e022cc8ebabf59c2884f6525729892"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#ab8e022cc8ebabf59c2884f6525729892">get_remote_endpoint</a> (lib::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ab8e022cc8ebabf59c2884f6525729892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint address.  <a href="#ab8e022cc8ebabf59c2884f6525729892">More...</a><br /></td></tr>
<tr class="separator:ab8e022cc8ebabf59c2884f6525729892"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac458885eaebea790795dbe5e7ab62dc9"><td class="memItemLeft" align="right" valign="top">lib::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#ac458885eaebea790795dbe5e7ab62dc9">init_asio</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#af4c876008bd8610fb497c5d5be56faab">io_service_ptr</a> service, <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#aed8283ac4f3aa27ada9cd899d579e497">strand_ptr</a>, bool)</td></tr>
<tr class="memdesc:ac458885eaebea790795dbe5e7ab62dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one time initializations.  <a href="#ac458885eaebea790795dbe5e7ab62dc9">More...</a><br /></td></tr>
<tr class="separator:ac458885eaebea790795dbe5e7ab62dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d114dca4ca6ce161fca608e1a7138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a303d114dca4ca6ce161fca608e1a7138">set_uri</a> (<a class="el" href="namespacewebsocketpp.html#aae370ea5ac83a8ece7712cb39fc23f5b">uri_ptr</a>)</td></tr>
<tr class="memdesc:a303d114dca4ca6ce161fca608e1a7138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set uri hook.  <a href="#a303d114dca4ca6ce161fca608e1a7138">More...</a><br /></td></tr>
<tr class="separator:a303d114dca4ca6ce161fca608e1a7138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49994bd223b8d0a2eaa11d0029a1b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#ab49994bd223b8d0a2eaa11d0029a1b78">pre_init</a> (<a class="el" href="namespacewebsocketpp_1_1transport.html#aeae75e675c1a334b3b33ab7120b480a5">init_handler</a> callback)</td></tr>
<tr class="memdesc:ab49994bd223b8d0a2eaa11d0029a1b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-initialize security policy.  <a href="#ab49994bd223b8d0a2eaa11d0029a1b78">More...</a><br /></td></tr>
<tr class="separator:ab49994bd223b8d0a2eaa11d0029a1b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeee4b73e1f47d21dd42e455f1272d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#abeee4b73e1f47d21dd42e455f1272d64">post_init</a> (<a class="el" href="namespacewebsocketpp_1_1transport.html#aeae75e675c1a334b3b33ab7120b480a5">init_handler</a> callback)</td></tr>
<tr class="memdesc:abeee4b73e1f47d21dd42e455f1272d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-initialize security policy.  <a href="#abeee4b73e1f47d21dd42e455f1272d64">More...</a><br /></td></tr>
<tr class="separator:abeee4b73e1f47d21dd42e455f1272d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8318bcf892664a4f66a1f1435ed5ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#aac8318bcf892664a4f66a1f1435ed5ce">set_handle</a> (<a class="el" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">connection_hdl</a> hdl)</td></tr>
<tr class="memdesc:aac8318bcf892664a4f66a1f1435ed5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the connection handle.  <a href="#aac8318bcf892664a4f66a1f1435ed5ce">More...</a><br /></td></tr>
<tr class="separator:aac8318bcf892664a4f66a1f1435ed5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1e0b99023c2653ebbe7953c874cc6d"><td class="memItemLeft" align="right" valign="top">lib::asio::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#aaf1e0b99023c2653ebbe7953c874cc6d">cancel_socket</a> ()</td></tr>
<tr class="memdesc:aaf1e0b99023c2653ebbe7953c874cc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all async operations on this socket.  <a href="#aaf1e0b99023c2653ebbe7953c874cc6d">More...</a><br /></td></tr>
<tr class="separator:aaf1e0b99023c2653ebbe7953c874cc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82ce93dad13c5b909367c75a3195759"><td class="memItemLeft" align="right" valign="top"><a id="ac82ce93dad13c5b909367c75a3195759"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>async_shutdown</b> (socket::shutdown_handler h)</td></tr>
<tr class="separator:ac82ce93dad13c5b909367c75a3195759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959b352b412f30394a4e480bab01b7c7"><td class="memItemLeft" align="right" valign="top"><a id="a959b352b412f30394a4e480bab01b7c7"></a>
lib::error_code&#160;</td><td class="memItemRight" valign="bottom"><b>get_ec</b> () const</td></tr>
<tr class="separator:a959b352b412f30394a4e480bab01b7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce50f4cb485ca4e98577f9f7af4b635"><td class="memTemplParams" colspan="2">template&lt;typename ErrorCodeType &gt; </td></tr>
<tr class="memitem:a3ce50f4cb485ca4e98577f9f7af4b635"><td class="memTemplItemLeft" align="right" valign="top">lib::error_code&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a3ce50f4cb485ca4e98577f9f7af4b635">translate_ec</a> (ErrorCodeType)</td></tr>
<tr class="memdesc:a3ce50f4cb485ca4e98577f9f7af4b635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate any security policy specific information about an error code.  <a href="#a3ce50f4cb485ca4e98577f9f7af4b635">More...</a><br /></td></tr>
<tr class="separator:a3ce50f4cb485ca4e98577f9f7af4b635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b3f3132f48c3b57f48514557f6e653"><td class="memItemLeft" align="right" valign="top">lib::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#a92b3f3132f48c3b57f48514557f6e653">translate_ec</a> (lib::error_code ec)</td></tr>
<tr class="separator:a92b3f3132f48c3b57f48514557f6e653"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Basic Asio connection socket component. </p>
<p><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html" title="Basic Asio connection socket component. ">transport::asio::basic_socket::connection</a> implements a connection socket component using Asio ip::tcp::socket. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf1e0b99023c2653ebbe7953c874cc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1e0b99023c2653ebbe7953c874cc6d">&#9670;&nbsp;</a></span>cancel_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::asio::error_code websocketpp::transport::asio::basic_socket::connection::cancel_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all async operations on this socket. </p>
<p>Attempts to cancel all async operations on this socket and reports any failures.</p>
<p>NOTE: Windows XP and earlier do not support socket cancellation.</p>
<dl class="section return"><dt>Returns</dt><dd>The error that occurred, if any. </dd></dl>

</div>
</div>
<a id="aad9f1b8fec827bc502f450cbf2c0d583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9f1b8fec827bc502f450cbf2c0d583">&#9670;&nbsp;</a></span>get_next_layer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::asio::ip::tcp::socket&amp; websocketpp::transport::asio::basic_socket::connection::get_next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a pointer to the underlying socket. </p>
<p>This is used internally. </p>

</div>
</div>
<a id="a2735b03146b13e956bf58cd9f2e51ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2735b03146b13e956bf58cd9f2e51ff6">&#9670;&nbsp;</a></span>get_raw_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::asio::ip::tcp::socket&amp; websocketpp::transport::asio::basic_socket::connection::get_raw_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a pointer to the underlying socket. </p>
<p>This is used internally. It can also be used to set socket options, etc </p>

</div>
</div>
<a id="ab8e022cc8ebabf59c2884f6525729892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e022cc8ebabf59c2884f6525729892">&#9670;&nbsp;</a></span>get_remote_endpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string websocketpp::transport::asio::basic_socket::connection::get_remote_endpoint </td>
          <td>(</td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint address. </p>
<p>The iostream transport has no information about the ultimate remote endpoint. It will return the string "iostream transport". To indicate this.</p>
<p>TODO: allow user settable remote endpoint addresses if this seems useful</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a.html">A</a> string identifying the address of the remote endpoint </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection_ab8e022cc8ebabf59c2884f6525729892_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection_ab8e022cc8ebabf59c2884f6525729892_cgraph" alt=""/></div>
<!-- MAP 2 -->
</div>

</div>
</div>
<a id="ae5026a6893c7bc54be3f7981fceaf849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5026a6893c7bc54be3f7981fceaf849">&#9670;&nbsp;</a></span>get_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::asio::ip::tcp::socket&amp; websocketpp::transport::asio::basic_socket::connection::get_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a pointer to the underlying socket. </p>
<p>This is used internally. It can also be used to set socket options, etc </p>

</div>
</div>
<a id="ac458885eaebea790795dbe5e7ab62dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac458885eaebea790795dbe5e7ab62dc9">&#9670;&nbsp;</a></span>init_asio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::error_code websocketpp::transport::asio::basic_socket::connection::init_asio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#af4c876008bd8610fb497c5d5be56faab">io_service_ptr</a>&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1basic__socket_1_1connection.html#aed8283ac4f3aa27ada9cd899d579e497">strand_ptr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one time initializations. </p>
<p>init_asio is called once immediately after construction to initialize Asio components to the io_service</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td><a class="el" href="struct_a.html">A</a> pointer to the endpoint's io_service </td></tr>
    <tr><td class="paramname">strand</td><td><a class="el" href="struct_a.html">A</a> shared pointer to the connection's asio strand </td></tr>
    <tr><td class="paramname">is_server</td><td>Whether or not the endpoint is a server or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a747da29816758e8aae89ff36542c7c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747da29816758e8aae89ff36542c7c7d">&#9670;&nbsp;</a></span>is_secure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool websocketpp::transport::asio::basic_socket::connection::is_secure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether or not this connection is secure. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not this connection is secure </dd></dl>

</div>
</div>
<a id="abeee4b73e1f47d21dd42e455f1272d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeee4b73e1f47d21dd42e455f1272d64">&#9670;&nbsp;</a></span>post_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void websocketpp::transport::asio::basic_socket::connection::post_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#aeae75e675c1a334b3b33ab7120b480a5">init_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-initialize security policy. </p>
<p>Called by the transport after all intermediate proxies have been negotiated. This gives the security policy the chance to talk with the real remote endpoint for a bit before the websocket handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Handler to call back with completion information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab49994bd223b8d0a2eaa11d0029a1b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49994bd223b8d0a2eaa11d0029a1b78">&#9670;&nbsp;</a></span>pre_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void websocketpp::transport::asio::basic_socket::connection::pre_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#aeae75e675c1a334b3b33ab7120b480a5">init_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-initialize security policy. </p>
<p>Called by the transport after a new connection is created to initialize the socket component of the connection. This method is not allowed to write any bytes to the wire. This initialization happens before any proxies or other intermediate wrappers are negotiated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Handler to call back with completion information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac8318bcf892664a4f66a1f1435ed5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8318bcf892664a4f66a1f1435ed5ce">&#9670;&nbsp;</a></span>set_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void websocketpp::transport::asio::basic_socket::connection::set_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">connection_hdl</a>&#160;</td>
          <td class="paramname"><em>hdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the connection handle. </p>
<p>The connection handle is passed to any handlers to identify the connection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hdl</td><td>The new handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ea605a8c2ed46812057b36b7a0ddf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea605a8c2ed46812057b36b7a0ddf6a">&#9670;&nbsp;</a></span>set_socket_init_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void websocketpp::transport::asio::basic_socket::connection::set_socket_init_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport_1_1asio_1_1basic__socket.html#a88f9c59fa40db3188769162db98edb93">socket_init_handler</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the socket initialization handler. </p>
<p>The socket initialization handler is called after the socket object is created but before it is used. This gives the application a chance to set any Asio socket options it needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The new socket_init_handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a303d114dca4ca6ce161fca608e1a7138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303d114dca4ca6ce161fca608e1a7138">&#9670;&nbsp;</a></span>set_uri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void websocketpp::transport::asio::basic_socket::connection::set_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp.html#aae370ea5ac83a8ece7712cb39fc23f5b">uri_ptr</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set uri hook. </p>
<p>Called by the transport as a connection is being established to provide the uri being connected to to the security/socket layer.</p>
<p>This socket policy doesn't use the uri so it is ignored.</p>
<dl class="section since"><dt>Since</dt><dd>0.6.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The uri to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ce50f4cb485ca4e98577f9f7af4b635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce50f4cb485ca4e98577f9f7af4b635">&#9670;&nbsp;</a></span>translate_ec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ErrorCodeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::error_code websocketpp::transport::asio::basic_socket::connection::translate_ec </td>
          <td>(</td>
          <td class="paramtype">ErrorCodeType&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate any security policy specific information about an error code. </p>
<p>Translate_ec takes an Asio error code and attempts to convert its value to an appropriate websocketpp error code. In the case that the Asio and Websocketpp error types are the same (such as using boost::asio and boost::system_error or using standalone asio and std::system_error the code will be passed through natively.</p>
<p>In the case of a mismatch (boost::asio with std::system_error) a translated code will be returned. The plain socket policy does not have any additional information so all such errors will be reported as the generic transport pass_through error.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>The error code to translate_ec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated error code </dd></dl>

</div>
</div>
<a id="a92b3f3132f48c3b57f48514557f6e653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b3f3132f48c3b57f48514557f6e653">&#9670;&nbsp;</a></span>translate_ec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::error_code websocketpp::transport::asio::basic_socket::connection::translate_ec </td>
          <td>(</td>
          <td class="paramtype">lib::error_code&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of translate_ec to catch cases where lib::error_code is the same type as lib::asio::error_code </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libraries/fc/vendor/websocketpp/websocketpp/transport/asio/security/<a class="el" href="transport_2asio_2security_2none_8hpp_source.html">none.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
