<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AcuteAngleChain: Utility Server Example Application Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="aac-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AcuteAngleChain
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Utility Server Example Application Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction </h2>
<p>This tutorial provides a step by step discussion of building a basic WebSocket++ server. The final product of this tutorial is the <a class="el" href="classutility__server.html">utility_server</a> example application from the example section. This server demonstrates the following features:</p>
<ul>
<li>Use Asio Transport for networking</li>
<li>Accept multiple WebSocket connections at once</li>
<li>Read incoming messages and perform a few basic actions (echo, broadcast, telemetry, server commands) based on the path</li>
<li>Use validate handler to reject connections to invalid paths</li>
<li>Serve basic HTTP responses with the http handler</li>
<li>Gracefully exit the server</li>
<li>Encrypt connections with TLS</li>
</ul>
<p>This tutorial is current as of the 0.6.x version of the library.</p>
<h2>Chapter 1: Initial Setup &amp; Basics </h2>
<h3>Step 1</h3>
<p><em>Add WebSocket++ includes and set up a a server endpoint type.</em></p>
<p>WebSocket++ includes two major object types. The endpoint and the connection. The endpoint creates and launches new connections and maintains default settings for those connections. Endpoints also manage any shared network resources.</p>
<p>The connection stores information specific to each WebSocket session.</p>
<blockquote class="doxtable">
<p><b>Note:</b> Once a connection is launched, there is no link between the endpoint and the connection. All default settings are copied into the new connection by the endpoint. Changing default settings on an endpoint will only affect future connections. </p>
</blockquote>
<p>Connections do not maintain a link back to their associated endpoint. Endpoints do not maintain a list of outstanding connections. If your application needs to iterate over all connections it will need to maintain a list of them itself.</p>
<p>WebSocket++ endpoints are built by combining an endpoint role with an endpoint config. There are two different types of endpoint roles, one each for the client and server roles in a WebSocket session. This is a server tutorial so we will use the server role <code><a class="el" href="classwebsocketpp_1_1server.html" title="Server endpoint role based on the given config. ">websocketpp::server</a></code> which is provided by the <code>&lt;<a class="el" href="server_8hpp_source.html">websocketpp/server.hpp</a>&gt;</code> header.</p>
<blockquote class="doxtable">
<h4>Terminology: Endpoint Config</h4>
<p>WebSocket++ endpoints have a group of settings that may be configured at compile time via the <code>config</code> template parameter. <a class="el" href="struct_a.html">A</a> config is a struct that contains types and static constants that are used to produce an endpoint with specific properties. Depending on which config is being used the endpoint will have different methods available and may have additional third party dependencies. </p>
</blockquote>
<p>The endpoint role takes a template parameter called <code>config</code> that is used to configure the behavior of endpoint at compile time. For this example we are going to use a default config provided by the library called <code>asio</code>, provided by <code>&lt;<a class="el" href="asio__no__tls_8hpp_source.html">websocketpp/config/asio_no_tls.hpp</a>&gt;</code>. This is a server config that uses the Asio library to provide network transport and does not support TLS based security. Later on we will discuss how to introduce TLS based security into a WebSocket++ application, more about the other stock configs, and how to build your own custom configs.</p>
<p>Combine a config with an endpoint role to produce a fully configured endpoint. This type will be used frequently so I would recommend a typedef here.</p>
<p><code>typedef <a class="el" href="classwebsocketpp_1_1server.html" title="Server endpoint role based on the given config. ">websocketpp::server</a>&lt;<a class="el" href="structwebsocketpp_1_1config_1_1asio.html" title="Server config with asio transport and TLS disabled. ">websocketpp::config::asio</a>&gt; server</code></p>
<h4><code><a class="el" href="classutility__server.html">utility_server</a></code> constructor</h4>
<p>This endpoint type will be the base of the <a class="el" href="classutility__server.html">utility_server</a> object that will keep track of the state of the server. Within the <code><a class="el" href="classutility__server.html">utility_server</a></code> constructor several things happen:</p>
<p>First, we adjust the endpoint logging behavior to include all error logging channels and all access logging channels except the frame payload, which is particularly noisy and generally useful only for debugging. [TODO: link to more information about logging]</p>
<div class="fragment"><div class="line">m_endpoint.set_error_channels(<a class="code" href="structwebsocketpp_1_1log_1_1elevel.html#a9b31ff708c221d314f9f4eb3ff2b1ad7">websocketpp::log::elevel::all</a>);</div><div class="line">m_endpoint.set_access_channels(<a class="code" href="structwebsocketpp_1_1log_1_1alevel.html#a853aa0b8976e53f3181af3bc398d493e">websocketpp::log::alevel::all</a> ^ <a class="code" href="structwebsocketpp_1_1log_1_1alevel.html#aa38cfdf7a82f33cac319438462707e90">websocketpp::log::alevel::frame_payload</a>);</div></div><!-- fragment --><p>Next, we initialize the transport system underlying the endpoint. This method is specific to the Asio transport not WebSocket++ core. It will not be necessary or present in endpoints that use a non-asio config.</p>
<blockquote class="doxtable">
<p><b>Note:</b> This example uses an internal Asio <code>io_service</code> that is managed by the endpoint itself. This is a simple arrangement suitable for programs where WebSocket++ is the only code using Asio. If you have an existing program that already manages an <code>io_service</code> object or want to build a new program where WebSocket++ handlers share an io_service with other handlers you can pass the <code>io_service</code> you want WebSocket++ to register its handlers on to the <code>init_asio()</code> method and it will use it instead of generating and managing its own. [TODO: FAQ link instead?] </p>
</blockquote>
<div class="fragment"><div class="line">m_endpoint.init_asio();</div></div><!-- fragment --><h4><code>utility_server::run</code> method</h4>
<p>In addition to the constructor, we also add a run method that sets up the listening socket, begins accepting connections, starts the Asio io_service event loop.</p>
<div class="fragment"><div class="line"><span class="comment">// Listen on port 9002</span></div><div class="line">m_endpoint.listen(9002);</div><div class="line"></div><div class="line"><span class="comment">// Queues a connection accept operation</span></div><div class="line">m_endpoint.start_accept();</div><div class="line"></div><div class="line"><span class="comment">// Start the Asio io_service run loop</span></div><div class="line">m_endpoint.run();</div></div><!-- fragment --><p>The final line, <code>m_endpoint.run();</code>, will block until the endpoint is instructed to stop listening for new connections. While running it will listen for and process new connections as well as accept and process new data and control messages for existing connections. WebSocket++ uses Asio in an asyncronous mode where multiple connections can be similtaneously serviced efficiently within a single thread.</p>
<h4>Build</h4>
<p>Adding WebSocket++ has added a few dependencies to our program that must be addressed in the build system. Firstly, the WebSocket++ library headers need must be in the include search path of your build system. How exactly this is done depends on where you have the WebSocket++ headers installed what build system you are using.</p>
<p>For the rest of this tutorial we are going to assume a C++11 build environment. WebSocket++ will work with pre-C++11 systems if your build system has access to a recent version of the Boost library headers.</p>
<p>Finally, to use the Asio transport config we need to bring in the Asio library. There are two options here. If you have access to a C++11 build environment the standalone version from <a href="http://think-async.com">http://think-async.com</a> is a good option. This header only library does not bring in any special dependencies and ensures you have the latest version of Asio. If you do not have a C++11 build environment or already have brought in the Boost libraries you can also use the version of Asio bundled with Boost.</p>
<p>To use standalone Asio, make sure the Asio headers are in your include path and define ASIO_STANDALONE. To use Boost Asio, make sure the Boost headers are in your include path and that you are linking to the boost_system library.</p>
<p><code>c++ -std=c++11 step1.cpp</code> (Asio Standalone) OR <code>c++ -std=c++11 step1.cpp -lboost_system</code> (Boost Asio)</p>
<p>#### Code so far </p><div class="fragment"><div class="line"><span class="comment">// The ASIO_STANDALONE define is necessary to use the standalone version of Asio.</span></div><div class="line"><span class="comment">// Remove if you are using Boost Asio.</span></div><div class="line"><span class="preprocessor">#define ASIO_STANDALONE</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;websocketpp/config/asio_no_tls.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;websocketpp/server.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classwebsocketpp_1_1server.html">websocketpp::server&lt;websocketpp::config::asio&gt;</a> <a class="code" href="classwebsocketpp_1_1server.html">server</a>;</div><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="classutility__server.html">utility_server</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classutility__server.html">utility_server</a>() {</div><div class="line">         <span class="comment">// Set logging settings</span></div><div class="line">        m_endpoint.<a class="code" href="classwebsocketpp_1_1endpoint.html#a8292bcdca9344b57af1b0964ff7fc778">set_error_channels</a>(<a class="code" href="structwebsocketpp_1_1log_1_1elevel.html#a9b31ff708c221d314f9f4eb3ff2b1ad7">websocketpp::log::elevel::all</a>);</div><div class="line">        m_endpoint.<a class="code" href="classwebsocketpp_1_1endpoint.html#a5d7da609ebd2f797e5e67b6d050ebc59">set_access_channels</a>(<a class="code" href="structwebsocketpp_1_1log_1_1alevel.html#a853aa0b8976e53f3181af3bc398d493e">websocketpp::log::alevel::all</a> ^ <a class="code" href="structwebsocketpp_1_1log_1_1alevel.html#aa38cfdf7a82f33cac319438462707e90">websocketpp::log::alevel::frame_payload</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Initialize Asio</span></div><div class="line">        m_endpoint.init_asio();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run() {</div><div class="line">        <span class="comment">// Listen on port 9002</span></div><div class="line">        m_endpoint.listen(9002);</div><div class="line"></div><div class="line">        <span class="comment">// Queues a connection accept operation</span></div><div class="line">        m_endpoint.<a class="code" href="classwebsocketpp_1_1server.html#a0204a7d444144f7ea5b8bbcf14689fc1">start_accept</a>();</div><div class="line"></div><div class="line">        <span class="comment">// Start the Asio io_service run loop</span></div><div class="line">        m_endpoint.run();</div><div class="line">    }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <a class="code" href="classwebsocketpp_1_1server.html">server</a> m_endpoint;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="classutility__server.html">utility_server</a> s;</div><div class="line">    s.run();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>Step 2</h3>
<p><em>Set up a message handler to echo all replies back to the original user</em></p>
<h4>Setting a message handler</h4>
<blockquote class="doxtable">
<h6>Terminology: Registering handlers</h6>
<p>WebSocket++ provides a number of execution points where you can register to have a handler run. Which of these points are available to your endpoint will depend on its config. TLS handlers will not exist on non-TLS endpoints for example. <a class="el" href="struct_a.html">A</a> complete list of handlers can be found at <a href="http://www.zaphoyd.com/websocketpp/manual/reference/handler-list">http://www.zaphoyd.com/websocketpp/manual/reference/handler-list</a>.</p>
<p>Handlers can be registered at the endpoint level and at the connection level. Endpoint handlers are copied into new connections as they are created. Changing an endpoint handler will affect only future connections. Handlers registered at the connection level will be bound to that specific connection only.</p>
<p>The signature of handler binding methods is the same for endpoints and connections. The format is: <code>set_*_handler(...)</code>. Where * is the name of the handler. For example, <code>set_open_handler(...)</code> will set the handler to be called when a new connection is open. <code>set_fail_handler(...)</code> will set the handler to be called when a connection fails to connect.</p>
<p>All handlers take one argument, a callable type that can be converted to a <code>std::function</code> with the correct count and type of arguments. You can pass free functions, functors, and Lambdas with matching argument lists as handlers. In addition, you can use <code>std::bind</code> (or <code>boost::bind</code>) to register functions with non-matching argument lists. This is useful for passing additional parameters not present in the handler signature or member functions that need to carry a 'this' pointer.</p>
<p>The function signature of each handler can be looked up in the list above in the manual. In general, all handlers include the <code>connection_hdl</code> identifying which connection this even is associated with as the first parameter. Some handlers (such as the message handler) include additional parameters. Most handlers have a void return value but some (<code>validate</code>, <code>ping</code>, <code>tls_init</code>) do not. The specific meanings of the return values are documented in the handler list linked above. </p>
</blockquote>
<h3>Step 3</h3>
<p><em>error handling</em></p>
<h3>Step 4</h3>
<p><em>Set up open and close handlers and a connection data structure</em></p>
<h3>Step 5</h3>
<p><em>Change the message handler for connections based on URI and add a validate handler to reject invalid URIs</em></p>
<h3>Step 6</h3>
<p><em>Add some Admin commands (report total clients, cleanly shut down server)</em></p>
<h3>Step 7</h3>
<p><em>Add some Broadcast commands</em></p>
<h3>Step 8</h3>
<p><em>Add TLS</em> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
