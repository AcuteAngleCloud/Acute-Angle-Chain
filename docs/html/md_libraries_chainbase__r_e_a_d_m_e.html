<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AcuteAngleChain: ChainBase - a fast version controlled, transactional database</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="aac-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AcuteAngleChain
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ChainBase - a fast version controlled, transactional database </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ChainBase is designed to meet the demanding requirments of blockchain applications, but is suitable for use in any application that requires a robust transactional database with the ability have near-infinate levels of undo history.</p>
<p>While chainbase was designed for blockchain applications, it is suitable for any program that needs to persist complex application state with the ability to undo.</p>
<h2>Features</h2>
<ul>
<li>Supports multiple objects (tables) with multiple indicies (based upon boost::multi_index_container)</li>
<li>State is persistant and sharable among multiple processes</li>
<li>Nested Transactional Writes with ability to undo changes</li>
</ul>
<h2>Dependencies</h2>
<ul>
<li>c++11</li>
<li><a href="http://www.boost.org/">Boost</a></li>
<li>CMake Build Process</li>
<li>Supports Linux, Mac OS <a class="el" href="class_x.html">X</a> (no Windows Support)</li>
</ul>
<h2>Example Usage</h2>
<div class="fragment"><div class="line">enum tables {</div><div class="line">   book_table</div><div class="line">};</div><div class="line"></div><div class="line">/**</div><div class="line"> * Defines a &quot;table&quot; for storing books. This table is assigned a </div><div class="line"> * globally unique ID (book_table) and must inherit from chainbase::object&lt;&gt; which</div><div class="line"> * decorates the book type by defining &quot;id_type&quot; and &quot;type_id&quot; </div><div class="line"> */</div><div class="line">struct book : public chainbase::object&lt;book_table, book&gt; {</div><div class="line"></div><div class="line">   /** defines a default constructor for types that don&#39;t have</div><div class="line">     * members requiring dynamic memory allocation.</div><div class="line">     */</div><div class="line">   CHAINBASE_DEFAULT_CONSTRUCTOR( book )</div><div class="line"></div><div class="line">   id_type          id; ///&lt; this manditory member is a primary key</div><div class="line">   int pages        = 0;</div><div class="line">   int publish_date = 0;</div><div class="line">};</div><div class="line"></div><div class="line">struct by_id;</div><div class="line">struct by_pages;</div><div class="line">struct by_date;</div><div class="line"></div><div class="line">/**</div><div class="line"> * This is a relatively standard boost multi_index_container definition that has three </div><div class="line"> * requirements to be used withn a chainbase database:</div><div class="line"> *   - it must use chainbase::allocator&lt;T&gt; </div><div class="line"> *   - the first index must be on the primary key (id) and must be unique (hashed or ordered)</div><div class="line"> */</div><div class="line">typedef multi_index_container&lt;</div><div class="line">  book,</div><div class="line">  indexed_by&lt;</div><div class="line">     ordered_unique&lt; tag&lt;by_id&gt;, member&lt;book,book::id_type,&amp;book::id&gt; &gt;, ///&lt; required </div><div class="line">     ordered_non_unique&lt; tag&lt;by_pages&gt;, BOOST_MULTI_INDEX_MEMBER(book,int,pages) &gt;,</div><div class="line">     ordered_non_unique&lt; tag&lt;by_date&gt;, BOOST_MULTI_INDEX_MEMBER(book,int,publish_date) &gt;</div><div class="line">  &gt;,</div><div class="line">  chainbase::allocator&lt;book&gt; ///&lt; required for use with chainbase::database</div><div class="line">&gt; book_index;</div><div class="line"></div><div class="line">/**</div><div class="line">    This simple program will open database_dir and add two new books every time</div><div class="line">    it is run and then print out all of the books in the database.</div><div class="line"> */</div><div class="line">int main( int argc, char** argv ) {</div><div class="line">   chainbase::database db;</div><div class="line">   db.open( &quot;database_dir&quot;, database::read_write, 1024*1024*8 ); /// open or create a database with 8MB capacity</div><div class="line">   db.add_index&lt; book_index &gt;(); /// open or create the book_index </div><div class="line"></div><div class="line"></div><div class="line">   const auto&amp; book_idx = db.get_index&lt;book_index&gt;().indicies();</div><div class="line"></div><div class="line">   /**</div><div class="line">      Returns a const reference to the book, this pointer will remain</div><div class="line">      valid until the book is removed from the database.</div><div class="line">    */</div><div class="line">   const auto&amp; new_book300 = db.create&lt;book&gt;( [&amp;]( book&amp; b ) {</div><div class="line">       b.pages = 300+book_idx.size();</div><div class="line">   } );</div><div class="line">   const auto&amp; new_book400 = db.create&lt;book&gt;( [&amp;]( book&amp; b ) {</div><div class="line">       b.pages = 300+book_idx.size();</div><div class="line">   } );</div><div class="line"></div><div class="line">   /**</div><div class="line">      You modify a book by passing in a lambda that receives a</div><div class="line">      non-const reference to the book you wish to modify. </div><div class="line">   */</div><div class="line">   db.modify( new_book300, [&amp;]( book&amp; b ) {</div><div class="line">      b.pages++;</div><div class="line">   });</div><div class="line"></div><div class="line">   for( const auto&amp; b : book_idx ) {</div><div class="line">      std::cout &lt;&lt; b.pages &lt;&lt; &quot;\n&quot;;</div><div class="line">   }</div><div class="line"></div><div class="line">   auto itr = book_idx.get&lt;by_pages&gt;().lower_bound( 100 );</div><div class="line">   if( itr != book_idx.get&lt;by_pages&gt;().end() ) {</div><div class="line">      std::cout &lt;&lt; itr-&gt;pages;</div><div class="line">   }</div><div class="line"></div><div class="line">   db.remove( new_book400 );</div><div class="line"></div><div class="line">   return 0;</div><div class="line">}</div></div><!-- fragment --><h2>Concurrent Access</h2>
<p>By default ChainBase provides no synchronization and has the same concurrency restrictions as any boost::multi_index_container. This means that two or more threads may read the database at the same time, but all writes must be protected by a mutex. <br />
 Multiple processes may open the same database if care is taken to use interpocess locking on the database. <br />
 </p><h2>Persistance</h2>
<p>By default data is only flushed to disk upon request or when the program exits. So long as the program does not crash in the middle of a call to db.modify(), or db.create() the content of the database should remain in a consistant state. This means that you should minimize the complexity of the lambdas used to create and/or modify state.</p>
<p>If the operating system crashes or the computer loses power, then the database will be left in an undefined state depending upon which memory pages that operating system was able to sync to disk.</p>
<p>ChainBase was designed to be used with blockchain applications where an append-only log of blocks is used to secure state in the event of power loss. This block log can be replayed to regenerate the full database state. Dealing with OS crashes, loss of power, and logs, is beyond the scope of ChainBase.</p>
<h2>Portability</h2>
<p>The contents of the database file is dependent upon the memory layout of the computer and process that created the database. Moving the database to a machine that uses a different compiler, operating system, libraries, or build type (release vs debug) will result in undefined behavior. <br />
 If portability is desired, the developer will have to export the database to a suitable format.</p>
<h2>Background</h2>
<p>Blockchain applications depend upon a high performance database capable of millions of read/write operations per second. Additionally blockchains operate on the basis of "eventually consistant" which means that any changes made to the database are potentially reversible for an unknown amount of time depending upon the consenus protocol used.</p>
<p>Existing database such as <a href="https://github.com/libbitcoin/libbitcoin-database">libbitcoin Database</a> achieve high peformance using similar techniques (memory mapped files), but they are heavily specialised and do not implement the logic necessary for multiple indicies or undo history.</p>
<p>Databases such as LevelDB provide a simple Key/Value database, but suffer from poor performance relative to memory mapped file implementations. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
