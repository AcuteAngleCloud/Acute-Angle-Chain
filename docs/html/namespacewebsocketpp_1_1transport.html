<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Acute-Angle-Chain: websocketpp::transport Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="aac-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Acute-Angle-Chain
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewebsocketpp.html">websocketpp</a></li><li class="navelem"><a class="el" href="namespacewebsocketpp_1_1transport.html">transport</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">websocketpp::transport Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Transport policies provide network connectivity and timers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacewebsocketpp_1_1transport_1_1asio"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport_1_1asio.html">asio</a></td></tr>
<tr class="memdesc:namespacewebsocketpp_1_1transport_1_1asio"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport policy that uses asio. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewebsocketpp_1_1transport_1_1debug"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport_1_1debug.html">debug</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewebsocketpp_1_1transport_1_1error"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport_1_1error.html">error</a></td></tr>
<tr class="memdesc:namespacewebsocketpp_1_1transport_1_1error"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic transport related errors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewebsocketpp_1_1transport_1_1iostream"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport_1_1iostream.html">iostream</a></td></tr>
<tr class="memdesc:namespacewebsocketpp_1_1transport_1_1iostream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport policy that uses STL iostream for I/O and does not support timers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewebsocketpp_1_1transport_1_1stub"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport_1_1stub.html">stub</a></td></tr>
<tr class="memdesc:namespacewebsocketpp_1_1transport_1_1stub"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stub transport policy that has no input or output. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwebsocketpp_1_1transport_1_1buffer.html">buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_a.html">A</a> simple utility buffer class.  <a href="structwebsocketpp_1_1transport_1_1buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeae75e675c1a334b3b33ab7120b480a5"><td class="memItemLeft" align="right" valign="top"><a id="aeae75e675c1a334b3b33ab7120b480a5"></a>
typedef lib::function&lt; void(lib::error_code const &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#aeae75e675c1a334b3b33ab7120b480a5">init_handler</a></td></tr>
<tr class="memdesc:aeae75e675c1a334b3b33ab7120b480a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the init hook. <br /></td></tr>
<tr class="separator:aeae75e675c1a334b3b33ab7120b480a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb"><td class="memItemLeft" align="right" valign="top"><a id="a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb"></a>
typedef lib::function&lt; void(lib::error_code const &amp;, size_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb">read_handler</a></td></tr>
<tr class="memdesc:a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the read method. <br /></td></tr>
<tr class="separator:a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf5d728159e7aa2bce2a0df947b1560"><td class="memItemLeft" align="right" valign="top"><a id="addf5d728159e7aa2bce2a0df947b1560"></a>
typedef lib::function&lt; void(lib::error_code const &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#addf5d728159e7aa2bce2a0df947b1560">write_handler</a></td></tr>
<tr class="memdesc:addf5d728159e7aa2bce2a0df947b1560"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the write method. <br /></td></tr>
<tr class="separator:addf5d728159e7aa2bce2a0df947b1560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946cc56ff41139f3002149c15fd87bc9"><td class="memItemLeft" align="right" valign="top"><a id="a946cc56ff41139f3002149c15fd87bc9"></a>
typedef lib::function&lt; void(lib::error_code const &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#a946cc56ff41139f3002149c15fd87bc9">timer_handler</a></td></tr>
<tr class="memdesc:a946cc56ff41139f3002149c15fd87bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the read method. <br /></td></tr>
<tr class="separator:a946cc56ff41139f3002149c15fd87bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39aff6fc4cb76f7df0d5322b734d156"><td class="memItemLeft" align="right" valign="top"><a id="af39aff6fc4cb76f7df0d5322b734d156"></a>
typedef lib::function&lt; void(lib::error_code const &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#af39aff6fc4cb76f7df0d5322b734d156">shutdown_handler</a></td></tr>
<tr class="memdesc:af39aff6fc4cb76f7df0d5322b734d156"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the shutdown method. <br /></td></tr>
<tr class="separator:af39aff6fc4cb76f7df0d5322b734d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8090563b066d7e8e31f7165be18dee51"><td class="memItemLeft" align="right" valign="top"><a id="a8090563b066d7e8e31f7165be18dee51"></a>
typedef lib::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#a8090563b066d7e8e31f7165be18dee51">interrupt_handler</a></td></tr>
<tr class="memdesc:a8090563b066d7e8e31f7165be18dee51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the interrupt method. <br /></td></tr>
<tr class="separator:a8090563b066d7e8e31f7165be18dee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658447b2e10f4c712dd792aad0e0c78"><td class="memItemLeft" align="right" valign="top"><a id="a6658447b2e10f4c712dd792aad0e0c78"></a>
typedef lib::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#a6658447b2e10f4c712dd792aad0e0c78">dispatch_handler</a></td></tr>
<tr class="memdesc:a6658447b2e10f4c712dd792aad0e0c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the dispatch method. <br /></td></tr>
<tr class="separator:a6658447b2e10f4c712dd792aad0e0c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9326ea831379368ee47841b2e46cb009"><td class="memItemLeft" align="right" valign="top"><a id="a9326ea831379368ee47841b2e46cb009"></a>
typedef lib::function&lt; void(lib::error_code const &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#a9326ea831379368ee47841b2e46cb009">accept_handler</a></td></tr>
<tr class="memdesc:a9326ea831379368ee47841b2e46cb009"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the accept method. <br /></td></tr>
<tr class="separator:a9326ea831379368ee47841b2e46cb009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac392fca34e946b48414278c0c3addfa5"><td class="memItemLeft" align="right" valign="top"><a id="ac392fca34e946b48414278c0c3addfa5"></a>
typedef lib::function&lt; void(lib::error_code const &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewebsocketpp_1_1transport.html#ac392fca34e946b48414278c0c3addfa5">connect_handler</a></td></tr>
<tr class="memdesc:ac392fca34e946b48414278c0c3addfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type and signature of the callback passed to the connect method. <br /></td></tr>
<tr class="separator:ac392fca34e946b48414278c0c3addfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transport policies provide network connectivity and timers. </p>
<h3>Connection Interface</h3>
<p>Transport connection components needs to provide:</p>
<p><b>init</b><br />
<code>void init(init_handler handler)</code><br />
Called once shortly after construction to give the policy the chance to perform one time initialization. When complete, the policy must call the supplied <code>init_handler</code> to continue setup. The handler takes one argument with the error code if any. If an error is returned here setup will fail and the connection will be aborted or terminated.</p>
<p>WebSocket++ will call init only once. The transport must call <code>handler</code> exactly once.</p>
<p><b>async_read_at_least</b><br />
<code>void async_read_at_least(size_t num_bytes, char *buf, size_t len, read_handler handler)</code><br />
start an async read for at least num_bytes and at most len bytes into buf. Call handler when done with number of bytes read.</p>
<p>WebSocket++ promises to have only one async_read_at_least in flight at a time. The transport must promise to only call read_handler once per async read.</p>
<p><b>async_write</b><br />
<code>void async_write(const char* buf, size_t len, write_handler handler)</code><br />
<code>void async_write(<a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;buffer&gt; &amp; bufs, write_handler handler)</code><br />
Start a write of all of the data in buf or bufs. In second case data is written sequentially and in place without copying anything to a temporary location.</p>
<p>Websocket++ promises to have only one async_write in flight at a time. The transport must promise to only call the write_handler once per async write</p>
<p><b>set_handle</b><br />
<code>void set_handle(connection_hdl hdl)</code><br />
Called by WebSocket++ to let this policy know the hdl to the connection. It may be stored for later use or ignored/discarded. This handle should be used if the policy adds any connection handlers. Connection handlers must be called with the handle as the first argument so that the handler code knows which connection generated the callback.</p>
<p><b>set_timer</b><br />
<code>timer_ptr set_timer(long duration, timer_handler handler)</code><br />
WebSocket++ uses the timers provided by the transport policy as the implementation of timers is often highly coupled with the implementation of the networking event loops.</p>
<p>Transport timer support is an optional feature. <a class="el" href="struct_a.html">A</a> transport method may elect to implement a dummy timer object and have this method return an empty pointer. If so, all timer related features of WebSocket++ core will be disabled. This includes many security features designed to prevent denial of service attacks. Use timer-free transport policies with caution.</p>
<p><b>get_remote_endpoint</b><br />
<code>std::string get_remote_endpoint()</code><br />
retrieve address of remote endpoint</p>
<p><b>is_secure</b><br />
<code>void is_secure()</code><br />
whether or not the connection to the remote endpoint is secure</p>
<p><b>dispatch</b><br />
<code>lib::error_code dispatch(dispatch_handler handler)</code>: invoke handler within the transport's event system if it uses one. Otherwise, this method should simply call <code>handler</code> immediately.</p>
<p><b>async_shutdown</b><br />
<code>void async_shutdown(shutdown_handler handler)</code><br />
Perform any cleanup necessary (if any). Call <code>handler</code> when complete.</p>
<h3>Endpoint Interface</h3>
<p>Transport endpoint components needs to provide:</p>
<p><b>init</b><br />
<code>lib::error_code init(transport_con_ptr tcon)</code><br />
init is called by an endpoint once for each newly created connection. It's purpose is to give the transport policy the chance to perform any transport specific initialization that couldn't be done via the default constructor.</p>
<p><b>is_secure</b><br />
<code>bool is_secure() const</code><br />
<a class="el" href="struct_test.html">Test</a> whether the transport component of this endpoint is capable of secure connections.</p>
<p><b>async_connect</b><br />
<code>void async_connect(transport_con_ptr tcon, uri_ptr location, connect_handler handler)</code><br />
Initiate a connection to <code>location</code> using the given connection <code>tcon</code>. <code>tcon</code> is a pointer to the transport connection component of the connection. When complete, <code>handler</code> should be called with the the connection's <code>connection_hdl</code> and any error that occurred.</p>
<p><b>init_logging</b> <code>void init_logging(alog_type * a, elog_type * e)</code><br />
Called once after construction to provide pointers to the endpoint's access and error loggers. These may be stored and used to log messages or ignored. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
