<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AcuteAngleChain: FAQ</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="aac-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AcuteAngleChain
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">index</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">FAQ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Dependency Management</h2>
<h3>Can WebSocket++ be used without Boost?</h3>
<p>Yes. WebSocket++ only uses Boost features as polyfills for C++11 language features and libraries. If you have a C++11 compiler and standard library you can use WebSocket++ without Boost. In most cases setting your build environment to use the C++11 (or later) language dialect is sufficient to enable this mode of use.</p>
<p>With less common compilers (and sometimes very recently release compilers) there may be specific issues with certain libraries that aren't automatically detected by the library. For these situations there are additional defines available to fine tune which C++11 libraries and features are used. TODO: more details about them.</p>
<p>For the iostream/raw transport the C++11 standard library is sufficient. For the Asio based transports, there is no C++11 library that provides the networking capabilaties that Asio does. As such even with a C++11 build system, you will need a standalone copy of Asio to use if Boost Asio is not available.</p>
<h3>Can WebSocket++ be used with standalone Asio</h3>
<p>Yes. The process is the same as used with standalone Asio itself. Define <code>ASIO_STANDALONE</code> before including Asio or WebSocket++ headers. You will need to download a copy of the Asio headers separately (<a href="http://www.think-async.com">http://www.think-async.com</a>) and make sure they are in your build system's include path.</p>
<h3>Can WebSocket++ be used without TLS or OpenSSL?</h3>
<p>Yes. When using the iostream/raw transport, there are no TLS features and OpenSSL is not required. When using the Asio transport TLS features are optional. You only need OpenSSL if you want to use TLS. You can only make or recieve encrypted connections (https/wss) if you have enabled TLS features.</p>
<p>Whether an Asio endpoint uses TLS or not is determined by its config template parameter. The default bundled <code><a class="el" href="structwebsocketpp_1_1config_1_1asio.html" title="Server config with asio transport and TLS disabled. ">websocketpp::config::asio</a></code> and <code><a class="el" href="structwebsocketpp_1_1config_1_1asio__client.html" title="Client config with asio transport and TLS disabled. ">websocketpp::config::asio_client</a></code> configs do not support TLS, the <code><a class="el" href="structwebsocketpp_1_1config_1_1asio__tls.html" title="Server config with asio transport and TLS enabled. ">websocketpp::config::asio_tls</a></code> and <code><a class="el" href="structwebsocketpp_1_1config_1_1asio__tls__client.html" title="Client config with asio transport and TLS enabled. ">websocketpp::config::asio_tls_client</a></code> do.</p>
<p>The <code>&lt;<a class="el" href="config_2asio_8hpp_source.html">websocketpp/config/asio.hpp</a>&gt;</code> and <code>&lt;<a class="el" href="asio__client_8hpp_source.html">websocketpp/config/asio_client.hpp</a>&gt;</code> headers will include both the TLS and non-TLS varients of their respective configs and require the presence of OpenSSL. The <code>&lt;<a class="el" href="asio__no__tls_8hpp_source.html">websocketpp/config/asio_no_tls.hpp</a>&gt;</code> and <code>&lt;<a class="el" href="asio__no__tls__client_8hpp_source.html">websocketpp/config/asio_no_tls_client.hpp</a>&gt;</code> headers will include only the non-TLS configs and do not require OpenSSL.</p>
<h2>Compression</h2>
<h3>How do I use permessage-deflate in version 0.6.0-permessagedeflate and 0.7.0?</h3>
<p>These versions of the library require a custom config to use the permessage-deflate extension. Here is a minimal example of such a custom config. You can also integrate these lines into an existing custom config.</p>
<p>Note that in these versions there is no fine grained control over which connections are compressed or not. Clients will request compression with the default settings and use it if the server supports it. Servers will accept whatever parameters clients request.</p>
<p>Outgoing messages by default will be compressed if compression was auto-negotiated during the handshake. There is an option to force a specific message to be sent uncompressed even if compression was negotiated. This may be useful for sending data that you know to be compressed already (images, zip files, etc).</p>
<p><b>Server Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;websocketpp/extensions/permessage_deflate/enabled.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>deflate_server_config : <span class="keyword">public</span> <a class="code" href="structwebsocketpp_1_1config_1_1asio.html">websocketpp::config::asio</a> {</div><div class="line">    <span class="comment">// ... additional custom config if you need it for other things</span></div><div class="line"></div><div class="line">    <span class="keyword">struct </span>permessage_deflate_config {};</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classwebsocketpp_1_1extensions_1_1permessage__deflate_1_1enabled.html">websocketpp::extensions::permessage_deflate::enabled</a></div><div class="line">        &lt;permessage_deflate_config&gt; permessage_deflate_type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classwebsocketpp_1_1server.html">websocketpp::server&lt;deflate_server_config&gt;</a> server_endpoint_type;</div></div><!-- fragment --><p><b>Client Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;websocketpp/extensions/permessage_deflate/enabled.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>deflate_client_config : <span class="keyword">public</span> <a class="code" href="structwebsocketpp_1_1config_1_1asio__client.html">websocketpp::config::asio_client</a> {</div><div class="line">    <span class="comment">// ... additional custom config if you need it for other things</span></div><div class="line"></div><div class="line">    <span class="keyword">struct </span>permessage_deflate_config {};</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classwebsocketpp_1_1extensions_1_1permessage__deflate_1_1enabled.html">websocketpp::extensions::permessage_deflate::enabled</a></div><div class="line">        &lt;permessage_deflate_config&gt; permessage_deflate_type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classwebsocketpp_1_1client.html">websocketpp::client&lt;deflate_client_config&gt;</a> client_endpoint_type;</div></div><!-- fragment --><h2>Security</h2>
<h3>Is it possible to terminate a malicious connection quickly, without tying up resources performing clean close steps,</h3>
<p>Yes. The library will automatically detect and terminate connections that violate the WebSocket protocol. In cases where the library believes the remote endpoint to be malicious or sufficiently broken to be unlikely to understand or process the closing handshake, it will be omited.</p>
<p>If your application detects conditions above the protocol level that you believe to be malicious, for example, if you recognize an IP from a known denial of service attack, you can close the connection with two different levels of urgency. Use the standard <code>websocketpp::endpoint::close</code> or <code><a class="el" href="classwebsocketpp_1_1connection.html#ae718e4fa8b2c37757d8abd71dae07dc9" title="Close the connection. ">websocketpp::connection::close</a></code> methods with one of the following special close codes:</p><ul>
<li><code>websocketpp::close::status::omit_handshake</code>: Omits the closing handshake, but cleanly closes the TCP connection.</li>
<li><code>websocketpp::close::status::force_tcp_drop</code>: Forcibly drop the TCP connection.</li>
</ul>
<p>Please note that usage of these disconnect methods results in a violation of the WebSocket protocol and may have negative reprocusions for the remote endpoint with respect to network timeouts. Please use caution when using them.</p>
<h2>Build Issues</h2>
<h3>Getting compile errors related to <code>std::chrono</code>, <code>boost::chrono</code>, <code>waitable_timer</code>, or <code>steady_clock</code></h3>
<p>Your build system may be confused about whether it is supposed to be using <code>boost::chrono</code> or <code>std::chrono</code>. Boost automatically detects this setup on some compilers but not others. Defining <code>BOOST_ASIO_HAS_STD_CHRONO</code> can help. See <a href="http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/overview/cpp2011/chrono.html">http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/overview/cpp2011/chrono.html</a> for more details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
