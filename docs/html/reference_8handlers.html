<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AcuteAngleChain: Handler Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="aac-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AcuteAngleChain
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Handler Reference </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Handlers allow WebSocket++ programs to receive notifications about events that happen in relation to their connections. Some handlers also behave as hooks that give the program a chance to modify state or adjust settings before the connection continues.</p>
<p>Handlers are registered by calling the appropriate <code>set_*_handler</code> method on either an endpoint or connection. The * refers to the name of the handler (as specified in the signature field below). For example, to set the open handler, call <code>set_open_handler(...)</code>.</p>
<p>Setting handlers on an endpoint will result in them being copied as the default handler to all new connections created by that endpoint. Changing an endpoint's handlers will not affect connections that are already in progress. This includes connections that are in the listening state. As such, it is important to set any endpoint handlers before you call <code>endpoint::start_accept</code> or else the handlers will not be attached to your first connection.</p>
<p>Setting handlers on a connection will result in the handler being changed for that connection only, starting at the next time that handler is called. This can be used to change the handler during a connection.</p>
<h2>Connection Handlers </h2>
<p>These handlers will be called at most once per connection in the order specified below.</p>
<h3>Socket Init Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Socket initialization  </td><td class="markdownTableBodyNone"><code>socket_init(connection_hdl, asio::ip::tcp::socket&amp;)</code>  </td><td class="markdownTableBodyNone">0.3.0 Asio Transport   </td></tr>
</table>
<p>This hook is triggered after the socket has been initialized but before a connection is established. It allows setting arbitrary socket options before connections are sent/recieved.</p>
<h3>TCP Pre-init Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TCP established, no data sent  </td><td class="markdownTableBodyNone"><code>tcp_pre_init(connection_hdl)</code>  </td><td class="markdownTableBodyNone">0.3.0 Asio Transport   </td></tr>
</table>
<p>This hook is triggered after the TCP connection is established, but before any pre-WebSocket-handshake operations have been run. Common pre-handshake operations include TLS handshakes and proxy connections.</p>
<h3>TCP Post-init Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Request for TLS context  </td><td class="markdownTableBodyNone"><code>tls_context_ptr tls_init(connection_hdl)</code>  </td><td class="markdownTableBodyNone">0.3.0 Asio Transport with TLS   </td></tr>
</table>
<p>This hook is triggered before the TLS handshake to request the TLS context to use. You must return a pointer to a configured TLS conext to continue. This provides the opportuinity to set up the TLS settings, certificates, etc.</p>
<h3>Validate Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hook to accept or reject a connection  </td><td class="markdownTableBodyNone"><code>bool validate(connection_hdl)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core, Server role only   </td></tr>
</table>
<p>This hook is triggered for servers during the opening handshake after the request has been processed but before the response has been sent. It gives a program the opportunity to inspect headers and other connection details and either accept or reject the connection. Validate happens before the open or fail handler.</p>
<p>Return true to accept the connection, false to reject. If no validate handler is registered, all connections will be accepted.</p>
<h3>Open Connection Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Successful new connection  </td><td class="markdownTableBodyNone"><code>open(connection_hdl)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core   </td></tr>
</table>
<p>Either open or fail will be called for each connection. Never both. All connections that begin with an open handler call will also have a matching close handler call when the connection ends.</p>
<h3>Fail Connection Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Connection failed (before opening)  </td><td class="markdownTableBodyNone"><code>fail(connection_hdl)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core   </td></tr>
</table>
<p>Either open or fail will be called for each connection. Never both. Connections that fail will never have a close handler called.</p>
<h3>Close Connection Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Connection closed (after opening)  </td><td class="markdownTableBodyNone"><code>close(connection_hdl)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core   </td></tr>
</table>
<p>Close will be called exactly once for every connection that open was called for. Close is not called for failed connections.</p>
<h2>Message Handlers </h2>
<p>These handers are called in response to incoming messages or message like events. They only will be called while the connection is in the open state.</p>
<h3>Message Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Data message recieved  </td><td class="markdownTableBodyNone"><code>message(connection_hdl, message_ptr)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core   </td></tr>
</table>
<p>Applies to all non-control messages, including both text and binary opcodes. The <code>message_ptr</code> type and its API depends on your endpoint type and its config.</p>
<h3>Ping Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Ping recieved  </td><td class="markdownTableBodyNone"><code>bool ping(connection_hdl, std::string)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core   </td></tr>
</table>
<p>Second (string) argument is the binary ping payload. Handler return value indicates whether or not to respond to the ping with a pong. If no ping handler is set, WebSocket++ will respond with a pong containing the same binary data as the ping (Per requirements in RFC6455).</p>
<h3>Pong Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pong recieved  </td><td class="markdownTableBodyNone"><code>pong(connection_hdl, std::string)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core   </td></tr>
</table>
<p>Second (string) argument is the binary pong payload.</p>
<h3>Pong Timeout Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Timed out while waiting for a pong  </td><td class="markdownTableBodyNone"><code>pong_timeout(connection_hdl, std::string)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core, transport with timer support   </td></tr>
</table>
<p>Triggered if there is no response to a ping after the configured duration. The second (string) argument is the binary payload of the unanswered ping.</p>
<h3>HTTP Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">HTTP request recieved  </td><td class="markdownTableBodyNone"><code>http(connection_hdl</code>  </td><td class="markdownTableBodyNone">0.3.0 Core, Server role only   </td></tr>
</table>
<p>Called when HTTP requests that are not WebSocket handshake upgrade requests are recieved. Allows responding to regular HTTP requests. If no handler is registered a 426/Upgrade Required error is returned.</p>
<h3>Interrupt Handler</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event  </th><th class="markdownTableHeadNone">Signature  </th><th class="markdownTableHeadNone">Availability   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Connection was manually interrupted  </td><td class="markdownTableBodyNone"><code>interrupt(connection_hdl)</code>  </td><td class="markdownTableBodyNone">0.3.0 Core   </td></tr>
</table>
<p>Interrupt events can be triggered by calling <code>endpoint::interrupt</code> or <code>connection::interrupt</code>. Interrupt is similar to a timer event with duration zero but with lower overhead. It is useful for single threaded programs to allow breaking up a very long handler into multiple parts and for multi threaded programs as a way for worker threads to signale to the main/network thread that an event is ready.</p>
<p>todo: write low and high watermark handlers </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
