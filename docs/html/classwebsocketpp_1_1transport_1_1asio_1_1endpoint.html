<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Acute-Angle-Chain: websocketpp::transport::asio::endpoint&lt; config &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="aac-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Acute-Angle-Chain
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewebsocketpp.html">websocketpp</a></li><li class="navelem"><a class="el" href="namespacewebsocketpp_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespacewebsocketpp_1_1transport_1_1asio.html">asio</a></li><li class="navelem"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">endpoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">websocketpp::transport::asio::endpoint&lt; config &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Asio based endpoint transport component.  
 <a href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="transport_2asio_2endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for websocketpp::transport::asio::endpoint&lt; config &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint__inherit__graph.png" border="0" usemap="#websocketpp_1_1transport_1_1asio_1_1endpoint_3_01config_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for websocketpp::transport::asio::endpoint&lt; config &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint__coll__graph.png" border="0" usemap="#websocketpp_1_1transport_1_1asio_1_1endpoint_3_01config_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a86283417bb35f13b9a1d9795f5fcf077"><td class="memItemLeft" align="right" valign="top"><a id="a86283417bb35f13b9a1d9795f5fcf077"></a>
typedef <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a86283417bb35f13b9a1d9795f5fcf077">type</a></td></tr>
<tr class="memdesc:a86283417bb35f13b9a1d9795f5fcf077"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of this endpoint transport component. <br /></td></tr>
<tr class="separator:a86283417bb35f13b9a1d9795f5fcf077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1979c2199a48526d5bc44651ffc72f3"><td class="memItemLeft" align="right" valign="top"><a id="aa1979c2199a48526d5bc44651ffc72f3"></a>
typedef <a class="el" href="classwebsocketpp_1_1concurrency_1_1none.html">config::concurrency_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#aa1979c2199a48526d5bc44651ffc72f3">concurrency_type</a></td></tr>
<tr class="memdesc:aa1979c2199a48526d5bc44651ffc72f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of the concurrency policy. <br /></td></tr>
<tr class="separator:aa1979c2199a48526d5bc44651ffc72f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13784d09af030a55e85faaf8f111fdc3"><td class="memItemLeft" align="right" valign="top"><a id="a13784d09af030a55e85faaf8f111fdc3"></a>
typedef <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html">config::socket_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a13784d09af030a55e85faaf8f111fdc3">socket_type</a></td></tr>
<tr class="memdesc:a13784d09af030a55e85faaf8f111fdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of the socket policy. <br /></td></tr>
<tr class="separator:a13784d09af030a55e85faaf8f111fdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa93730c801602b55b585121a2898c0"><td class="memItemLeft" align="right" valign="top"><a id="a2aa93730c801602b55b585121a2898c0"></a>
typedef <a class="el" href="classwebsocketpp_1_1log_1_1stub.html">config::elog_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a2aa93730c801602b55b585121a2898c0">elog_type</a></td></tr>
<tr class="memdesc:a2aa93730c801602b55b585121a2898c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of the error logging policy. <br /></td></tr>
<tr class="separator:a2aa93730c801602b55b585121a2898c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba708e66a47d4aae9a053d364585b81"><td class="memItemLeft" align="right" valign="top"><a id="acba708e66a47d4aae9a053d364585b81"></a>
typedef <a class="el" href="classwebsocketpp_1_1log_1_1stub.html">config::alog_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#acba708e66a47d4aae9a053d364585b81">alog_type</a></td></tr>
<tr class="memdesc:acba708e66a47d4aae9a053d364585b81"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of the access logging policy. <br /></td></tr>
<tr class="separator:acba708e66a47d4aae9a053d364585b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6f8cbdf8f2141915881a6d13779545"><td class="memItemLeft" align="right" valign="top"><a id="a0b6f8cbdf8f2141915881a6d13779545"></a>
typedef <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#a690393b3da13e389cf025f88a3d38f3f">socket_type::socket_con_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a0b6f8cbdf8f2141915881a6d13779545">socket_con_type</a></td></tr>
<tr class="memdesc:a0b6f8cbdf8f2141915881a6d13779545"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of the socket connection component. <br /></td></tr>
<tr class="separator:a0b6f8cbdf8f2141915881a6d13779545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fb719ac5393b320d98b77f346a4b34"><td class="memItemLeft" align="right" valign="top"><a id="a74fb719ac5393b320d98b77f346a4b34"></a>
typedef <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1connection.html#a2aa605c27a476eba644e062dc5bc4f6d">socket_con_type::ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a74fb719ac5393b320d98b77f346a4b34">socket_con_ptr</a></td></tr>
<tr class="memdesc:a74fb719ac5393b320d98b77f346a4b34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a shared pointer to the socket connection component. <br /></td></tr>
<tr class="separator:a74fb719ac5393b320d98b77f346a4b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f3102766fd3ba8230e99a2b0e00457"><td class="memItemLeft" align="right" valign="top">typedef asio::connection&lt; <a class="el" href="classconfig.html">config</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a75f3102766fd3ba8230e99a2b0e00457">transport_con_type</a></td></tr>
<tr class="separator:a75f3102766fd3ba8230e99a2b0e00457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fc306f32d15f92dd1b22366eaba62d"><td class="memItemLeft" align="right" valign="top">typedef transport_con_type::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a></td></tr>
<tr class="separator:ac5fc306f32d15f92dd1b22366eaba62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7e89c6427514628f551cf3f795b7e0"><td class="memItemLeft" align="right" valign="top"><a id="acc7e89c6427514628f551cf3f795b7e0"></a>
typedef lib::asio::io_service *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#acc7e89c6427514628f551cf3f795b7e0">io_service_ptr</a></td></tr>
<tr class="memdesc:acc7e89c6427514628f551cf3f795b7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a pointer to the ASIO io_service being used. <br /></td></tr>
<tr class="separator:acc7e89c6427514628f551cf3f795b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff1078ca1ea0fa4f47bbabcae255c16"><td class="memItemLeft" align="right" valign="top"><a id="aaff1078ca1ea0fa4f47bbabcae255c16"></a>
typedef lib::shared_ptr&lt; lib::asio::ip::tcp::acceptor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#aaff1078ca1ea0fa4f47bbabcae255c16">acceptor_ptr</a></td></tr>
<tr class="memdesc:aaff1078ca1ea0fa4f47bbabcae255c16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a shared pointer to the acceptor being used. <br /></td></tr>
<tr class="separator:aaff1078ca1ea0fa4f47bbabcae255c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1899396fa9d1439e00ca53c56676a5"><td class="memItemLeft" align="right" valign="top"><a id="aff1899396fa9d1439e00ca53c56676a5"></a>
typedef lib::shared_ptr&lt; lib::asio::ip::tcp::resolver &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#aff1899396fa9d1439e00ca53c56676a5">resolver_ptr</a></td></tr>
<tr class="memdesc:aff1899396fa9d1439e00ca53c56676a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a shared pointer to the resolver being used. <br /></td></tr>
<tr class="separator:aff1899396fa9d1439e00ca53c56676a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1802f5762009dbed117ff793fa87468f"><td class="memItemLeft" align="right" valign="top"><a id="a1802f5762009dbed117ff793fa87468f"></a>
typedef lib::shared_ptr&lt; lib::asio::steady_timer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a></td></tr>
<tr class="memdesc:a1802f5762009dbed117ff793fa87468f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of timer handle. <br /></td></tr>
<tr class="separator:a1802f5762009dbed117ff793fa87468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac730e8330bb982f9144127e9d66d0a23"><td class="memItemLeft" align="right" valign="top"><a id="ac730e8330bb982f9144127e9d66d0a23"></a>
typedef lib::shared_ptr&lt; lib::asio::io_service::work &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac730e8330bb982f9144127e9d66d0a23">work_ptr</a></td></tr>
<tr class="memdesc:ac730e8330bb982f9144127e9d66d0a23"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a shared pointer to an io_service work object. <br /></td></tr>
<tr class="separator:ac730e8330bb982f9144127e9d66d0a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html">websocketpp::transport::asio::tls_socket::endpoint</a></td></tr>
<tr class="memitem:adc98054310e74703eb102760e85f5cd9 inherit pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memItemLeft" align="right" valign="top"><a id="adc98054310e74703eb102760e85f5cd9"></a>
typedef <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html">endpoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#adc98054310e74703eb102760e85f5cd9">type</a></td></tr>
<tr class="memdesc:adc98054310e74703eb102760e85f5cd9 inherit pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of this endpoint socket component. <br /></td></tr>
<tr class="separator:adc98054310e74703eb102760e85f5cd9 inherit pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690393b3da13e389cf025f88a3d38f3f inherit pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memItemLeft" align="right" valign="top"><a id="a690393b3da13e389cf025f88a3d38f3f"></a>
typedef <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1connection.html">connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#a690393b3da13e389cf025f88a3d38f3f">socket_con_type</a></td></tr>
<tr class="memdesc:a690393b3da13e389cf025f88a3d38f3f inherit pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the corresponding connection socket component. <br /></td></tr>
<tr class="separator:a690393b3da13e389cf025f88a3d38f3f inherit pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0babd14e53524633840467d072710c3 inherit pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1connection.html#a2aa605c27a476eba644e062dc5bc4f6d">socket_con_type::ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#ad0babd14e53524633840467d072710c3">socket_con_ptr</a></td></tr>
<tr class="separator:ad0babd14e53524633840467d072710c3 inherit pub_types_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a31d10fbfbc4bc7693c5f1679bc35516f"><td class="memItemLeft" align="right" valign="top"><a id="a31d10fbfbc4bc7693c5f1679bc35516f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a31d10fbfbc4bc7693c5f1679bc35516f">is_secure</a> () const</td></tr>
<tr class="memdesc:a31d10fbfbc4bc7693c5f1679bc35516f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether or not the endpoint produces secure connections. <br /></td></tr>
<tr class="separator:a31d10fbfbc4bc7693c5f1679bc35516f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67da637106d3cfb40078b477e2579a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a67da637106d3cfb40078b477e2579a13">init_asio</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#acc7e89c6427514628f551cf3f795b7e0">io_service_ptr</a> ptr, lib::error_code &amp;ec)</td></tr>
<tr class="memdesc:a67da637106d3cfb40078b477e2579a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize asio transport with external io_service (exception free)  <a href="#a67da637106d3cfb40078b477e2579a13">More...</a><br /></td></tr>
<tr class="separator:a67da637106d3cfb40078b477e2579a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320fc4ea3a151afaf8b973ce32effd25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a320fc4ea3a151afaf8b973ce32effd25">init_asio</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#acc7e89c6427514628f551cf3f795b7e0">io_service_ptr</a> ptr)</td></tr>
<tr class="memdesc:a320fc4ea3a151afaf8b973ce32effd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize asio transport with external io_service  <a href="#a320fc4ea3a151afaf8b973ce32effd25">More...</a><br /></td></tr>
<tr class="separator:a320fc4ea3a151afaf8b973ce32effd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4249fd3e2663323ac29ef7935278de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a7b4249fd3e2663323ac29ef7935278de">init_asio</a> (lib::error_code &amp;ec)</td></tr>
<tr class="memdesc:a7b4249fd3e2663323ac29ef7935278de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize asio transport with internal io_service (exception free)  <a href="#a7b4249fd3e2663323ac29ef7935278de">More...</a><br /></td></tr>
<tr class="separator:a7b4249fd3e2663323ac29ef7935278de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22938eec899a9ab2b9ada2b76172f798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a22938eec899a9ab2b9ada2b76172f798">init_asio</a> ()</td></tr>
<tr class="memdesc:a22938eec899a9ab2b9ada2b76172f798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize asio transport with internal io_service.  <a href="#a22938eec899a9ab2b9ada2b76172f798">More...</a><br /></td></tr>
<tr class="separator:a22938eec899a9ab2b9ada2b76172f798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad334b214cf4800bb34aa09d7055e6464"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ad334b214cf4800bb34aa09d7055e6464">set_tcp_pre_init_handler</a> (tcp_init_handler h)</td></tr>
<tr class="memdesc:ad334b214cf4800bb34aa09d7055e6464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tcp pre init handler.  <a href="#ad334b214cf4800bb34aa09d7055e6464">More...</a><br /></td></tr>
<tr class="separator:ad334b214cf4800bb34aa09d7055e6464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497f353a5ec277355cd8b0caf893d1ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a497f353a5ec277355cd8b0caf893d1ce">set_tcp_init_handler</a> (tcp_init_handler h)</td></tr>
<tr class="memdesc:a497f353a5ec277355cd8b0caf893d1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tcp pre init handler (deprecated)  <a href="#a497f353a5ec277355cd8b0caf893d1ce">More...</a><br /></td></tr>
<tr class="separator:a497f353a5ec277355cd8b0caf893d1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605c9f8c671d783739c1e98c6c7fda9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a605c9f8c671d783739c1e98c6c7fda9d">set_tcp_post_init_handler</a> (tcp_init_handler h)</td></tr>
<tr class="memdesc:a605c9f8c671d783739c1e98c6c7fda9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tcp post init handler.  <a href="#a605c9f8c671d783739c1e98c6c7fda9d">More...</a><br /></td></tr>
<tr class="separator:a605c9f8c671d783739c1e98c6c7fda9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bb0d01c277b7cfcb6f69215a36b216"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a60bb0d01c277b7cfcb6f69215a36b216">set_listen_backlog</a> (int backlog)</td></tr>
<tr class="memdesc:a60bb0d01c277b7cfcb6f69215a36b216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum length of the queue of pending connections.  <a href="#a60bb0d01c277b7cfcb6f69215a36b216">More...</a><br /></td></tr>
<tr class="separator:a60bb0d01c277b7cfcb6f69215a36b216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491d13d6e1ad0edc5843e41b06fa4e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a491d13d6e1ad0edc5843e41b06fa4e0c">set_reuse_addr</a> (bool value)</td></tr>
<tr class="memdesc:a491d13d6e1ad0edc5843e41b06fa4e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to use the SO_REUSEADDR flag when opening listening sockets.  <a href="#a491d13d6e1ad0edc5843e41b06fa4e0c">More...</a><br /></td></tr>
<tr class="separator:a491d13d6e1ad0edc5843e41b06fa4e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97efb3c1915ae8cc38ef92ff9514ebd4"><td class="memItemLeft" align="right" valign="top">lib::asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a97efb3c1915ae8cc38ef92ff9514ebd4">get_io_service</a> ()</td></tr>
<tr class="memdesc:a97efb3c1915ae8cc38ef92ff9514ebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the endpoint's io_service.  <a href="#a97efb3c1915ae8cc38ef92ff9514ebd4">More...</a><br /></td></tr>
<tr class="separator:a97efb3c1915ae8cc38ef92ff9514ebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4147ba098fc2f1669d2f880b47917342"><td class="memItemLeft" align="right" valign="top">lib::asio::ip::tcp::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a4147ba098fc2f1669d2f880b47917342">get_local_endpoint</a> (lib::asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a4147ba098fc2f1669d2f880b47917342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local TCP endpoint.  <a href="#a4147ba098fc2f1669d2f880b47917342">More...</a><br /></td></tr>
<tr class="separator:a4147ba098fc2f1669d2f880b47917342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36c2b22a7c2550663792472a728f615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac36c2b22a7c2550663792472a728f615">listen</a> (lib::asio::ip::tcp::endpoint const &amp;ep, lib::error_code &amp;ec)</td></tr>
<tr class="memdesc:ac36c2b22a7c2550663792472a728f615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up endpoint for listening manually (exception free)  <a href="#ac36c2b22a7c2550663792472a728f615">More...</a><br /></td></tr>
<tr class="separator:ac36c2b22a7c2550663792472a728f615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d7708b939531c5c803e3b148a9b009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ab3d7708b939531c5c803e3b148a9b009">listen</a> (lib::asio::ip::tcp::endpoint const &amp;ep)</td></tr>
<tr class="memdesc:ab3d7708b939531c5c803e3b148a9b009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up endpoint for listening manually.  <a href="#ab3d7708b939531c5c803e3b148a9b009">More...</a><br /></td></tr>
<tr class="separator:ab3d7708b939531c5c803e3b148a9b009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6813b9ecda67a13a78967f72e77b061"><td class="memTemplParams" colspan="2">template&lt;typename InternetProtocol &gt; </td></tr>
<tr class="memitem:ae6813b9ecda67a13a78967f72e77b061"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ae6813b9ecda67a13a78967f72e77b061">listen</a> (InternetProtocol const &amp;internet_protocol, uint16_t port, lib::error_code &amp;ec)</td></tr>
<tr class="memdesc:ae6813b9ecda67a13a78967f72e77b061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up endpoint for listening with protocol and port (exception free)  <a href="#ae6813b9ecda67a13a78967f72e77b061">More...</a><br /></td></tr>
<tr class="separator:ae6813b9ecda67a13a78967f72e77b061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08b16daae1fac46679245ec7d0c8952"><td class="memTemplParams" colspan="2">template&lt;typename InternetProtocol &gt; </td></tr>
<tr class="memitem:ad08b16daae1fac46679245ec7d0c8952"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ad08b16daae1fac46679245ec7d0c8952">listen</a> (InternetProtocol const &amp;internet_protocol, uint16_t port)</td></tr>
<tr class="memdesc:ad08b16daae1fac46679245ec7d0c8952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up endpoint for listening with protocol and port.  <a href="#ad08b16daae1fac46679245ec7d0c8952">More...</a><br /></td></tr>
<tr class="separator:ad08b16daae1fac46679245ec7d0c8952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7da6e2c944c3e1a087495b9d998dc8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ae7da6e2c944c3e1a087495b9d998dc8b">listen</a> (uint16_t port, lib::error_code &amp;ec)</td></tr>
<tr class="memdesc:ae7da6e2c944c3e1a087495b9d998dc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up endpoint for listening on a port (exception free)  <a href="#ae7da6e2c944c3e1a087495b9d998dc8b">More...</a><br /></td></tr>
<tr class="separator:ae7da6e2c944c3e1a087495b9d998dc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c1e2bb6edbfbfc46d387015e528117"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a80c1e2bb6edbfbfc46d387015e528117">listen</a> (uint16_t port)</td></tr>
<tr class="memdesc:a80c1e2bb6edbfbfc46d387015e528117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up endpoint for listening on a port.  <a href="#a80c1e2bb6edbfbfc46d387015e528117">More...</a><br /></td></tr>
<tr class="separator:a80c1e2bb6edbfbfc46d387015e528117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85606665cc9c948194076c2377cb61c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a85606665cc9c948194076c2377cb61c0">listen</a> (std::string const &amp;host, std::string const &amp;service, lib::error_code &amp;ec)</td></tr>
<tr class="memdesc:a85606665cc9c948194076c2377cb61c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up endpoint for listening on a host and service (exception free)  <a href="#a85606665cc9c948194076c2377cb61c0">More...</a><br /></td></tr>
<tr class="separator:a85606665cc9c948194076c2377cb61c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69ca2f648f48c7616ad1df614d88d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ad69ca2f648f48c7616ad1df614d88d67">listen</a> (std::string const &amp;host, std::string const &amp;service)</td></tr>
<tr class="memdesc:ad69ca2f648f48c7616ad1df614d88d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up endpoint for listening on a host and service.  <a href="#ad69ca2f648f48c7616ad1df614d88d67">More...</a><br /></td></tr>
<tr class="separator:ad69ca2f648f48c7616ad1df614d88d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da87d3a3e8ee8279fe59eb0385d81e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a0da87d3a3e8ee8279fe59eb0385d81e3">stop_listening</a> (lib::error_code &amp;ec)</td></tr>
<tr class="memdesc:a0da87d3a3e8ee8279fe59eb0385d81e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop listening (exception free)  <a href="#a0da87d3a3e8ee8279fe59eb0385d81e3">More...</a><br /></td></tr>
<tr class="separator:a0da87d3a3e8ee8279fe59eb0385d81e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ae00e12a34475a1950d69f5b9da507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#af4ae00e12a34475a1950d69f5b9da507">stop_listening</a> ()</td></tr>
<tr class="memdesc:af4ae00e12a34475a1950d69f5b9da507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop listening.  <a href="#af4ae00e12a34475a1950d69f5b9da507">More...</a><br /></td></tr>
<tr class="separator:af4ae00e12a34475a1950d69f5b9da507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33506cbd90a184cdf1a0424ec2d0619"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#af33506cbd90a184cdf1a0424ec2d0619">is_listening</a> () const</td></tr>
<tr class="memdesc:af33506cbd90a184cdf1a0424ec2d0619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the endpoint is listening.  <a href="#af33506cbd90a184cdf1a0424ec2d0619">More...</a><br /></td></tr>
<tr class="separator:af33506cbd90a184cdf1a0424ec2d0619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c457ea6734a1d8aafe6c6f364996dfe"><td class="memItemLeft" align="right" valign="top"><a id="a5c457ea6734a1d8aafe6c6f364996dfe"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a5c457ea6734a1d8aafe6c6f364996dfe">run</a> ()</td></tr>
<tr class="memdesc:a5c457ea6734a1d8aafe6c6f364996dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps the run method of the internal io_service object <br /></td></tr>
<tr class="separator:a5c457ea6734a1d8aafe6c6f364996dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b42e739e095b5ec489b59a655b2242"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a06b42e739e095b5ec489b59a655b2242">run_one</a> ()</td></tr>
<tr class="memdesc:a06b42e739e095b5ec489b59a655b2242"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps the run_one method of the internal io_service object  <a href="#a06b42e739e095b5ec489b59a655b2242">More...</a><br /></td></tr>
<tr class="separator:a06b42e739e095b5ec489b59a655b2242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaf6de5a0a7f868c60f5d611a8e399c"><td class="memItemLeft" align="right" valign="top"><a id="a5aaf6de5a0a7f868c60f5d611a8e399c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a5aaf6de5a0a7f868c60f5d611a8e399c">stop</a> ()</td></tr>
<tr class="memdesc:a5aaf6de5a0a7f868c60f5d611a8e399c"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps the stop method of the internal io_service object <br /></td></tr>
<tr class="separator:a5aaf6de5a0a7f868c60f5d611a8e399c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73831b3e81e61cd95bfbfab799a41b7"><td class="memItemLeft" align="right" valign="top"><a id="aa73831b3e81e61cd95bfbfab799a41b7"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#aa73831b3e81e61cd95bfbfab799a41b7">poll</a> ()</td></tr>
<tr class="memdesc:aa73831b3e81e61cd95bfbfab799a41b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps the poll method of the internal io_service object <br /></td></tr>
<tr class="separator:aa73831b3e81e61cd95bfbfab799a41b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae413ac572300c418cfd822845960cc6c"><td class="memItemLeft" align="right" valign="top"><a id="ae413ac572300c418cfd822845960cc6c"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ae413ac572300c418cfd822845960cc6c">poll_one</a> ()</td></tr>
<tr class="memdesc:ae413ac572300c418cfd822845960cc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps the poll_one method of the internal io_service object <br /></td></tr>
<tr class="separator:ae413ac572300c418cfd822845960cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79a1a69f86df035471ccdc9f4aea351"><td class="memItemLeft" align="right" valign="top"><a id="ac79a1a69f86df035471ccdc9f4aea351"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac79a1a69f86df035471ccdc9f4aea351">reset</a> ()</td></tr>
<tr class="memdesc:ac79a1a69f86df035471ccdc9f4aea351"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps the reset method of the internal io_service object <br /></td></tr>
<tr class="separator:ac79a1a69f86df035471ccdc9f4aea351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633264e7fd0ab7623cac336f2eb85aa0"><td class="memItemLeft" align="right" valign="top"><a id="a633264e7fd0ab7623cac336f2eb85aa0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a633264e7fd0ab7623cac336f2eb85aa0">stopped</a> () const</td></tr>
<tr class="memdesc:a633264e7fd0ab7623cac336f2eb85aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps the stopped method of the internal io_service object <br /></td></tr>
<tr class="separator:a633264e7fd0ab7623cac336f2eb85aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a707078d482c141edf0a8cdd0bc6345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a5a707078d482c141edf0a8cdd0bc6345">start_perpetual</a> ()</td></tr>
<tr class="memdesc:a5a707078d482c141edf0a8cdd0bc6345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the endpoint as perpetual, stopping it from exiting when empty.  <a href="#a5a707078d482c141edf0a8cdd0bc6345">More...</a><br /></td></tr>
<tr class="separator:a5a707078d482c141edf0a8cdd0bc6345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf8c9ef3f41be6968674bd704dc23b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#aaaf8c9ef3f41be6968674bd704dc23b0">stop_perpetual</a> ()</td></tr>
<tr class="memdesc:aaaf8c9ef3f41be6968674bd704dc23b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the endpoint's perpetual flag, allowing it to exit when empty.  <a href="#aaaf8c9ef3f41be6968674bd704dc23b0">More...</a><br /></td></tr>
<tr class="separator:aaaf8c9ef3f41be6968674bd704dc23b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63525bd209bb3dabf373b9b72d37e78e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a63525bd209bb3dabf373b9b72d37e78e">set_timer</a> (long duration, <a class="el" href="namespacewebsocketpp_1_1transport.html#a946cc56ff41139f3002149c15fd87bc9">timer_handler</a> callback)</td></tr>
<tr class="memdesc:a63525bd209bb3dabf373b9b72d37e78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call back a function after a period of time.  <a href="#a63525bd209bb3dabf373b9b72d37e78e">More...</a><br /></td></tr>
<tr class="separator:a63525bd209bb3dabf373b9b72d37e78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5345d9bbde4333d7b4b4858a4816e596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a5345d9bbde4333d7b4b4858a4816e596">handle_timer</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a>, <a class="el" href="namespacewebsocketpp_1_1transport.html#a946cc56ff41139f3002149c15fd87bc9">timer_handler</a> callback, lib::asio::error_code const &amp;ec)</td></tr>
<tr class="memdesc:a5345d9bbde4333d7b4b4858a4816e596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer handler.  <a href="#a5345d9bbde4333d7b4b4858a4816e596">More...</a><br /></td></tr>
<tr class="separator:a5345d9bbde4333d7b4b4858a4816e596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24b2ea11e8ce90b6101c1ab56d7fe48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ae24b2ea11e8ce90b6101c1ab56d7fe48">async_accept</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a> tcon, <a class="el" href="namespacewebsocketpp_1_1transport.html#a9326ea831379368ee47841b2e46cb009">accept_handler</a> callback, lib::error_code &amp;ec)</td></tr>
<tr class="memdesc:ae24b2ea11e8ce90b6101c1ab56d7fe48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept the next connection attempt and assign it to con (exception free)  <a href="#ae24b2ea11e8ce90b6101c1ab56d7fe48">More...</a><br /></td></tr>
<tr class="separator:ae24b2ea11e8ce90b6101c1ab56d7fe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e559e38bf344d60706f106db8b15d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a7e559e38bf344d60706f106db8b15d50">async_accept</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a> tcon, <a class="el" href="namespacewebsocketpp_1_1transport.html#a9326ea831379368ee47841b2e46cb009">accept_handler</a> callback)</td></tr>
<tr class="memdesc:a7e559e38bf344d60706f106db8b15d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept the next connection attempt and assign it to con.  <a href="#a7e559e38bf344d60706f106db8b15d50">More...</a><br /></td></tr>
<tr class="separator:a7e559e38bf344d60706f106db8b15d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html">websocketpp::transport::asio::tls_socket::endpoint</a></td></tr>
<tr class="memitem:aaaf0047506bbbd83d2da026970fc3bf8 inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#aaaf0047506bbbd83d2da026970fc3bf8">is_secure</a> () const</td></tr>
<tr class="memdesc:aaaf0047506bbbd83d2da026970fc3bf8 inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the endpoint creates secure connections.  <a href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#aaaf0047506bbbd83d2da026970fc3bf8">More...</a><br /></td></tr>
<tr class="separator:aaaf0047506bbbd83d2da026970fc3bf8 inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9466b3c3169eb1757ca64a1462ac86e inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#ae9466b3c3169eb1757ca64a1462ac86e">set_socket_init_handler</a> (<a class="el" href="namespacewebsocketpp_1_1transport_1_1asio_1_1tls__socket.html#a0ec24de8bf054a4bc6f6c018e743efea">socket_init_handler</a> h)</td></tr>
<tr class="memdesc:ae9466b3c3169eb1757ca64a1462ac86e inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket init handler.  <a href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#ae9466b3c3169eb1757ca64a1462ac86e">More...</a><br /></td></tr>
<tr class="separator:ae9466b3c3169eb1757ca64a1462ac86e inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8973ceabe2423f535f6cfd2f7cbd53 inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#aaa8973ceabe2423f535f6cfd2f7cbd53">set_tls_init_handler</a> (<a class="el" href="namespacewebsocketpp_1_1transport_1_1asio_1_1tls__socket.html#a6fe279813cc19b05a3897d20f10f16d2">tls_init_handler</a> h)</td></tr>
<tr class="memdesc:aaa8973ceabe2423f535f6cfd2f7cbd53 inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set TLS init handler.  <a href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#aaa8973ceabe2423f535f6cfd2f7cbd53">More...</a><br /></td></tr>
<tr class="separator:aaa8973ceabe2423f535f6cfd2f7cbd53 inherit pub_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a26ad1ad26277ed99a691559e69d47932"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a26ad1ad26277ed99a691559e69d47932">init_logging</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#acba708e66a47d4aae9a053d364585b81">alog_type</a> *a, <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a2aa93730c801602b55b585121a2898c0">elog_type</a> *e)</td></tr>
<tr class="memdesc:a26ad1ad26277ed99a691559e69d47932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize logging.  <a href="#a26ad1ad26277ed99a691559e69d47932">More...</a><br /></td></tr>
<tr class="separator:a26ad1ad26277ed99a691559e69d47932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8154dd7191c0d8df984a202bc2e54cf7"><td class="memItemLeft" align="right" valign="top"><a id="a8154dd7191c0d8df984a202bc2e54cf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>handle_accept</b> (<a class="el" href="namespacewebsocketpp_1_1transport.html#a9326ea831379368ee47841b2e46cb009">accept_handler</a> callback, lib::asio::error_code const &amp;asio_ec)</td></tr>
<tr class="separator:a8154dd7191c0d8df984a202bc2e54cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca12e4d72c691e6cc1ce1f5316e3243"><td class="memItemLeft" align="right" valign="top"><a id="a1ca12e4d72c691e6cc1ce1f5316e3243"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1ca12e4d72c691e6cc1ce1f5316e3243">async_connect</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a> tcon, <a class="el" href="namespacewebsocketpp.html#aae370ea5ac83a8ece7712cb39fc23f5b">uri_ptr</a> u, <a class="el" href="namespacewebsocketpp_1_1transport.html#ac392fca34e946b48414278c0c3addfa5">connect_handler</a> cb)</td></tr>
<tr class="memdesc:a1ca12e4d72c691e6cc1ce1f5316e3243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a new connection. <br /></td></tr>
<tr class="separator:a1ca12e4d72c691e6cc1ce1f5316e3243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac240587f91cf837babbbb7c48b3cff40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac240587f91cf837babbbb7c48b3cff40">handle_resolve_timeout</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a>, <a class="el" href="namespacewebsocketpp_1_1transport.html#ac392fca34e946b48414278c0c3addfa5">connect_handler</a> callback, lib::error_code const &amp;ec)</td></tr>
<tr class="memdesc:ac240587f91cf837babbbb7c48b3cff40"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS resolution timeout handler.  <a href="#ac240587f91cf837babbbb7c48b3cff40">More...</a><br /></td></tr>
<tr class="separator:ac240587f91cf837babbbb7c48b3cff40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ded7b145e9d358747b7e0c0099594e"><td class="memItemLeft" align="right" valign="top"><a id="a97ded7b145e9d358747b7e0c0099594e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>handle_resolve</b> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a> tcon, <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a> dns_timer, <a class="el" href="namespacewebsocketpp_1_1transport.html#ac392fca34e946b48414278c0c3addfa5">connect_handler</a> callback, lib::asio::error_code const &amp;ec, lib::asio::ip::tcp::resolver::iterator iterator)</td></tr>
<tr class="separator:a97ded7b145e9d358747b7e0c0099594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf26b0ddc55fd6d223fd74be9e25d961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#adf26b0ddc55fd6d223fd74be9e25d961">handle_connect_timeout</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a> tcon, <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a>, <a class="el" href="namespacewebsocketpp_1_1transport.html#ac392fca34e946b48414278c0c3addfa5">connect_handler</a> callback, lib::error_code const &amp;ec)</td></tr>
<tr class="memdesc:adf26b0ddc55fd6d223fd74be9e25d961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asio connect timeout handler.  <a href="#adf26b0ddc55fd6d223fd74be9e25d961">More...</a><br /></td></tr>
<tr class="separator:adf26b0ddc55fd6d223fd74be9e25d961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2dd1fcad6099397b53e5f6ede001a0"><td class="memItemLeft" align="right" valign="top"><a id="a1d2dd1fcad6099397b53e5f6ede001a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>handle_connect</b> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a> tcon, <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a> con_timer, <a class="el" href="namespacewebsocketpp_1_1transport.html#ac392fca34e946b48414278c0c3addfa5">connect_handler</a> callback, lib::asio::error_code const &amp;ec)</td></tr>
<tr class="separator:a1d2dd1fcad6099397b53e5f6ede001a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756059ab3ecd99d7c2a845b40729c7c8"><td class="memItemLeft" align="right" valign="top">lib::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a756059ab3ecd99d7c2a845b40729c7c8">init</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a> tcon)</td></tr>
<tr class="memdesc:a756059ab3ecd99d7c2a845b40729c7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a connection.  <a href="#a756059ab3ecd99d7c2a845b40729c7c8">More...</a><br /></td></tr>
<tr class="separator:a756059ab3ecd99d7c2a845b40729c7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html">websocketpp::transport::asio::tls_socket::endpoint</a></td></tr>
<tr class="memitem:a3fcd99c817947b9e23f0438c976edc64 inherit pro_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memItemLeft" align="right" valign="top">lib::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#a3fcd99c817947b9e23f0438c976edc64">init</a> (<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#ad0babd14e53524633840467d072710c3">socket_con_ptr</a> scon)</td></tr>
<tr class="memdesc:a3fcd99c817947b9e23f0438c976edc64 inherit pro_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a connection.  <a href="classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint.html#a3fcd99c817947b9e23f0438c976edc64">More...</a><br /></td></tr>
<tr class="separator:a3fcd99c817947b9e23f0438c976edc64 inherit pro_methods_classwebsocketpp_1_1transport_1_1asio_1_1tls__socket_1_1endpoint"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename config&gt;<br />
class websocketpp::transport::asio::endpoint&lt; config &gt;</h3>

<p>Asio based endpoint transport component. </p>
<p><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html" title="Asio based endpoint transport component. ">transport::asio::endpoint</a> implements an endpoint transport component using Asio. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac5fc306f32d15f92dd1b22366eaba62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fc306f32d15f92dd1b22366eaba62d">&#9670;&nbsp;</a></span>transport_con_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef transport_con_type::ptr <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_type.html">Type</a> of a shared pointer to the connection transport component associated with this endpoint transport component </p>

</div>
</div>
<a id="a75f3102766fd3ba8230e99a2b0e00457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f3102766fd3ba8230e99a2b0e00457">&#9670;&nbsp;</a></span>transport_con_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef asio::connection&lt;<a class="el" href="classconfig.html">config</a>&gt; <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::<a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a75f3102766fd3ba8230e99a2b0e00457">transport_con_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_type.html">Type</a> of the connection transport component associated with this endpoint transport component </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae24b2ea11e8ce90b6101c1ab56d7fe48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24b2ea11e8ce90b6101c1ab56d7fe48">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a>&#160;</td>
          <td class="paramname"><em>tcon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#a9326ea831379368ee47841b2e46cb009">accept_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept the next connection attempt and assign it to con (exception free) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcon</td><td>The connection to accept into. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call when the operation is complete. </td></tr>
    <tr><td class="paramname">ec</td><td><a class="el" href="struct_a.html">A</a> status code indicating an error, if any. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ae24b2ea11e8ce90b6101c1ab56d7fe48_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ae24b2ea11e8ce90b6101c1ab56d7fe48_cgraph" alt=""/></div>
<!-- MAP 2 -->
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ae24b2ea11e8ce90b6101c1ab56d7fe48_icgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ae24b2ea11e8ce90b6101c1ab56d7fe48_icgraph" alt=""/></div>
<!-- MAP 3 -->
</div>

</div>
</div>
<a id="a7e559e38bf344d60706f106db8b15d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e559e38bf344d60706f106db8b15d50">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a>&#160;</td>
          <td class="paramname"><em>tcon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#a9326ea831379368ee47841b2e46cb009">accept_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept the next connection attempt and assign it to con. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcon</td><td>The connection to accept into. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call when the operation is complete. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a7e559e38bf344d60706f106db8b15d50_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a7e559e38bf344d60706f106db8b15d50_cgraph" alt=""/></div>
<!-- MAP 4 -->
</div>

</div>
</div>
<a id="a97efb3c1915ae8cc38ef92ff9514ebd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97efb3c1915ae8cc38ef92ff9514ebd4">&#9670;&nbsp;</a></span>get_io_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::asio::io_service&amp; <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a reference to the endpoint's io_service. </p>
<p>The io_service may be an internal or external one. This may be used to call methods of the io_service that are not explicitly wrapped by the endpoint.</p>
<p>This method is only valid after the endpoint has been initialized with <code>init_asio</code>. No error will be returned if it isn't.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a.html">A</a> reference to the endpoint's io_service </dd></dl>

</div>
</div>
<a id="a4147ba098fc2f1669d2f880b47917342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4147ba098fc2f1669d2f880b47917342">&#9670;&nbsp;</a></span>get_local_endpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::asio::ip::tcp::endpoint <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::get_local_endpoint </td>
          <td>(</td>
          <td class="paramtype">lib::asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local TCP endpoint. </p>
<p>Extracts the local endpoint from the acceptor. This represents the address that WebSocket++ is listening on.</p>
<p>Sets a bad_descriptor error if the acceptor is not currently listening or otherwise unavailable.</p>
<dl class="section since"><dt>Since</dt><dd>0.7.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local endpoint </dd></dl>

</div>
</div>
<a id="adf26b0ddc55fd6d223fd74be9e25d961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf26b0ddc55fd6d223fd74be9e25d961">&#9670;&nbsp;</a></span>handle_connect_timeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::handle_connect_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a>&#160;</td>
          <td class="paramname"><em>tcon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#ac392fca34e946b48414278c0c3addfa5">connect_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asio connect timeout handler. </p>
<p>The timer pointer is included to ensure the timer isn't destroyed until after it has expired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcon</td><td><a class="el" href="struct_pointer.html">Pointer</a> to the transport connection that is being connected </td></tr>
    <tr><td class="paramname">con_timer</td><td><a class="el" href="struct_pointer.html">Pointer</a> to the timer in question </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call back </td></tr>
    <tr><td class="paramname">ec</td><td><a class="el" href="struct_a.html">A</a> status code indicating an error, if any. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_adf26b0ddc55fd6d223fd74be9e25d961_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_adf26b0ddc55fd6d223fd74be9e25d961_cgraph" alt=""/></div>
<!-- MAP 5 -->
</div>

</div>
</div>
<a id="ac240587f91cf837babbbb7c48b3cff40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac240587f91cf837babbbb7c48b3cff40">&#9670;&nbsp;</a></span>handle_resolve_timeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::handle_resolve_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#ac392fca34e946b48414278c0c3addfa5">connect_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DNS resolution timeout handler. </p>
<p>The timer pointer is included to ensure the timer isn't destroyed until after it has expired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns_timer</td><td><a class="el" href="struct_pointer.html">Pointer</a> to the timer in question </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call back </td></tr>
    <tr><td class="paramname">ec</td><td><a class="el" href="struct_a.html">A</a> status code indicating an error, if any. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ac240587f91cf837babbbb7c48b3cff40_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ac240587f91cf837babbbb7c48b3cff40_cgraph" alt=""/></div>
<!-- MAP 6 -->
</div>

</div>
</div>
<a id="a5345d9bbde4333d7b4b4858a4816e596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5345d9bbde4333d7b4b4858a4816e596">&#9670;&nbsp;</a></span>handle_timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::handle_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#a946cc56ff41139f3002149c15fd87bc9">timer_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::asio::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer handler. </p>
<p>The timer pointer is included to ensure the timer isn't destroyed until after it has expired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td><a class="el" href="struct_pointer.html">Pointer</a> to the timer in question </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call back </td></tr>
    <tr><td class="paramname">ec</td><td><a class="el" href="struct_a.html">A</a> status code indicating an error, if any. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a5345d9bbde4333d7b4b4858a4816e596_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a5345d9bbde4333d7b4b4858a4816e596_cgraph" alt=""/></div>
<!-- MAP 7 -->
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a5345d9bbde4333d7b4b4858a4816e596_icgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a5345d9bbde4333d7b4b4858a4816e596_icgraph" alt=""/></div>
<!-- MAP 8 -->
</div>

</div>
</div>
<a id="a756059ab3ecd99d7c2a845b40729c7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756059ab3ecd99d7c2a845b40729c7c8">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::error_code <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#ac5fc306f32d15f92dd1b22366eaba62d">transport_con_ptr</a>&#160;</td>
          <td class="paramname"><em>tcon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a connection. </p>
<p>init is called by an endpoint once for each newly created connection. It's purpose is to give the transport policy the chance to perform any transport specific initialization that couldn't be done via the default constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcon</td><td><a class="el" href="struct_a.html">A</a> pointer to the transport portion of the connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a.html">A</a> status code indicating the success or failure of the operation </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a756059ab3ecd99d7c2a845b40729c7c8_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a756059ab3ecd99d7c2a845b40729c7c8_cgraph" alt=""/></div>
<!-- MAP 9 -->
</div>

</div>
</div>
<a id="a67da637106d3cfb40078b477e2579a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67da637106d3cfb40078b477e2579a13">&#9670;&nbsp;</a></span>init_asio() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::init_asio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#acc7e89c6427514628f551cf3f795b7e0">io_service_ptr</a>&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize asio transport with external io_service (exception free) </p>
<p>Initialize the ASIO transport policy for this endpoint using the provided io_service object. asio_init must be called exactly once on any endpoint that uses <a class="el" href="namespacewebsocketpp_1_1transport_1_1asio.html" title="Transport policy that uses asio. ">transport::asio</a> before it can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_a.html">A</a> pointer to the io_service to use for asio events </td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a67da637106d3cfb40078b477e2579a13_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a67da637106d3cfb40078b477e2579a13_cgraph" alt=""/></div>
<!-- MAP 10 -->
</div>

</div>
</div>
<a id="a320fc4ea3a151afaf8b973ce32effd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320fc4ea3a151afaf8b973ce32effd25">&#9670;&nbsp;</a></span>init_asio() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::init_asio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#acc7e89c6427514628f551cf3f795b7e0">io_service_ptr</a>&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize asio transport with external io_service </p>
<p>Initialize the ASIO transport policy for this endpoint using the provided io_service object. asio_init must be called exactly once on any endpoint that uses <a class="el" href="namespacewebsocketpp_1_1transport_1_1asio.html" title="Transport policy that uses asio. ">transport::asio</a> before it can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_a.html">A</a> pointer to the io_service to use for asio events </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a320fc4ea3a151afaf8b973ce32effd25_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a320fc4ea3a151afaf8b973ce32effd25_cgraph" alt=""/></div>
<!-- MAP 11 -->
</div>

</div>
</div>
<a id="a7b4249fd3e2663323ac29ef7935278de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4249fd3e2663323ac29ef7935278de">&#9670;&nbsp;</a></span>init_asio() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::init_asio </td>
          <td>(</td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize asio transport with internal io_service (exception free) </p>
<p>This method of initialization will allocate and use an internally managed io_service.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a320fc4ea3a151afaf8b973ce32effd25" title="initialize asio transport with external io_service ">init_asio(io_service_ptr ptr)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a7b4249fd3e2663323ac29ef7935278de_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a7b4249fd3e2663323ac29ef7935278de_cgraph" alt=""/></div>
<!-- MAP 12 -->
</div>

</div>
</div>
<a id="a22938eec899a9ab2b9ada2b76172f798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22938eec899a9ab2b9ada2b76172f798">&#9670;&nbsp;</a></span>init_asio() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::init_asio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize asio transport with internal io_service. </p>
<p>This method of initialization will allocate and use an internally managed io_service.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a320fc4ea3a151afaf8b973ce32effd25" title="initialize asio transport with external io_service ">init_asio(io_service_ptr ptr)</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a22938eec899a9ab2b9ada2b76172f798_icgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a22938eec899a9ab2b9ada2b76172f798_icgraph" alt=""/></div>
<!-- MAP 13 -->
</div>

</div>
</div>
<a id="a26ad1ad26277ed99a691559e69d47932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ad1ad26277ed99a691559e69d47932">&#9670;&nbsp;</a></span>init_logging()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::init_logging </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#acba708e66a47d4aae9a053d364585b81">alog_type</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a2aa93730c801602b55b585121a2898c0">elog_type</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize logging. </p>
<p>The loggers are located in the main endpoint class. As such, the transport doesn't have direct access to them. This method is called by the endpoint constructor to allow shared logging from the transport component. These are raw pointers to member variables of the endpoint. In particular, they cannot be used in the transport constructor as they haven't been constructed yet, and cannot be used in the transport destructor as they will have been destroyed by then. </p>

</div>
</div>
<a id="af33506cbd90a184cdf1a0424ec2d0619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33506cbd90a184cdf1a0424ec2d0619">&#9670;&nbsp;</a></span>is_listening()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::is_listening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the endpoint is listening. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the endpoint is listening. </dd></dl>

</div>
</div>
<a id="ac36c2b22a7c2550663792472a728f615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36c2b22a7c2550663792472a728f615">&#9670;&nbsp;</a></span>listen() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">lib::asio::ip::tcp::endpoint&lt; <a class="el" href="classconfig.html">config</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up endpoint for listening manually (exception free) </p>
<p>Bind the internal acceptor using the specified settings. The endpoint must have been initialized by calling init_asio before listening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>An endpoint to read settings from </td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ac36c2b22a7c2550663792472a728f615_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ac36c2b22a7c2550663792472a728f615_cgraph" alt=""/></div>
<!-- MAP 14 -->
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ac36c2b22a7c2550663792472a728f615_icgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ac36c2b22a7c2550663792472a728f615_icgraph" alt=""/></div>
<!-- MAP 15 -->
</div>

</div>
</div>
<a id="ab3d7708b939531c5c803e3b148a9b009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d7708b939531c5c803e3b148a9b009">&#9670;&nbsp;</a></span>listen() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">lib::asio::ip::tcp::endpoint&lt; <a class="el" href="classconfig.html">config</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up endpoint for listening manually. </p>
<p>Bind the internal acceptor using the settings specified by the endpoint e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>An endpoint to read settings from </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ab3d7708b939531c5c803e3b148a9b009_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ab3d7708b939531c5c803e3b148a9b009_cgraph" alt=""/></div>
<!-- MAP 16 -->
</div>

</div>
</div>
<a id="ae6813b9ecda67a13a78967f72e77b061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6813b9ecda67a13a78967f72e77b061">&#9670;&nbsp;</a></span>listen() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<div class="memtemplate">
template&lt;typename InternetProtocol &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">InternetProtocol const &amp;&#160;</td>
          <td class="paramname"><em>internet_protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up endpoint for listening with protocol and port (exception free) </p>
<p>Bind the internal acceptor using the given internet protocol and port. The endpoint must have been initialized by calling init_asio before listening.</p>
<p>Common options include:</p><ul>
<li>IPv6 with mapped IPv4 for dual stack hosts lib::asio::ip::tcp::v6()</li>
<li>IPv4 only: lib::asio::ip::tcp::v4()</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internet_protocol</td><td>The internet protocol to use. </td></tr>
    <tr><td class="paramname">port</td><td>The port to listen on. </td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad08b16daae1fac46679245ec7d0c8952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08b16daae1fac46679245ec7d0c8952">&#9670;&nbsp;</a></span>listen() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<div class="memtemplate">
template&lt;typename InternetProtocol &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">InternetProtocol const &amp;&#160;</td>
          <td class="paramname"><em>internet_protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up endpoint for listening with protocol and port. </p>
<p>Bind the internal acceptor using the given internet protocol and port. The endpoint must have been initialized by calling init_asio before listening.</p>
<p>Common options include:</p><ul>
<li>IPv6 with mapped IPv4 for dual stack hosts lib::asio::ip::tcp::v6()</li>
<li>IPv4 only: lib::asio::ip::tcp::v4()</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internet_protocol</td><td>The internet protocol to use. </td></tr>
    <tr><td class="paramname">port</td><td>The port to listen on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7da6e2c944c3e1a087495b9d998dc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da6e2c944c3e1a087495b9d998dc8b">&#9670;&nbsp;</a></span>listen() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up endpoint for listening on a port (exception free) </p>
<p>Bind the internal acceptor using the given port. The IPv6 protocol with mapped IPv4 for dual stack hosts will be used. If you need IPv4 only use the overload that allows specifying the protocol explicitly.</p>
<p>The endpoint must have been initialized by calling init_asio before listening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to listen on. </td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80c1e2bb6edbfbfc46d387015e528117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c1e2bb6edbfbfc46d387015e528117">&#9670;&nbsp;</a></span>listen() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up endpoint for listening on a port. </p>
<p>Bind the internal acceptor using the given port. The IPv6 protocol with mapped IPv4 for dual stack hosts will be used. If you need IPv4 only use the overload that allows specifying the protocol explicitly.</p>
<p>The endpoint must have been initialized by calling init_asio before listening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to listen on. </td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85606665cc9c948194076c2377cb61c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85606665cc9c948194076c2377cb61c0">&#9670;&nbsp;</a></span>listen() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up endpoint for listening on a host and service (exception free) </p>
<p>Bind the internal acceptor using the given host and service. More details about what host and service can be are available in the Asio documentation for ip::basic_resolver_query::basic_resolver_query's constructors.</p>
<p>The endpoint must have been initialized by calling init_asio before listening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td><a class="el" href="struct_a.html">A</a> string identifying a location. May be a descriptive name or a numeric address string. </td></tr>
    <tr><td class="paramname">service</td><td><a class="el" href="struct_a.html">A</a> string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. </td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad69ca2f648f48c7616ad1df614d88d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69ca2f648f48c7616ad1df614d88d67">&#9670;&nbsp;</a></span>listen() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up endpoint for listening on a host and service. </p>
<p>Bind the internal acceptor using the given host and service. More details about what host and service can be are available in the Asio documentation for ip::basic_resolver_query::basic_resolver_query's constructors.</p>
<p>The endpoint must have been initialized by calling init_asio before listening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td><a class="el" href="struct_a.html">A</a> string identifying a location. May be a descriptive name or a numeric address string. </td></tr>
    <tr><td class="paramname">service</td><td><a class="el" href="struct_a.html">A</a> string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. </td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06b42e739e095b5ec489b59a655b2242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b42e739e095b5ec489b59a655b2242">&#9670;&nbsp;</a></span>run_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::run_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wraps the run_one method of the internal io_service object </p>
<dl class="section since"><dt>Since</dt><dd>0.3.0-alpha4 </dd></dl>

</div>
</div>
<a id="a60bb0d01c277b7cfcb6f69215a36b216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bb0d01c277b7cfcb6f69215a36b216">&#9670;&nbsp;</a></span>set_listen_backlog()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_listen_backlog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum length of the queue of pending connections. </p>
<p>Sets the maximum length of the queue of pending connections. Increasing this will allow WebSocket++ to queue additional incoming connections. Setting it higher may prevent failed connections at high connection rates but may cause additional latency.</p>
<p>For this value to take effect you may need to adjust operating system settings.</p>
<p>New values affect future calls to listen only.</p>
<p><a class="el" href="struct_a.html">A</a> value of zero will use the operating system default. This is the default value.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backlog</td><td>The maximum length of the queue of pending connections </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a491d13d6e1ad0edc5843e41b06fa4e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491d13d6e1ad0edc5843e41b06fa4e0c">&#9670;&nbsp;</a></span>set_reuse_addr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_reuse_addr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether to use the SO_REUSEADDR flag when opening listening sockets. </p>
<p>Specifies whether or not to use the SO_REUSEADDR TCP socket option. What this flag does depends on your operating system. Please consult operating system documentation for more details.</p>
<p>New values affect future calls to listen only.</p>
<p>The default is false.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Whether or not to use the SO_REUSEADDR option </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a497f353a5ec277355cd8b0caf893d1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497f353a5ec277355cd8b0caf893d1ce">&#9670;&nbsp;</a></span>set_tcp_init_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_tcp_init_handler </td>
          <td>(</td>
          <td class="paramtype">tcp_init_handler&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the tcp pre init handler (deprecated) </p>
<p>The tcp pre init handler is called after the raw tcp connection has been established but before any additional wrappers (proxy connects, TLS handshakes, etc) have been performed.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use set_tcp_pre_init_handler instead</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handler to call on tcp pre init. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a497f353a5ec277355cd8b0caf893d1ce_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a497f353a5ec277355cd8b0caf893d1ce_cgraph" alt=""/></div>
<!-- MAP 17 -->
</div>

</div>
</div>
<a id="a605c9f8c671d783739c1e98c6c7fda9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605c9f8c671d783739c1e98c6c7fda9d">&#9670;&nbsp;</a></span>set_tcp_post_init_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_tcp_post_init_handler </td>
          <td>(</td>
          <td class="paramtype">tcp_init_handler&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the tcp post init handler. </p>
<p>The tcp post init handler is called after the tcp connection has been established and all additional wrappers (proxy connects, TLS handshakes, etc have been performed. This is fired before any bytes are read or any WebSocket specific handshake logic has been performed.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handler to call on tcp post init. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad334b214cf4800bb34aa09d7055e6464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad334b214cf4800bb34aa09d7055e6464">&#9670;&nbsp;</a></span>set_tcp_pre_init_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_tcp_pre_init_handler </td>
          <td>(</td>
          <td class="paramtype">tcp_init_handler&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the tcp pre init handler. </p>
<p>The tcp pre init handler is called after the raw tcp connection has been established but before any additional wrappers (proxy connects, TLS handshakes, etc) have been performed.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handler to call on tcp pre init. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ad334b214cf4800bb34aa09d7055e6464_icgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_ad334b214cf4800bb34aa09d7055e6464_icgraph" alt=""/></div>
<!-- MAP 18 -->
</div>

</div>
</div>
<a id="a63525bd209bb3dabf373b9b72d37e78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63525bd209bb3dabf373b9b72d37e78e">&#9670;&nbsp;</a></span>set_timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html#a1802f5762009dbed117ff793fa87468f">timer_ptr</a> <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_timer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#a946cc56ff41139f3002149c15fd87bc9">timer_handler</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call back a function after a period of time. </p>
<p>Sets a timer that calls back a function after the specified period of milliseconds. Returns a handle that can be used to cancel the timer. <a class="el" href="struct_a.html">A</a> cancelled timer will return the error code <a class="el" href="namespacewebsocketpp_1_1transport_1_1error.html#a8d371a2562d813e5a2e106e2694d4fb0a887436887a8732e48f7c67bd85bb6f64" title="Operation aborted. ">error::operation_aborted</a> <a class="el" href="struct_a.html">A</a> timer that expired will return no error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>Length of time to wait in milliseconds </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call back when the timer has expired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a.html">A</a> handle that can be used to cancel the timer if it is no longer needed. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a63525bd209bb3dabf373b9b72d37e78e_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a63525bd209bb3dabf373b9b72d37e78e_cgraph" alt=""/></div>
<!-- MAP 19 -->
</div>

</div>
</div>
<a id="a5a707078d482c141edf0a8cdd0bc6345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a707078d482c141edf0a8cdd0bc6345">&#9670;&nbsp;</a></span>start_perpetual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::start_perpetual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the endpoint as perpetual, stopping it from exiting when empty. </p>
<p>Marks the endpoint as perpetual. Perpetual endpoints will not automatically exit when they run out of connections to process. To stop a perpetual endpoint call <code>end_perpetual</code>.</p>
<p>An endpoint may be marked perpetual at any time by any thread. It must be called either before the endpoint has run out of work or before it was started</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0 </dd></dl>

</div>
</div>
<a id="a0da87d3a3e8ee8279fe59eb0385d81e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da87d3a3e8ee8279fe59eb0385d81e3">&#9670;&nbsp;</a></span>stop_listening() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::stop_listening </td>
          <td>(</td>
          <td class="paramtype">lib::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop listening (exception free) </p>
<p>Stop listening and accepting new connections. This will not end any existing connections.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0-alpha4 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td><a class="el" href="struct_a.html">A</a> status code indicating an error, if any. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a0da87d3a3e8ee8279fe59eb0385d81e3_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1asio_1_1endpoint_a0da87d3a3e8ee8279fe59eb0385d81e3_cgraph" alt=""/></div>
<!-- MAP 20 -->
</div>

</div>
</div>
<a id="af4ae00e12a34475a1950d69f5b9da507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ae00e12a34475a1950d69f5b9da507">&#9670;&nbsp;</a></span>stop_listening() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::stop_listening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop listening. </p>
<p>Stop listening and accepting new connections. This will not end any existing connections.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0-alpha4 </dd></dl>

</div>
</div>
<a id="aaaf8c9ef3f41be6968674bd704dc23b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf8c9ef3f41be6968674bd704dc23b0">&#9670;&nbsp;</a></span>stop_perpetual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1asio_1_1endpoint.html">websocketpp::transport::asio::endpoint</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::stop_perpetual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the endpoint's perpetual flag, allowing it to exit when empty. </p>
<p>Clears the endpoint's perpetual flag. This will cause the endpoint's run method to exit normally when it runs out of connections. If there are currently active connections it will not end until they are complete.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libraries/fc/vendor/websocketpp/websocketpp/transport/asio/<a class="el" href="fc_2vendor_2websocketpp_2websocketpp_2transport_2asio_2base_8hpp_source.html">base.hpp</a></li>
<li>libraries/fc/vendor/websocketpp/websocketpp/transport/asio/<a class="el" href="transport_2asio_2endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
