<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Acute-Angle-Chain: websocketpp::transport::debug::connection&lt; config &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="aac-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Acute-Angle-Chain
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewebsocketpp.html">websocketpp</a></li><li class="navelem"><a class="el" href="namespacewebsocketpp_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespacewebsocketpp_1_1transport_1_1debug.html">debug</a></li><li class="navelem"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classwebsocketpp_1_1transport_1_1debug_1_1connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">websocketpp::transport::debug::connection&lt; config &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for websocketpp::transport::debug::connection&lt; config &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1debug_1_1connection__inherit__graph.png" border="0" usemap="#websocketpp_1_1transport_1_1debug_1_1connection_3_01config_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for websocketpp::transport::debug::connection&lt; config &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1debug_1_1connection__coll__graph.png" border="0" usemap="#websocketpp_1_1transport_1_1debug_1_1connection_3_01config_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7ba7dc8bc337d2734b3c4651f4fa8056"><td class="memItemLeft" align="right" valign="top"><a id="a7ba7dc8bc337d2734b3c4651f4fa8056"></a>
typedef <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a7ba7dc8bc337d2734b3c4651f4fa8056">type</a></td></tr>
<tr class="memdesc:a7ba7dc8bc337d2734b3c4651f4fa8056"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of this connection transport component. <br /></td></tr>
<tr class="separator:a7ba7dc8bc337d2734b3c4651f4fa8056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40631f93557c3308c2c8c7897e6a4825"><td class="memItemLeft" align="right" valign="top"><a id="a40631f93557c3308c2c8c7897e6a4825"></a>
typedef lib::shared_ptr&lt; <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a7ba7dc8bc337d2734b3c4651f4fa8056">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a40631f93557c3308c2c8c7897e6a4825">ptr</a></td></tr>
<tr class="memdesc:a40631f93557c3308c2c8c7897e6a4825"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of a shared pointer to this connection transport component. <br /></td></tr>
<tr class="separator:a40631f93557c3308c2c8c7897e6a4825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42b4d8fcad5351005adbaaee072daec"><td class="memItemLeft" align="right" valign="top"><a id="ae42b4d8fcad5351005adbaaee072daec"></a>
typedef <a class="el" href="classwebsocketpp_1_1concurrency_1_1none.html">config::concurrency_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#ae42b4d8fcad5351005adbaaee072daec">concurrency_type</a></td></tr>
<tr class="memdesc:ae42b4d8fcad5351005adbaaee072daec"><td class="mdescLeft">&#160;</td><td class="mdescRight">transport concurrency policy <br /></td></tr>
<tr class="separator:ae42b4d8fcad5351005adbaaee072daec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4041875e69d6a33ed4f27055fd9d6409"><td class="memItemLeft" align="right" valign="top"><a id="a4041875e69d6a33ed4f27055fd9d6409"></a>
typedef <a class="el" href="classwebsocketpp_1_1log_1_1stub.html">config::alog_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a4041875e69d6a33ed4f27055fd9d6409">alog_type</a></td></tr>
<tr class="memdesc:a4041875e69d6a33ed4f27055fd9d6409"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of this transport's access logging policy. <br /></td></tr>
<tr class="separator:a4041875e69d6a33ed4f27055fd9d6409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38501811c59ca185f0dde7fa7fa8486f"><td class="memItemLeft" align="right" valign="top"><a id="a38501811c59ca185f0dde7fa7fa8486f"></a>
typedef <a class="el" href="classwebsocketpp_1_1log_1_1stub.html">config::elog_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a38501811c59ca185f0dde7fa7fa8486f">elog_type</a></td></tr>
<tr class="memdesc:a38501811c59ca185f0dde7fa7fa8486f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_type.html">Type</a> of this transport's error logging policy. <br /></td></tr>
<tr class="separator:a38501811c59ca185f0dde7fa7fa8486f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6745c077e1f67447a8894c50699ad5d1"><td class="memItemLeft" align="right" valign="top"><a id="a6745c077e1f67447a8894c50699ad5d1"></a>
typedef <a class="el" href="classwebsocketpp_1_1concurrency_1_1none.html#af2d121eeb6202694819578ba4bb00d3e">concurrency_type::scoped_lock_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scoped_lock_type</b></td></tr>
<tr class="separator:a6745c077e1f67447a8894c50699ad5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3883614ff681edac3ee6556462636103"><td class="memItemLeft" align="right" valign="top"><a id="a3883614ff681edac3ee6556462636103"></a>
typedef <a class="el" href="classwebsocketpp_1_1concurrency_1_1none.html#a3cf002cfc62e64e920a91a06f5e6fbc3">concurrency_type::mutex_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mutex_type</b></td></tr>
<tr class="separator:a3883614ff681edac3ee6556462636103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ac093c337944c0d17422b090cc1e62"><td class="memItemLeft" align="right" valign="top"><a id="a92ac093c337944c0d17422b090cc1e62"></a>
typedef lib::shared_ptr&lt; <a class="el" href="structwebsocketpp_1_1transport_1_1debug_1_1timer.html">timer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>timer_ptr</b></td></tr>
<tr class="separator:a92ac093c337944c0d17422b090cc1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aebfb59b75e4beecf743f9f6f6cc599ff"><td class="memItemLeft" align="right" valign="top"><a id="aebfb59b75e4beecf743f9f6f6cc599ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>connection</b> (bool is_server, <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a4041875e69d6a33ed4f27055fd9d6409">alog_type</a> &amp;alog, <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a38501811c59ca185f0dde7fa7fa8486f">elog_type</a> &amp;elog)</td></tr>
<tr class="separator:aebfb59b75e4beecf743f9f6f6cc599ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100e8592dd57f19971d933b2b47ef820"><td class="memItemLeft" align="right" valign="top"><a id="a100e8592dd57f19971d933b2b47ef820"></a>
<a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a40631f93557c3308c2c8c7897e6a4825">ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a100e8592dd57f19971d933b2b47ef820">get_shared</a> ()</td></tr>
<tr class="memdesc:a100e8592dd57f19971d933b2b47ef820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to this component. <br /></td></tr>
<tr class="separator:a100e8592dd57f19971d933b2b47ef820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70244283cf80113e73f6dda8c1a2c4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a70244283cf80113e73f6dda8c1a2c4be">set_secure</a> (bool)</td></tr>
<tr class="memdesc:a70244283cf80113e73f6dda8c1a2c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether or not this connection is secure.  <a href="#a70244283cf80113e73f6dda8c1a2c4be">More...</a><br /></td></tr>
<tr class="separator:a70244283cf80113e73f6dda8c1a2c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c3bba737ddb4a2ef6bf0c3b40fd130"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a49c3bba737ddb4a2ef6bf0c3b40fd130">is_secure</a> () const</td></tr>
<tr class="memdesc:a49c3bba737ddb4a2ef6bf0c3b40fd130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether or not the underlying transport is secure.  <a href="#a49c3bba737ddb4a2ef6bf0c3b40fd130">More...</a><br /></td></tr>
<tr class="separator:a49c3bba737ddb4a2ef6bf0c3b40fd130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a06b3bfd0bd2b61822724c99911f1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a30a06b3bfd0bd2b61822724c99911f1c">set_uri</a> (<a class="el" href="namespacewebsocketpp.html#aae370ea5ac83a8ece7712cb39fc23f5b">uri_ptr</a>)</td></tr>
<tr class="memdesc:a30a06b3bfd0bd2b61822724c99911f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set uri hook.  <a href="#a30a06b3bfd0bd2b61822724c99911f1c">More...</a><br /></td></tr>
<tr class="separator:a30a06b3bfd0bd2b61822724c99911f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0a3a5bc888a570c287190d299cf276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a3c0a3a5bc888a570c287190d299cf276">set_remote_endpoint</a> (std::string)</td></tr>
<tr class="memdesc:a3c0a3a5bc888a570c287190d299cf276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set human readable remote endpoint address.  <a href="#a3c0a3a5bc888a570c287190d299cf276">More...</a><br /></td></tr>
<tr class="separator:a3c0a3a5bc888a570c287190d299cf276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e32def2e7de74a13684571cccce494b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a8e32def2e7de74a13684571cccce494b">get_remote_endpoint</a> () const</td></tr>
<tr class="memdesc:a8e32def2e7de74a13684571cccce494b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get human readable remote endpoint address.  <a href="#a8e32def2e7de74a13684571cccce494b">More...</a><br /></td></tr>
<tr class="separator:a8e32def2e7de74a13684571cccce494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258046ad6f04c2fe9d3b31da345c282f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">connection_hdl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a258046ad6f04c2fe9d3b31da345c282f">get_handle</a> () const</td></tr>
<tr class="memdesc:a258046ad6f04c2fe9d3b31da345c282f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the connection handle.  <a href="#a258046ad6f04c2fe9d3b31da345c282f">More...</a><br /></td></tr>
<tr class="separator:a258046ad6f04c2fe9d3b31da345c282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b96fed344bafbbb0453997dbf54f40"><td class="memItemLeft" align="right" valign="top">timer_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a56b96fed344bafbbb0453997dbf54f40">set_timer</a> (long, <a class="el" href="namespacewebsocketpp_1_1transport.html#a946cc56ff41139f3002149c15fd87bc9">timer_handler</a> handler)</td></tr>
<tr class="memdesc:a56b96fed344bafbbb0453997dbf54f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call back a function after a period of time.  <a href="#a56b96fed344bafbbb0453997dbf54f40">More...</a><br /></td></tr>
<tr class="separator:a56b96fed344bafbbb0453997dbf54f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7e0c517495dd8bdbecfa75c5a9d7b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a36a7e0c517495dd8bdbecfa75c5a9d7b">read_all</a> (char const *buf, size_t len)</td></tr>
<tr class="memdesc:a36a7e0c517495dd8bdbecfa75c5a9d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual input supply (read all)  <a href="#a36a7e0c517495dd8bdbecfa75c5a9d7b">More...</a><br /></td></tr>
<tr class="separator:a36a7e0c517495dd8bdbecfa75c5a9d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05593a3cbd005194ea0e822631d629ce"><td class="memItemLeft" align="right" valign="top"><a id="a05593a3cbd005194ea0e822631d629ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>expire_timer</b> (lib::error_code const &amp;ec)</td></tr>
<tr class="separator:a05593a3cbd005194ea0e822631d629ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d8858b47eeccbd9d8bfd8b8e4f4a9a"><td class="memItemLeft" align="right" valign="top"><a id="a53d8858b47eeccbd9d8bfd8b8e4f4a9a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fullfil_write</b> ()</td></tr>
<tr class="separator:a53d8858b47eeccbd9d8bfd8b8e4f4a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1ed8a6a163997f22ab3977c58514d607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a1ed8a6a163997f22ab3977c58514d607">init</a> (<a class="el" href="namespacewebsocketpp_1_1transport.html#aeae75e675c1a334b3b33ab7120b480a5">init_handler</a> handler)</td></tr>
<tr class="memdesc:a1ed8a6a163997f22ab3977c58514d607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the connection transport.  <a href="#a1ed8a6a163997f22ab3977c58514d607">More...</a><br /></td></tr>
<tr class="separator:a1ed8a6a163997f22ab3977c58514d607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd1522c7700b42b9d54b32d394e32fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a9dd1522c7700b42b9d54b32d394e32fe">async_read_at_least</a> (size_t num_bytes, char *buf, size_t len, <a class="el" href="namespacewebsocketpp_1_1transport.html#a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb">read_handler</a> handler)</td></tr>
<tr class="memdesc:a9dd1522c7700b42b9d54b32d394e32fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate an async_read for at least num_bytes bytes into buf.  <a href="#a9dd1522c7700b42b9d54b32d394e32fe">More...</a><br /></td></tr>
<tr class="separator:a9dd1522c7700b42b9d54b32d394e32fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc282f30447d46911cd54f676fe0a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#aecc282f30447d46911cd54f676fe0a73">async_write</a> (char const *, size_t, <a class="el" href="namespacewebsocketpp_1_1transport.html#addf5d728159e7aa2bce2a0df947b1560">write_handler</a> handler)</td></tr>
<tr class="memdesc:aecc282f30447d46911cd54f676fe0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronous Transport Write.  <a href="#aecc282f30447d46911cd54f676fe0a73">More...</a><br /></td></tr>
<tr class="separator:aecc282f30447d46911cd54f676fe0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a648a7501f13845fe6708fab59ac1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#af8a648a7501f13845fe6708fab59ac1f">async_write</a> (<a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="structwebsocketpp_1_1transport_1_1buffer.html">buffer</a> &gt; const &amp;, <a class="el" href="namespacewebsocketpp_1_1transport.html#addf5d728159e7aa2bce2a0df947b1560">write_handler</a> handler)</td></tr>
<tr class="memdesc:af8a648a7501f13845fe6708fab59ac1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronous Transport Write (scatter-gather)  <a href="#af8a648a7501f13845fe6708fab59ac1f">More...</a><br /></td></tr>
<tr class="separator:af8a648a7501f13845fe6708fab59ac1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdbe8c6860526e66b651ddd402f9cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#affdbe8c6860526e66b651ddd402f9cf3">set_handle</a> (<a class="el" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">connection_hdl</a>)</td></tr>
<tr class="memdesc:affdbe8c6860526e66b651ddd402f9cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Connection Handle.  <a href="#affdbe8c6860526e66b651ddd402f9cf3">More...</a><br /></td></tr>
<tr class="separator:affdbe8c6860526e66b651ddd402f9cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cac08eb7b8646fc042d465b3bb645a6"><td class="memItemLeft" align="right" valign="top">lib::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a4cac08eb7b8646fc042d465b3bb645a6">dispatch</a> (<a class="el" href="namespacewebsocketpp_1_1transport.html#a6658447b2e10f4c712dd792aad0e0c78">dispatch_handler</a> handler)</td></tr>
<tr class="memdesc:a4cac08eb7b8646fc042d465b3bb645a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call given handler back within the transport's event system (if present)  <a href="#a4cac08eb7b8646fc042d465b3bb645a6">More...</a><br /></td></tr>
<tr class="separator:a4cac08eb7b8646fc042d465b3bb645a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1269aca10cf5de3cf031eac5f499075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#aa1269aca10cf5de3cf031eac5f499075">async_shutdown</a> (<a class="el" href="namespacewebsocketpp_1_1transport.html#af39aff6fc4cb76f7df0d5322b734d156">shutdown_handler</a> handler)</td></tr>
<tr class="memdesc:aa1269aca10cf5de3cf031eac5f499075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cleanup on socket shutdown_handler.  <a href="#aa1269aca10cf5de3cf031eac5f499075">More...</a><br /></td></tr>
<tr class="separator:aa1269aca10cf5de3cf031eac5f499075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e17152ea6389887e1a19da2ca53cf8b"><td class="memItemLeft" align="right" valign="top"><a id="a7e17152ea6389887e1a19da2ca53cf8b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>read_some_impl</b> (char const *buf, size_t len)</td></tr>
<tr class="separator:a7e17152ea6389887e1a19da2ca53cf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb6d0259dfd111b99edc1edae4014f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html#a1eb6d0259dfd111b99edc1edae4014f5">complete_read</a> (lib::error_code const &amp;ec)</td></tr>
<tr class="memdesc:a1eb6d0259dfd111b99edc1edae4014f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that a requested read is complete.  <a href="#a1eb6d0259dfd111b99edc1edae4014f5">More...</a><br /></td></tr>
<tr class="separator:a1eb6d0259dfd111b99edc1edae4014f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9dd1522c7700b42b9d54b32d394e32fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd1522c7700b42b9d54b32d394e32fe">&#9670;&nbsp;</a></span>async_read_at_least()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::async_read_at_least </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#a3a9b2ed54dfcc6ebe7d7e6b4c02f53fb">read_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiate an async_read for at least num_bytes bytes into buf. </p>
<p>Initiates an async_read request for at least num_bytes bytes. The input will be read into buf. <a class="el" href="struct_a.html">A</a> maximum of len bytes will be input. When the operation is complete, handler will be called with the status and number of bytes read.</p>
<p>This method may or may not call handler from within the initial call. The application should be prepared to accept either.</p>
<p>The application should never call this method a second time before it has been called back for the first read. If this is done, the second read will be called back immediately with a double_read error.</p>
<p>If num_bytes or len are zero handler will be called back immediately indicating success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_bytes</td><td>Don't call handler until at least this many bytes have been read. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to read bytes into </td></tr>
    <tr><td class="paramname">len</td><td>The size of buf. At maximum, this many bytes will be read. </td></tr>
    <tr><td class="paramname">handler</td><td>The callback to invoke when the operation is complete or ends in an error </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1debug_1_1connection_a9dd1522c7700b42b9d54b32d394e32fe_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1debug_1_1connection_a9dd1522c7700b42b9d54b32d394e32fe_cgraph" alt=""/></div>
<!-- MAP 2 -->
</div>

</div>
</div>
<a id="aa1269aca10cf5de3cf031eac5f499075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1269aca10cf5de3cf031eac5f499075">&#9670;&nbsp;</a></span>async_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::async_shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#af39aff6fc4cb76f7df0d5322b734d156">shutdown_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform cleanup on socket shutdown_handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The <code>shutdown_handler</code> to call back when complete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecc282f30447d46911cd54f676fe0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc282f30447d46911cd54f676fe0a73">&#9670;&nbsp;</a></span>async_write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::async_write </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#addf5d728159e7aa2bce2a0df947b1560">write_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asyncronous Transport Write. </p>
<p>Write len bytes in buf to the output stream. Call handler to report success or failure. handler may or may not be called during async_write, but it must be safe for this to happen.</p>
<p>Will return 0 on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to read bytes from </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to write </td></tr>
    <tr><td class="paramname">handler</td><td>Callback to invoke with operation status. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1debug_1_1connection_aecc282f30447d46911cd54f676fe0a73_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1debug_1_1connection_aecc282f30447d46911cd54f676fe0a73_cgraph" alt=""/></div>
<!-- MAP 3 -->
</div>

</div>
</div>
<a id="af8a648a7501f13845fe6708fab59ac1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a648a7501f13845fe6708fab59ac1f">&#9670;&nbsp;</a></span>async_write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::async_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="structwebsocketpp_1_1transport_1_1buffer.html">buffer</a> &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#addf5d728159e7aa2bce2a0df947b1560">write_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asyncronous Transport Write (scatter-gather) </p>
<p>Write a sequence of buffers to the output stream. Call handler to report success or failure. handler may or may not be called during async_write, but it must be safe for this to happen.</p>
<p>Will return 0 on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufs</td><td>vector of buffers to write </td></tr>
    <tr><td class="paramname">handler</td><td>Callback to invoke with operation status. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1debug_1_1connection_af8a648a7501f13845fe6708fab59ac1f_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1debug_1_1connection_af8a648a7501f13845fe6708fab59ac1f_cgraph" alt=""/></div>
<!-- MAP 4 -->
</div>

</div>
</div>
<a id="a1eb6d0259dfd111b99edc1edae4014f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb6d0259dfd111b99edc1edae4014f5">&#9670;&nbsp;</a></span>complete_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::complete_read </td>
          <td>(</td>
          <td class="paramtype">lib::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal that a requested read is complete. </p>
<p>Sets the reading flag to false and returns the handler that should be called back with the result of the read. The cursor position that is sent is whatever the value of m_cursor is.</p>
<p>It MUST NOT be called when m_reading is false. it MUST be called while holding the read lock</p>
<p>It is important to use this method rather than directly setting/calling m_read_handler back because this function makes sure to delete the locally stored handler which contains shared pointers that will otherwise cause circular reference based memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>The error code to forward to the read handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cac08eb7b8646fc042d465b3bb645a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cac08eb7b8646fc042d465b3bb645a6">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lib::error_code <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#a6658447b2e10f4c712dd792aad0e0c78">dispatch_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call given handler back within the transport's event system (if present) </p>
<p>Invoke a callback within the transport's event system if it has one. If it doesn't, the handler will be invoked immediately before this function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The callback to invoke</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the transport was able to register the handler for callback. </dd></dl>

</div>
</div>
<a id="a258046ad6f04c2fe9d3b31da345c282f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258046ad6f04c2fe9d3b31da345c282f">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">connection_hdl</a> <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::get_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the connection handle. </p>
<dl class="section return"><dt>Returns</dt><dd>The handle for this connection. </dd></dl>

</div>
</div>
<a id="a8e32def2e7de74a13684571cccce494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e32def2e7de74a13684571cccce494b">&#9670;&nbsp;</a></span>get_remote_endpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::get_remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get human readable remote endpoint address. </p>
<p>TODO: docs</p>
<p>This value is used in access and error logs and is available to the end application for including in user facing interfaces and messages.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a.html">A</a> string identifying the address of the remote endpoint </dd></dl>

</div>
</div>
<a id="a1ed8a6a163997f22ab3977c58514d607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed8a6a163997f22ab3977c58514d607">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#aeae75e675c1a334b3b33ab7120b480a5">init_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the connection transport. </p>
<p>Initialize the connection's transport component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The <code>init_handler</code> to call when initialization is done </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1debug_1_1connection_a1ed8a6a163997f22ab3977c58514d607_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1debug_1_1connection_a1ed8a6a163997f22ab3977c58514d607_cgraph" alt=""/></div>
<!-- MAP 5 -->
</div>

</div>
</div>
<a id="a49c3bba737ddb4a2ef6bf0c3b40fd130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c3bba737ddb4a2ef6bf0c3b40fd130">&#9670;&nbsp;</a></span>is_secure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::is_secure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether or not the underlying transport is secure. </p>
<p>TODO: docs</p>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the underlying transport is secure </dd></dl>

</div>
</div>
<a id="a36a7e0c517495dd8bdbecfa75c5a9d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a7e0c517495dd8bdbecfa75c5a9d7b">&#9670;&nbsp;</a></span>read_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::read_all </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manual input supply (read all) </p>
<p>Similar to read_some, but continues to read until all bytes in the supplied buffer have been read or the connection runs out of read requests.</p>
<p>This method still may not read all of the bytes in the input buffer. if it doesn't it indicates that the connection was most likely closed or is in an error state where it is no longer accepting new input.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Char buffer to read into the websocket </td></tr>
    <tr><td class="paramname">len</td><td>Length of buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters from buf actually read. </dd></dl>

</div>
</div>
<a id="affdbe8c6860526e66b651ddd402f9cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdbe8c6860526e66b651ddd402f9cf3">&#9670;&nbsp;</a></span>set_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp.html#a6b3d26a10ee7229b84b776786332631d">connection_hdl</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set Connection Handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hdl</td><td>The new handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c0a3a5bc888a570c287190d299cf276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0a3a5bc888a570c287190d299cf276">&#9670;&nbsp;</a></span>set_remote_endpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_remote_endpoint </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set human readable remote endpoint address. </p>
<p>Sets the remote endpoint address returned by <code>get_remote_endpoint</code>. This value should be a human readable string that describes the remote endpoint. Typically an IP address or hostname, perhaps with a port. But may be something else depending on the nature of the underlying transport.</p>
<p>If none is set a default is returned.</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0-alpha4</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The remote endpoint address to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70244283cf80113e73f6dda8c1a2c4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70244283cf80113e73f6dda8c1a2c4be">&#9670;&nbsp;</a></span>set_secure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_secure </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether or not this connection is secure. </p>
<p>Todo: docs</p>
<dl class="section since"><dt>Since</dt><dd>0.3.0-alpha4</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Whether or not this connection is secure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56b96fed344bafbbb0453997dbf54f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b96fed344bafbbb0453997dbf54f40">&#9670;&nbsp;</a></span>set_timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">timer_ptr <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_timer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp_1_1transport.html#a946cc56ff41139f3002149c15fd87bc9">timer_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call back a function after a period of time. </p>
<p>Timers are not implemented in this transport. The timer pointer will always be empty. The handler will never be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>Length of time to wait in milliseconds </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call back when the timer has expired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a.html">A</a> handle that can be used to cancel the timer if it is no longer needed. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classwebsocketpp_1_1transport_1_1debug_1_1connection_a56b96fed344bafbbb0453997dbf54f40_cgraph.png" border="0" usemap="#classwebsocketpp_1_1transport_1_1debug_1_1connection_a56b96fed344bafbbb0453997dbf54f40_cgraph" alt=""/></div>
<!-- MAP 6 -->
</div>

</div>
</div>
<a id="a30a06b3bfd0bd2b61822724c99911f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a06b3bfd0bd2b61822724c99911f1c">&#9670;&nbsp;</a></span>set_uri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwebsocketpp_1_1transport_1_1debug_1_1connection.html">websocketpp::transport::debug::connection</a>&lt; <a class="el" href="classconfig.html">config</a> &gt;::set_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewebsocketpp.html#aae370ea5ac83a8ece7712cb39fc23f5b">uri_ptr</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set uri hook. </p>
<p>Called by the endpoint as a connection is being established to provide the uri being connected to to the transport layer.</p>
<p>Implementation is optional and can be ignored if the transport has no need for this information.</p>
<dl class="section since"><dt>Since</dt><dd>0.6.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The uri to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libraries/fc/vendor/websocketpp/websocketpp/transport/debug/<a class="el" href="transport_2debug_2connection_8hpp_source.html">connection.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
